<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>viewer\viewer_init.js - 资料库</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="资料库"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/_fileup.html">_fileup</a></li>
            
                <li><a href="../classes/db_print.html">db_print</a></li>
            
                <li><a href="../classes/disk.html">disk</a></li>
            
                <li><a href="../classes/fc.html">fc</a></li>
            
                <li><a href="../classes/select.html">select</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: viewer\viewer_init.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals PDFJS, PDFBug, FirefoxCom, Stats, Cache, CustomStyle,
           ProgressBar, TextLayerBuilder, 
           getFileName, getOutputScale, scrollIntoView, getPDFFileNameFromURL,
           PDFHistory, noContextMenuHandler */

&#x27;use strict&#x27;;
var require_script = [&#x27;&lt;!--#endif--&gt;&#x27;,
	&#x27;&lt;!--#if !(FIREFOX || MOZCENTRAL || CHROME)--&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;compatibility.js&quot;&gt;&lt;/script&gt;&#x27;,
	&#x27;&lt;!--#endif--&gt;&#x27;,	
	&#x27;&lt;!--#if !PRODUCTION--&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/external/webL10n/l10n.js&quot;&gt;&lt;/script&gt;&#x27;,
	&#x27;&lt;!--#endif--&gt;&#x27;,
	&#x27;&lt;!--#if !PRODUCTION--&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/shared/util.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/shared/colorspace.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/shared/pattern.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/shared/function.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/shared/annotation.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/display/api.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/display/metadata.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/display/canvas.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/display/font_loader.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/viewer/src/display/font_renderer.js&quot;&gt;&lt;/script&gt;&#x27;,
	&#x27;&lt;!--#endif--&gt;&#x27;,
	&#x27;&lt;!--#if GENERIC || CHROME--&gt;&#x27;,
	&#x27;&lt;!--#include viewer-snippet.html--&gt;&#x27;,
	&#x27;&lt;!--#endif--&gt;&#x27;,
	&#x27;&lt;!--#if !PRODUCTION--&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;ui_utils.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;text_layer_builder.js&quot;&gt;&lt;/script&gt;&#x27;,
		&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;pdf_history.js&quot;&gt;&lt;/script&gt;&#x27;,
	&#x27;&lt;!--#endif--&gt;&#x27;,	
	&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;debugger.js&quot;&gt;&lt;/script&gt;&#x27;
];

$(&#x27;head&#x27;).append(require_script.join(&#x27;&#x27;))

PDFJS.workerSrc = &#x27;/public/disk/js/viewer/src/worker_loader.js&#x27;;
var DEFAULT_URL = &#x27;/viewer/abc.pdf&#x27;;
var DEFAULT_SCALE = &#x27;auto&#x27;;
var DEFAULT_SCALE_DELTA = 1.1;
var UNKNOWN_SCALE = 0;
var CACHE_SIZE = 20;
var CSS_UNITS = 96.0 / 72.0;
var SCROLLBAR_PADDING = 40;
var VERTICAL_PADDING = 5;
var MIN_SCALE = 0.25;
var MAX_SCALE = 4.0;
var SETTINGS_MEMORY = 20;
var SCALE_SELECT_CONTAINER_PADDING = 8;
var SCALE_SELECT_PADDING = 22;
var RenderingStates = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
};

PDFJS.imageResourcesPath = &#x27;./images/&#x27;;
//#if (FIREFOX || MOZCENTRAL || B2G || GENERIC || CHROME)
//PDFJS.workerSrc = &#x27;../build/pdf.worker.js&#x27;;
//#endif

var mozL10n = document.mozL10n || document.webL10n;

//#include ui_utils.js
//#if GENERIC || CHROME
//#endif

//#if FIREFOX || MOZCENTRAL
//#include firefoxcom.js
//#endif

// Settings Manager - This is a utility for saving settings
// First we see if localStorage is available
// If not, we use FUEL in FF
// Use asyncStorage for B2G
var Settings = (function SettingsClosure() {
//#if !(FIREFOX || MOZCENTRAL || B2G)
  var isLocalStorageEnabled = (function localStorageEnabledTest() {
    // Feature test as per http://diveintohtml5.info/storage.html
    // The additional localStorage call is to get around a FF quirk, see
    // bug #495747 in bugzilla
    try {
      return &#x27;localStorage&#x27; in window &amp;&amp; window[&#x27;localStorage&#x27;] !== null &amp;&amp;
          localStorage;
    } catch (e) {
      return false;
    }
  })();
//#endif

  function Settings(fingerprint) {
    this.fingerprint = fingerprint;
    this.initializedPromise = new PDFJS.Promise();

    var resolvePromise = (function settingsResolvePromise(db) {
      this.initialize(db || &#x27;{}&#x27;);
      this.initializedPromise.resolve();
    }).bind(this);

//#if !(FIREFOX || MOZCENTRAL || B2G)
    if (isLocalStorageEnabled)
      resolvePromise(localStorage.getItem(&#x27;database&#x27;));
//#endif
  }

  Settings.prototype = {
    initialize: function settingsInitialize(database) {
      database = JSON.parse(database);
      if (!(&#x27;files&#x27; in database))
        database.files = [];
      if (database.files.length &gt;= SETTINGS_MEMORY)
        database.files.shift();
      var index;
      for (var i = 0, length = database.files.length; i &lt; length; i++) {
        var branch = database.files[i];
        if (branch.fingerprint == this.fingerprint) {
          index = i;
          break;
        }
      }
      if (typeof index != &#x27;number&#x27;)
        index = database.files.push({fingerprint: this.fingerprint}) - 1;
      this.file = database.files[index];
      this.database = database;
    },

    set: function settingsSet(name, val) {
      if (!this.initializedPromise.isResolved)
        return;

      var file = this.file;
      file[name] = val;
      var database = JSON.stringify(this.database);

//#if B2G
//    asyncStorage.setItem(&#x27;database&#x27;, database);
//#endif

//#if FIREFOX || MOZCENTRAL
//    FirefoxCom.requestSync(&#x27;setDatabase&#x27;, database);
//#endif

//#if !(FIREFOX || MOZCENTRAL || B2G)
      if (isLocalStorageEnabled)
        localStorage.setItem(&#x27;database&#x27;, database);
//#endif
    },

    get: function settingsGet(name, defaultValue) {
      if (!this.initializedPromise.isResolved)
        return defaultValue;

      return this.file[name] || defaultValue;
    }
  };

  return Settings;
})();

var cache = new Cache(CACHE_SIZE);
var currentPageNumber = 1;

// TODO: Enable the FindBar *AFTER* the pagesPromise in the load function
// got resolved
//#include pdf_find_bar.js
//#include pdf_find_controller.js
//#include pdf_history.js

var PDFView = {
  pages: [],
  currentScale: UNKNOWN_SCALE,
  currentScaleValue: null,
  initialBookmark: document.location.hash.substring(1),
  startedTextExtraction: false,
  pageText: [],
  container: null,
  initialized: false,
  fellback: false,
  pdfDocument: null,
  pageViewScroll: null,
  isPresentationMode: false,
  presentationModeArgs: null,
  pageRotation: 0,
  mouseScrollTimeStamp: 0,
  mouseScrollDelta: 0,
  lastScroll: 0,
  previousPageNumber: 1,
  isViewerEmbedded: (window.parent !== window),

  // called once when the document is loaded
  initialize: function pdfViewInitialize() {
    var self = this;
    var container = this.container = document.getElementById(&#x27;viewerContainer&#x27;);
    this.pageViewScroll = {};
    this.watchScroll(container, this.pageViewScroll, updateViewarea);

    this.initialized = true;
    container.addEventListener(&#x27;scroll&#x27;, function() {
      self.lastScroll = Date.now();
    }, false);
  },

  getPage: function pdfViewGetPage(n) {
    return this.pdfDocument.getPage(n);
  },

  // Helper function to keep track whether a div was scrolled up or down and
  // then call a callback.
  watchScroll: function pdfViewWatchScroll(viewAreaElement, state, callback) {
    state.down = true;
    state.lastY = viewAreaElement.scrollTop;
    viewAreaElement.addEventListener(&#x27;scroll&#x27;, function webViewerScroll(evt) {
      var currentY = viewAreaElement.scrollTop;
      var lastY = state.lastY;
      if (currentY &gt; lastY)
        state.down = true;
      else if (currentY &lt; lastY)
        state.down = false;
      // else do nothing and use previous value
      state.lastY = currentY;
      callback();
    }, true);
  },

  setScale: function pdfViewSetScale(val, resetAutoSettings, noScroll) {
    if (val == this.currentScale)
      return;

    var pages = this.pages;
    for (var i = 0; i &lt; pages.length; i++)
      pages[i].update(val * CSS_UNITS);

    if (!noScroll &amp;&amp; this.currentScale != val)
      this.pages[this.page - 1].scrollIntoView();
    this.currentScale = val;

    var event = document.createEvent(&#x27;UIEvents&#x27;);
    event.initUIEvent(&#x27;scalechange&#x27;, false, false, window, 0);
    event.scale = val;
    event.resetAutoSettings = resetAutoSettings;
    window.dispatchEvent(event);
  },

  parseScale: function pdfViewParseScale(value, resetAutoSettings, noScroll) {
    if (&#x27;custom&#x27; == value)
      return;

    var scale = parseFloat(value);
    this.currentScaleValue = value;
    if (scale) {
      this.setScale(scale, true, noScroll);
      return;
    }

    var container = this.container;
    var currentPage = this.pages[this.page - 1];
    if (!currentPage) {
      return;
    }

    var pageWidthScale = (container.clientWidth - SCROLLBAR_PADDING) /
                          currentPage.width * currentPage.scale / CSS_UNITS;
    var pageHeightScale = (container.clientHeight - VERTICAL_PADDING) /
                           currentPage.height * currentPage.scale / CSS_UNITS;
    switch (value) {
      case &#x27;page-actual&#x27;:
        scale = 1;
        break;
      case &#x27;page-width&#x27;:
        scale = pageWidthScale;
        break;
      case &#x27;page-height&#x27;:
        scale = pageHeightScale;
        break;
      case &#x27;page-fit&#x27;:
        scale = Math.min(pageWidthScale, pageHeightScale);
        break;
      case &#x27;auto&#x27;:
        scale = Math.min(1.0, pageWidthScale);
        break;
    }
    this.setScale(scale, resetAutoSettings, noScroll);

    selectScaleOption(value);
  },

  zoomIn: function pdfViewZoomIn() {
    var newScale = (this.currentScale * DEFAULT_SCALE_DELTA).toFixed(2);
    newScale = Math.ceil(newScale * 10) / 10;
    newScale = Math.min(MAX_SCALE, newScale);
    this.parseScale(newScale, true);
  },

  zoomOut: function pdfViewZoomOut() {
    var newScale = (this.currentScale / DEFAULT_SCALE_DELTA).toFixed(2);
    newScale = Math.floor(newScale * 10) / 10;
    newScale = Math.max(MIN_SCALE, newScale);
    this.parseScale(newScale, true);
  },

  set page(val) {
    var pages = this.pages;
    var input = document.getElementById(&#x27;pageNumber&#x27;);
    var event = document.createEvent(&#x27;UIEvents&#x27;);
    event.initUIEvent(&#x27;pagechange&#x27;, false, false, window, 0);

    if (!(0 &lt; val &amp;&amp; val &lt;= pages.length)) {
      this.previousPageNumber = val;
      event.pageNumber = this.page;
      window.dispatchEvent(event);
      return;
    }

    pages[val - 1].updateStats();
    this.previousPageNumber = currentPageNumber;
    currentPageNumber = val;
    event.pageNumber = val;
    window.dispatchEvent(event);

    // checking if the this.page was called from the updateViewarea function:
    // avoiding the creation of two &quot;set page&quot; method (internal and public)
    if (updateViewarea.inProgress)
      return;

    // Avoid scrolling the first page during loading
    if (this.loading &amp;&amp; val == 1)
      return;

    pages[val - 1].scrollIntoView();
  },

  get page() {
    return currentPageNumber;
  },

  get supportsPrinting() {
    var canvas = document.createElement(&#x27;canvas&#x27;);
    var value = &#x27;mozPrintCallback&#x27; in canvas;
    // shadow
    Object.defineProperty(this, &#x27;supportsPrinting&#x27;, { value: value,
                                                      enumerable: true,
                                                      configurable: true,
                                                      writable: false });
    return value;
  },

  get supportsFullscreen() {
    var doc = document.documentElement;
    var support = doc.requestFullscreen || doc.mozRequestFullScreen ||
                  doc.webkitRequestFullScreen;

    if (document.fullscreenEnabled === false ||
        document.mozFullScreenEnabled === false ||
        document.webkitFullscreenEnabled === false ) {
      support = false;
    }

    Object.defineProperty(this, &#x27;supportsFullscreen&#x27;, { value: support,
                                                        enumerable: true,
                                                        configurable: true,
                                                        writable: false });
    return support;
  },

  get supportsIntegratedFind() {
    var support = false;
//#if !(FIREFOX || MOZCENTRAL)
//#else
//  support = FirefoxCom.requestSync(&#x27;supportsIntegratedFind&#x27;);
//#endif
    Object.defineProperty(this, &#x27;supportsIntegratedFind&#x27;, { value: support,
                                                            enumerable: true,
                                                            configurable: true,
                                                            writable: false });
    return support;
  },

  get supportsDocumentFonts() {
    var support = true;
//#if !(FIREFOX || MOZCENTRAL)
//#else
//  support = FirefoxCom.requestSync(&#x27;supportsDocumentFonts&#x27;);
//#endif
    Object.defineProperty(this, &#x27;supportsDocumentFonts&#x27;, { value: support,
                                                           enumerable: true,
                                                           configurable: true,
                                                           writable: false });
    return support;
  },

  get supportsDocumentColors() {
    var support = true;
//#if !(FIREFOX || MOZCENTRAL)
//#else
//  support = FirefoxCom.requestSync(&#x27;supportsDocumentColors&#x27;);
//#endif
    Object.defineProperty(this, &#x27;supportsDocumentColors&#x27;, { value: support,
                                                            enumerable: true,
                                                            configurable: true,
                                                            writable: false });
    return support;
  },

  get loadingBar() {
    var bar = new ProgressBar(&#x27;#loadingBar&#x27;, {});
    Object.defineProperty(this, &#x27;loadingBar&#x27;, { value: bar,
                                                enumerable: true,
                                                configurable: true,
                                                writable: false });
    return bar;
  },

  get isHorizontalScrollbarEnabled() {
    var div = document.getElementById(&#x27;viewerContainer&#x27;);
    return div.scrollWidth &gt; div.clientWidth;
  },

  initPassiveLoading: function pdfViewInitPassiveLoading() {
    var pdfDataRangeTransport = {
      rangeListeners: [],
      progressListeners: [],

      addRangeListener: function PdfDataRangeTransport_addRangeListener(
                                   listener) {
        this.rangeListeners.push(listener);
      },

      addProgressListener: function PdfDataRangeTransport_addProgressListener(
                                      listener) {
        this.progressListeners.push(listener);
      },

      onDataRange: function PdfDataRangeTransport_onDataRange(begin, chunk) {
        var listeners = this.rangeListeners;
        for (var i = 0, n = listeners.length; i &lt; n; ++i) {
          listeners[i](begin, chunk);
        }
      },

      onDataProgress: function PdfDataRangeTransport_onDataProgress(loaded) {
        var listeners = this.progressListeners;
        for (var i = 0, n = listeners.length; i &lt; n; ++i) {
          listeners[i](loaded);
        }
      },

      requestDataRange: function PdfDataRangeTransport_requestDataRange(
                                  begin, end) {
        FirefoxCom.request(&#x27;requestDataRange&#x27;, { begin: begin, end: end });
      }
    };

    window.addEventListener(&#x27;message&#x27;, function windowMessage(e) {
      var args = e.data;

      if (typeof args !== &#x27;object&#x27; || !(&#x27;pdfjsLoadAction&#x27; in args))
        return;
      switch (args.pdfjsLoadAction) {
        case &#x27;supportsRangedLoading&#x27;:
          PDFView.open(args.pdfUrl, 0, undefined, pdfDataRangeTransport, {
            length: args.length
          });
          break;
        case &#x27;range&#x27;:
          pdfDataRangeTransport.onDataRange(args.begin, args.chunk);
          break;
        case &#x27;rangeProgress&#x27;:
          pdfDataRangeTransport.onDataProgress(args.loaded);
          break;
        case &#x27;progress&#x27;:
          PDFView.progress(args.loaded / args.total);
          break;
        case &#x27;complete&#x27;:
          if (!args.data) {
            PDFView.error(mozL10n.get(&#x27;loading_error&#x27;, null,
                          &#x27;An error occurred while loading the PDF.&#x27;), e);
            break;
          }
          PDFView.open(args.data, 0);
          break;
      }
    });
    FirefoxCom.requestSync(&#x27;initPassiveLoading&#x27;, null);
  },

  // TODO(mack): This function signature should really be pdfViewOpen(url, args)
  open: function pdfViewOpen(url, scale, password,
                             pdfDataRangeTransport, args) {
    var parameters = {password: password};
    if (typeof url === &#x27;string&#x27;) { // URL
      parameters.url = url;
    } else if (url &amp;&amp; &#x27;byteLength&#x27; in url) { // ArrayBuffer
      parameters.data = url;
    }
    if (args) {
      for (var prop in args) {
        parameters[prop] = args[prop];
      }
    }

    this.pdfDocument = null;
    var self = this;
    self.loading = true;
    var passwordNeeded = function passwordNeeded(updatePassword, reason) {
      var promptString = mozL10n.get(&#x27;request_password&#x27;, null,
                                &#x27;PDF is protected by a password:&#x27;);

      if (reason === PDFJS.PasswordResponses.INCORRECT_PASSWORD) {
        promptString += &#x27;\n&#x27; + mozL10n.get(&#x27;invalid_password&#x27;, null,
                                &#x27;Invalid Password.&#x27;);
      }

      password = prompt(promptString);
      if (password &amp;&amp; password.length &gt; 0) {
        return updatePassword(password);
      }
    };

    function getDocumentProgress(progressData) {
      self.progress(progressData.loaded / progressData.total);
    }

    PDFJS.getDocument(parameters, pdfDataRangeTransport, passwordNeeded,
                      getDocumentProgress).then(
      function getDocumentCallback(pdfDocument) {
        self.load(pdfDocument, scale);
        self.loading = false;
      },
      function getDocumentError(message, exception) {
        var loadingErrorMessage = mozL10n.get(&#x27;loading_error&#x27;, null,
          &#x27;An error occurred while loading the PDF.&#x27;);

        if (exception &amp;&amp; exception.name === &#x27;InvalidPDFException&#x27;) {
          // change error message also for other builds
          var loadingErrorMessage = mozL10n.get(&#x27;invalid_file_error&#x27;, null,&#x27;Invalid or corrupted PDF file.&#x27;);

        }

        if (exception &amp;&amp; exception.name === &#x27;MissingPDFException&#x27;) {
          // special message for missing PDF&#x27;s
          var loadingErrorMessage = mozL10n.get(&#x27;missing_file_error&#x27;, null,&#x27;Missing PDF file.&#x27;);

        }

        var moreInfo = {
          message: message
        };
        self.error(loadingErrorMessage, moreInfo);
        self.loading = false;
      }
    );
  },
  fallback: function pdfViewFallback() {

  },

  navigateTo: function pdfViewNavigateTo(dest) {
    var destString = &#x27;&#x27;;
    var self = this;

    var goToDestination = function(destRef) {
      self.pendingRefStr = null;
      // dest array looks like that: &lt;page-ref&gt; &lt;/XYZ|FitXXX&gt; &lt;args..&gt;
      var pageNumber = destRef instanceof Object ?
        self.pagesRefMap[destRef.num + &#x27; &#x27; + destRef.gen + &#x27; R&#x27;] :
        (destRef + 1);
      if (pageNumber) {
        if (pageNumber &gt; self.pages.length) {
          pageNumber = self.pages.length;
        }
        var currentPage = self.pages[pageNumber - 1];
        currentPage.scrollIntoView(dest);

        // Update the browsing history.
        PDFHistory.push({ dest: dest, hash: destString, page: pageNumber });
      } else {
        self.pendingRefStrLoaded = new PDFJS.Promise();
        self.pendingRefStr = destRef.num + &#x27; &#x27; + destRef.gen + &#x27; R&#x27;;
        self.pendingRefStrLoaded.then(function() {
          goToDestination(destRef);
        });
      }
    };

    this.destinationsPromise.then(function() {
      if (typeof dest === &#x27;string&#x27;) {
        destString = dest;
        dest = self.destinations[dest];
      }
      if (!(dest instanceof Array)) {
        return; // invalid destination
      }
      goToDestination(dest[0]);
    });
  },

  getDestinationHash: function pdfViewGetDestinationHash(dest) {
    if (typeof dest === &#x27;string&#x27;)
      return PDFView.getAnchorUrl(&#x27;#&#x27; + escape(dest));
    if (dest instanceof Array) {
      var destRef = dest[0]; // see navigateTo method for dest format
      var pageNumber = destRef instanceof Object ?
        this.pagesRefMap[destRef.num + &#x27; &#x27; + destRef.gen + &#x27; R&#x27;] :
        (destRef + 1);
      if (pageNumber) {
        var pdfOpenParams = PDFView.getAnchorUrl(&#x27;#page=&#x27; + pageNumber);
        var destKind = dest[1];
        if (typeof destKind === &#x27;object&#x27; &amp;&amp; &#x27;name&#x27; in destKind &amp;&amp;
            destKind.name == &#x27;XYZ&#x27;) {
          var scale = (dest[4] || this.currentScaleValue);
          var scaleNumber = parseFloat(scale);
          if (scaleNumber) {
            scale = scaleNumber * 100;
          }
          pdfOpenParams += &#x27;&amp;zoom=&#x27; + scale;
          if (dest[2] || dest[3]) {
            pdfOpenParams += &#x27;,&#x27; + (dest[2] || 0) + &#x27;,&#x27; + (dest[3] || 0);
          }
        }
        return pdfOpenParams;
      }
    }
    return &#x27;&#x27;;
  },

  /**
   * For the firefox extension we prefix the full url on anchor links so they
   * don&#x27;t come up as resource:// urls and so open in new tab/window works.
   * @param {String} anchor The anchor hash include the #.
   */
  getAnchorUrl: function getAnchorUrl(anchor) {
//#if !(FIREFOX || MOZCENTRAL)
    return anchor;
//#else
//  return this.url.split(&#x27;#&#x27;)[0] + anchor;
//#endif
  },


  /**
   * Show the error box.
   * @param {String} message A message that is human readable.
   * @param {Object} moreInfo (optional) Further information about the error
   *                            that is more technical.  Should have a &#x27;message&#x27;
   *                            and optionally a &#x27;stack&#x27; property.
   */
  error: function pdfViewError(message, moreInfo) {
    var moreInfoText = mozL10n.get(&#x27;error_version_info&#x27;,
      {version: PDFJS.version || &#x27;?&#x27;, build: PDFJS.build || &#x27;?&#x27;},
      &#x27;PDF.js v{{version}} (build: {{build}})&#x27;) + &#x27;\n&#x27;;
    if (moreInfo) {
      moreInfoText +=
        mozL10n.get(&#x27;error_message&#x27;, {message: moreInfo.message},
        &#x27;Message: {{message}}&#x27;);
      if (moreInfo.stack) {
        moreInfoText += &#x27;\n&#x27; +
          mozL10n.get(&#x27;error_stack&#x27;, {stack: moreInfo.stack},
          &#x27;Stack: {{stack}}&#x27;);
      } else {
        if (moreInfo.filename) {
          moreInfoText += &#x27;\n&#x27; +
            mozL10n.get(&#x27;error_file&#x27;, {file: moreInfo.filename},
            &#x27;File: {{file}}&#x27;);
        }
        if (moreInfo.lineNumber) {
          moreInfoText += &#x27;\n&#x27; +
            mozL10n.get(&#x27;error_line&#x27;, {line: moreInfo.lineNumber},
            &#x27;Line: {{line}}&#x27;);
        }
      }
    }

//#if !(FIREFOX || MOZCENTRAL)
    var errorWrapper = document.getElementById(&#x27;errorWrapper&#x27;);
    errorWrapper.removeAttribute(&#x27;hidden&#x27;);

    var errorMessage = document.getElementById(&#x27;errorMessage&#x27;);
    errorMessage.textContent = message;

    var closeButton = document.getElementById(&#x27;errorClose&#x27;);
    closeButton.onclick = function() {
      errorWrapper.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);
    };

    var errorMoreInfo = document.getElementById(&#x27;errorMoreInfo&#x27;);
    var moreInfoButton = document.getElementById(&#x27;errorShowMore&#x27;);
    var lessInfoButton = document.getElementById(&#x27;errorShowLess&#x27;);
    moreInfoButton.onclick = function() {
      errorMoreInfo.removeAttribute(&#x27;hidden&#x27;);
      moreInfoButton.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);
      lessInfoButton.removeAttribute(&#x27;hidden&#x27;);
      errorMoreInfo.style.height = errorMoreInfo.scrollHeight + &#x27;px&#x27;;
    };
    lessInfoButton.onclick = function() {
      errorMoreInfo.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);
      moreInfoButton.removeAttribute(&#x27;hidden&#x27;);
      lessInfoButton.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);
    };
    moreInfoButton.oncontextmenu = noContextMenuHandler;
    lessInfoButton.oncontextmenu = noContextMenuHandler;
    closeButton.oncontextmenu = noContextMenuHandler;
    moreInfoButton.removeAttribute(&#x27;hidden&#x27;);
    lessInfoButton.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);
    errorMoreInfo.value = moreInfoText;
//#else
//  console.error(message + &#x27;\n&#x27; + moreInfoText);
//#endif
  },

  progress: function pdfViewProgress(level) {
    var percent = Math.round(level * 100);
    // When we transition from full request to range requests, it&#x27;s possible
    // that we discard some of the loaded data. This can cause the loading
    // bar to move backwards. So prevent this by only updating the bar if it
    // increases.
    if (percent &gt; PDFView.loadingBar.percent) {
      PDFView.loadingBar.percent = percent;
    }
  },

  load: function pdfViewLoad(pdfDocument, scale) {

    this.pdfDocument = pdfDocument;

    var errorWrapper = document.getElementById(&#x27;errorWrapper&#x27;);
    errorWrapper.setAttribute(&#x27;hidden&#x27;, &#x27;true&#x27;);

    pdfDocument.dataLoaded().then(function() {
      PDFView.loadingBar.hide();
      var outerContainer = document.getElementById(&#x27;outerContainer&#x27;);
      outerContainer.classList.remove(&#x27;loadingInProgress&#x27;);
    });


    var container = document.getElementById(&#x27;viewer&#x27;);
    while (container.hasChildNodes())
      container.removeChild(container.lastChild);

    var pagesCount = pdfDocument.numPages;

    var id = pdfDocument.fingerprint;
    document.getElementById(&#x27;numPages&#x27;).textContent =
      mozL10n.get(&#x27;page_of&#x27;, {pageCount: pagesCount}, &#x27;of {{pageCount}}&#x27;);
    document.getElementById(&#x27;pageNumber&#x27;).max = pagesCount;

    PDFView.documentFingerprint = id;
    var store = PDFView.store = new Settings(id);

    this.pageRotation = 0;

    var pages = this.pages = [];
    this.pageText = [];
    this.startedTextExtraction = false;
    var pagesRefMap = this.pagesRefMap = {};

    var pagesPromise = this.pagesPromise = new PDFJS.Promise();
    var self = this;

    var firstPagePromise = pdfDocument.getPage(1);

    // Fetch a single page so we can get a viewport that will be the default
    // viewport for all pages
    firstPagePromise.then(function(pdfPage) {
      var viewport = pdfPage.getViewport(scale || 1.0);
      var pagePromises = [];
      for (var pageNum = 1; pageNum &lt;= pagesCount; ++pageNum) {
        var viewportClone = viewport.clone();
        var pageView = new PageView(container, pageNum, scale,
                                    self.navigateTo.bind(self),
                                    viewportClone);

        pages.push(pageView);
      }

      var event = document.createEvent(&#x27;CustomEvent&#x27;);
      event.initCustomEvent(&#x27;documentload&#x27;, true, true, {});
      window.dispatchEvent(event);

      PDFView.loadingBar.setWidth(container);

      for (var pageNum = 1; pageNum &lt;= pagesCount; ++pageNum) {
        var pagePromise = pdfDocument.getPage(pageNum);
        pagePromise.then(function(pdfPage) {
          var pageNum = pdfPage.pageNumber;
          var pageView = pages[pageNum - 1];
          if (!pageView.pdfPage) {
            // The pdfPage might already be set if we&#x27;ve already entered
            // pageView.draw()
            pageView.setPdfPage(pdfPage);
          }

          var pageRef = pdfPage.ref;
          var refStr = pageRef.num + &#x27; &#x27; + pageRef.gen + &#x27; R&#x27;;
          pagesRefMap[refStr] = pdfPage.pageNumber;

          if (self.pendingRefStr &amp;&amp; self.pendingRefStr === refStr) {
            self.pendingRefStrLoaded.resolve();
          }
        });
        pagePromises.push(pagePromise);
      }

      PDFJS.Promise.all(pagePromises).then(function(pages) {
        pagesPromise.resolve(pages);
      });
    });

    var storePromise = store.initializedPromise;
    PDFJS.Promise.all([firstPagePromise, storePromise]).then(function() {
      var storedHash = null;
      if (store.get(&#x27;exists&#x27;, false)) {
        var pageNum = store.get(&#x27;page&#x27;, &#x27;1&#x27;);
        var zoom = store.get(&#x27;zoom&#x27;, PDFView.currentScale);
        var left = store.get(&#x27;scrollLeft&#x27;, &#x27;0&#x27;);
        var top = store.get(&#x27;scrollTop&#x27;, &#x27;0&#x27;);

        storedHash = &#x27;page=&#x27; + pageNum + &#x27;&amp;zoom=&#x27; + zoom + &#x27;,&#x27; +
                     left + &#x27;,&#x27; + top;
      }
      // Initialize the browsing history.
      PDFHistory.initialize(self.documentFingerprint);

      self.setInitialView(storedHash, scale);

      // Make all navigation keys work on document load,
      // unless the viewer is embedded in a web page.
      if (!self.isViewerEmbedded) {
        self.container.focus();
//#if (FIREFOX || MOZCENTRAL)
//      self.container.blur();
//#endif
      }
    });

    pagesPromise.then(function() {
      if (PDFView.supportsPrinting) {
        pdfDocument.getJavaScript().then(function(javaScript) {
          if (javaScript.length) {
            console.warn(&#x27;Warning: JavaScript is not supported&#x27;);
            PDFView.fallback();
          }
          // Hack to support auto printing.
          var regex = /\bprint\s*\(/g;
          for (var i = 0, ii = javaScript.length; i &lt; ii; i++) {
            var js = javaScript[i];
            if (js &amp;&amp; regex.test(js)) {
              setTimeout(function() {
                window.print();
              });
              return;
            }
          }
        });
      }
    });

    var destinationsPromise =
      this.destinationsPromise = pdfDocument.getDestinations();
    destinationsPromise.then(function(destinations) {
      self.destinations = destinations;
    });

    // outline depends on destinations and pagesRefMap
    var promises = [pagesPromise, destinationsPromise,
                    PDFView.animationStartedPromise];
    PDFJS.Promise.all(promises).then(function() {
      pdfDocument.getOutline()
    });

    pdfDocument.getMetadata().then(function(data) {
      var info = data.info, metadata = data.metadata;
      self.documentInfo = info;
      self.metadata = metadata;

      // Provides some basic debug information
      console.log(&#x27;PDF &#x27; + pdfDocument.fingerprint + &#x27; [&#x27; +
                  info.PDFFormatVersion + &#x27; &#x27; + (info.Producer || &#x27;-&#x27;) +
                  &#x27; / &#x27; + (info.Creator || &#x27;-&#x27;) + &#x27;]&#x27; +
                  (PDFJS.version ? &#x27; (PDF.js: &#x27; + PDFJS.version + &#x27;)&#x27; : &#x27;&#x27;));

      var pdfTitle;
      if (metadata) {
        if (metadata.has(&#x27;dc:title&#x27;))
          pdfTitle = metadata.get(&#x27;dc:title&#x27;);
      }

      if (!pdfTitle &amp;&amp; info &amp;&amp; info[&#x27;Title&#x27;])
        pdfTitle = info[&#x27;Title&#x27;];

      if (info.IsAcroFormPresent) {
        console.warn(&#x27;Warning: AcroForm/XFA is not supported&#x27;);
        PDFView.fallback();
      }

//#if (FIREFOX || MOZCENTRAL)
//    var versionId = String(info.PDFFormatVersion).slice(-1) | 0;
//    var generatorId = 0;
//    var KNOWN_GENERATORS = [&quot;acrobat distiller&quot;, &quot;acrobat pdfwritter&quot;,
//     &quot;adobe livecycle&quot;, &quot;adobe pdf library&quot;, &quot;adobe photoshop&quot;, &quot;ghostscript&quot;,
//     &quot;tcpdf&quot;, &quot;cairo&quot;, &quot;dvipdfm&quot;, &quot;dvips&quot;, &quot;pdftex&quot;, &quot;pdfkit&quot;, &quot;itext&quot;,
//     &quot;prince&quot;, &quot;quarkxpress&quot;, &quot;mac os x&quot;, &quot;microsoft&quot;, &quot;openoffice&quot;, &quot;oracle&quot;,
//     &quot;luradocument&quot;, &quot;pdf-xchange&quot;, &quot;antenna house&quot;, &quot;aspose.cells&quot;, &quot;fpdf&quot;];
//    var generatorId = 0;
//    if (info.Producer) {
//      KNOWN_GENERATORS.some(function (generator, s, i) {
//        if (generator.indexOf(s) &lt; 0) {
//          return false;
//        }
//        generatorId = i + 1;
//        return true;
//      }.bind(null, info.Producer.toLowerCase()));
//    }
//    var formType = !info.IsAcroFormPresent ? null : info.IsXFAPresent ?
//                   &#x27;xfa&#x27; : &#x27;acroform&#x27;;
//    FirefoxCom.request(&#x27;reportTelemetry&#x27;, JSON.stringify({
//      type: &#x27;documentInfo&#x27;,
//      version: versionId,
//      generator: generatorId,
//      formType: formType
//    }));
//#endif
    });
  },

  setInitialView: function pdfViewSetInitialView(storedHash, scale) {
    // Reset the current scale, as otherwise the page&#x27;s scale might not get
    // updated if the zoom level stayed the same.
    this.currentScale = 0;
    this.currentScaleValue = null;
    // When opening a new file (when one is already loaded in the viewer):
    // Reset &#x27;currentPageNumber&#x27;, since otherwise the page&#x27;s scale will be wrong
    // if &#x27;currentPageNumber&#x27; is larger than the number of pages in the file.
    document.getElementById(&#x27;pageNumber&#x27;).value = currentPageNumber = 1;

    if (PDFHistory.initialDestination) {
      this.navigateTo(PDFHistory.initialDestination);
      PDFHistory.initialDestination = null;
    } else if (this.initialBookmark) {
      this.setHash(this.initialBookmark);
      PDFHistory.push({ hash: this.initialBookmark }, !!this.initialBookmark);
      this.initialBookmark = null;
    } else if (storedHash) {
      this.setHash(storedHash);
    } else if (scale) {
      this.parseScale(scale, true);
      this.page = 1;
    }

    if (PDFView.currentScale === UNKNOWN_SCALE) {
      // Scale was not initialized: invalid bookmark or scale was not specified.
      // Setting the default one.
      this.parseScale(DEFAULT_SCALE, true);
    }
  },

  renderHighestPriority: function pdfViewRenderHighestPriority() {
    // Pages have a higher priority , so check them first.
    var visiblePages = this.getVisiblePages();
    var pageView = this.getHighestPriority(visiblePages, this.pages,
                                           this.pageViewScroll.down);
    if (pageView) {
      this.renderView(pageView, &#x27;page&#x27;);
      return;
    }
  },

  getHighestPriority: function pdfViewGetHighestPriority(visible, views,
                                                         scrolledDown) {
    // The state has changed figure out which page has the highest priority to
    // render next (if any).
    // Priority:
    // 1 visible pages
    // 2 if last scrolled down page after the visible pages
    // 2 if last scrolled up page before the visible pages
    var visibleViews = visible.views;

    var numVisible = visibleViews.length;
    if (numVisible === 0) {
      return false;
    }
    for (var i = 0; i &lt; numVisible; ++i) {
      var view = visibleViews[i].view;
      if (!this.isViewFinished(view))
        return view;
    }

    // All the visible views have rendered, try to render next/previous pages.
    if (scrolledDown) {
      var nextPageIndex = visible.last.id;
      // ID&#x27;s start at 1 so no need to add 1.
      if (views[nextPageIndex] &amp;&amp; !this.isViewFinished(views[nextPageIndex]))
        return views[nextPageIndex];
    } else {
      var previousPageIndex = visible.first.id - 2;
      if (views[previousPageIndex] &amp;&amp;
          !this.isViewFinished(views[previousPageIndex]))
        return views[previousPageIndex];
    }
    // Everything that needs to be rendered has been.
    return false;
  },

  isViewFinished: function pdfViewNeedsRendering(view) {
    return view.renderingState === RenderingStates.FINISHED;
  },

  // Render a page. This calls the appropriate function based
  // on the views state. If the view is already rendered it will return false.
  renderView: function pdfViewRender(view, type) {
    var state = view.renderingState;
    switch (state) {
      case RenderingStates.FINISHED:
        return false;
      case RenderingStates.PAUSED:
        PDFView.highestPriorityPage = type + view.id;
        view.resume();
        break;
      case RenderingStates.RUNNING:
        PDFView.highestPriorityPage = type + view.id;
        break;
      case RenderingStates.INITIAL:
        PDFView.highestPriorityPage = type + view.id;
        view.draw(this.renderHighestPriority.bind(this));
        break;
    }
    return true;
  },

  setHash: function pdfViewSetHash(hash) {
    if (!hash)
      return;

    if (hash.indexOf(&#x27;=&#x27;) &gt;= 0) {
      var params = PDFView.parseQueryString(hash);
      // borrowing syntax from &quot;Parameters for Opening PDF Files&quot;
      if (&#x27;nameddest&#x27; in params) {
        PDFHistory.updateNextHashParam(params.nameddest);
        PDFView.navigateTo(params.nameddest);
        return;
      }
      if (&#x27;page&#x27; in params) {
        var pageNumber = (params.page | 0) || 1;
        if (&#x27;zoom&#x27; in params) {
          var zoomArgs = params.zoom.split(&#x27;,&#x27;); // scale,left,top
          // building destination array

          // If the zoom value, it has to get divided by 100. If it is a string,
          // it should stay as it is.
          var zoomArg = zoomArgs[0];
          var zoomArgNumber = parseFloat(zoomArg);
          if (zoomArgNumber)
            zoomArg = zoomArgNumber / 100;

          var dest = [null, {name: &#x27;XYZ&#x27;},
                      zoomArgs.length &gt; 1 ? (zoomArgs[1] | 0) : null,
                      zoomArgs.length &gt; 2 ? (zoomArgs[2] | 0) : null,
                      zoomArg];
          var currentPage = this.pages[pageNumber - 1];
          currentPage.scrollIntoView(dest);
        } else {
          this.page = pageNumber; // simple page
        }
      }
    } else if (/^\d+$/.test(hash)) { // page number
      this.page = hash;
    } else { // named destination
      PDFHistory.updateNextHashParam(unescape(hash));
      PDFView.navigateTo(unescape(hash));
    }
  },

  getVisiblePages: function pdfViewGetVisiblePages() {
    if (!this.isPresentationMode) {
      return this.getVisibleElements(this.container, this.pages, true);
    } else {
      // The algorithm in getVisibleElements is broken in presentation mode.
      var visible = [], page = this.page;
      var currentPage = this.pages[page - 1];
      visible.push({ id: currentPage.id, view: currentPage });

      return { first: currentPage, last: currentPage, views: visible};
    }
  },

  // Generic helper to find out what elements are visible within a scroll pane.
  getVisibleElements: function pdfViewGetVisibleElements(
      scrollEl, views, sortByVisibility) {
    var top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
    var left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;

    var visible = [], view;
    var currentHeight, viewHeight, hiddenHeight, percentHeight;
    var currentWidth, viewWidth;
    for (var i = 0, ii = views.length; i &lt; ii; ++i) {
      view = views[i];
      currentHeight = view.el.offsetTop + view.el.clientTop;
      viewHeight = view.el.clientHeight;
      if ((currentHeight + viewHeight) &lt; top) {
        continue;
      }
      if (currentHeight &gt; bottom) {
        break;
      }
      currentWidth = view.el.offsetLeft + view.el.clientLeft;
      viewWidth = view.el.clientWidth;
      if ((currentWidth + viewWidth) &lt; left || currentWidth &gt; right) {
        continue;
      }
      hiddenHeight = Math.max(0, top - currentHeight) +
                     Math.max(0, currentHeight + viewHeight - bottom);
      percentHeight = ((viewHeight - hiddenHeight) * 100 / viewHeight) | 0;

      visible.push({ id: view.id, y: currentHeight,
                     view: view, percent: percentHeight });
    }

    var first = visible[0];
    var last = visible[visible.length - 1];

    if (sortByVisibility) {
      visible.sort(function(a, b) {
        var pc = a.percent - b.percent;
        if (Math.abs(pc) &gt; 0.001) {
          return -pc;
        }
        return a.id - b.id; // ensure stability
      });
    }
    return {first: first, last: last, views: visible};
  },

  // Helper function to parse query string (e.g. ?param1=value&amp;parm2=...).
  parseQueryString: function pdfViewParseQueryString(query) {
    var parts = query.split(&#x27;&amp;&#x27;);
    var params = {};
    for (var i = 0, ii = parts.length; i &lt; parts.length; ++i) {
      var param = parts[i].split(&#x27;=&#x27;);
      var key = param[0];
      var value = param.length &gt; 1 ? param[1] : null;
      params[decodeURIComponent(key)] = decodeURIComponent(value);
    }
    return params;
  },

  presentationMode: function pdfViewPresentationMode() {
    var isPresentationMode = document.fullscreenElement ||
                             document.mozFullScreen ||
                             document.webkitIsFullScreen;

    if (isPresentationMode) {
      return false;
    }

    var wrapper = document.getElementById(&#x27;viewerContainer&#x27;);
    if (document.documentElement.requestFullscreen) {
      wrapper.requestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      wrapper.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullScreen) {
      wrapper.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
    } else {
      return false;
    }

    this.presentationModeArgs = {
      page: this.page,
      previousScale: this.currentScaleValue
    };

    return true;
  },

  enterPresentationMode: function pdfViewEnterPresentationMode() {
    this.isPresentationMode = true;
    this.page = this.presentationModeArgs.page;
    this.parseScale(&#x27;page-fit&#x27;, true);
    this.showPresentationControls();
  },

  exitPresentationMode: function pdfViewExitPresentationMode() {
    this.isPresentationMode = false;
    this.parseScale(this.presentationModeArgs.previousScale);
    this.page = this.page;
    this.clearMouseScrollState();
    this.hidePresentationControls();
    this.presentationModeArgs = null;
  },

  showPresentationControls: function pdfViewShowPresentationControls() {
    var DELAY_BEFORE_HIDING_CONTROLS = 3000;
    var wrapper = document.getElementById(&#x27;viewerContainer&#x27;);
    if (this.presentationControlsTimeout) {
      clearTimeout(this.presentationControlsTimeout);
    } else {
      wrapper.classList.add(&#x27;presentationControls&#x27;);
    }
    this.presentationControlsTimeout = setTimeout(function hideControls() {
      wrapper.classList.remove(&#x27;presentationControls&#x27;);
      delete PDFView.presentationControlsTimeout;
    }, DELAY_BEFORE_HIDING_CONTROLS);
  },

  hidePresentationControls: function pdfViewShowPresentationControls() {
    if (!this.presentationControlsTimeout) {
      return;
    }
    clearTimeout(this.presentationControlsTimeout);
    delete this.presentationControlsTimeout;

    var wrapper = document.getElementById(&#x27;viewerContainer&#x27;);
    wrapper.classList.remove(&#x27;presentationControls&#x27;);
  },

  rotatePages: function pdfViewPageRotation(delta) {

    this.pageRotation = (this.pageRotation + 360 + delta) % 360;

    for (var i = 0, l = this.pages.length; i &lt; l; i++) {
      var page = this.pages[i];
      page.update(page.scale, this.pageRotation);
    }

    this.parseScale(this.currentScaleValue, true);

    this.renderHighestPriority();

    var currentPage = this.pages[this.page - 1];
    if (!currentPage) {
      return;
    }

    // Wait for presentation mode to take effect
    setTimeout(function() {
      currentPage.scrollIntoView();
    }, 0);
  },

  /**
   * This function flips the page in presentation mode if the user scrolls up
   * or down with large enough motion and prevents page flipping too often.
   *
   * @this {PDFView}
   * @param {number} mouseScrollDelta The delta value from the mouse event.
   */
  mouseScroll: function pdfViewMouseScroll(mouseScrollDelta) {
    var MOUSE_SCROLL_COOLDOWN_TIME = 50;

    var currentTime = (new Date()).getTime();
    var storedTime = this.mouseScrollTimeStamp;

    // In case one page has already been flipped there is a cooldown time
    // which has to expire before next page can be scrolled on to.
    if (currentTime &gt; storedTime &amp;&amp;
        currentTime - storedTime &lt; MOUSE_SCROLL_COOLDOWN_TIME)
      return;

    // In case the user decides to scroll to the opposite direction than before
    // clear the accumulated delta.
    if ((this.mouseScrollDelta &gt; 0 &amp;&amp; mouseScrollDelta &lt; 0) ||
        (this.mouseScrollDelta &lt; 0 &amp;&amp; mouseScrollDelta &gt; 0))
      this.clearMouseScrollState();

    this.mouseScrollDelta += mouseScrollDelta;

    var PAGE_FLIP_THRESHOLD = 120;
    if (Math.abs(this.mouseScrollDelta) &gt;= PAGE_FLIP_THRESHOLD) {

      var PageFlipDirection = {
        UP: -1,
        DOWN: 1
      };

      // In presentation mode scroll one page at a time.
      var pageFlipDirection = (this.mouseScrollDelta &gt; 0) ?
                                PageFlipDirection.UP :
                                PageFlipDirection.DOWN;
      this.clearMouseScrollState();
      var currentPage = this.page;

      // In case we are already on the first or the last page there is no need
      // to do anything.
      if ((currentPage == 1 &amp;&amp; pageFlipDirection == PageFlipDirection.UP) ||
          (currentPage == this.pages.length &amp;&amp;
           pageFlipDirection == PageFlipDirection.DOWN))
        return;

      this.page += pageFlipDirection;
      this.mouseScrollTimeStamp = currentTime;
    }
  },

  /**
   * This function clears the member attributes used with mouse scrolling in
   * presentation mode.
   *
   * @this {PDFView}
   */
  clearMouseScrollState: function pdfViewClearMouseScrollState() {
    this.mouseScrollTimeStamp = 0;
    this.mouseScrollDelta = 0;
  }
};

var PageView = function pageView(container, id, scale,
                                 navigateTo, defaultViewport) {
  this.id = id;

  this.rotation = 0;
  this.scale = scale || 1.0;
  this.viewport = defaultViewport;
  this.pdfPageRotate = defaultViewport.rotate;

  this.renderingState = RenderingStates.INITIAL;
  this.resume = null;

  this.textContent = null;
  this.textLayer = null;

  var anchor = document.createElement(&#x27;a&#x27;);
  anchor.name = &#x27;&#x27; + this.id;

  var div = this.el = document.createElement(&#x27;div&#x27;);
  div.id = &#x27;pageContainer&#x27; + this.id;
  div.className = &#x27;page&#x27;;
  div.style.width = Math.floor(this.viewport.width) + &#x27;px&#x27;;
  div.style.height = Math.floor(this.viewport.height) + &#x27;px&#x27;;

  container.appendChild(anchor);
  container.appendChild(div);

  this.setPdfPage = function pageViewSetPdfPage(pdfPage) {
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    this.viewport = pdfPage.getViewport(this.scale);
    this.stats = pdfPage.stats;
    this.update();
  };

  this.destroy = function pageViewDestroy() {
    this.update();
    if (this.pdfPage) {
      this.pdfPage.destroy();
    }
  };

  this.update = function pageViewUpdate(scale, rotation) {
    if (this.renderTask) {
      this.renderTask.cancel();
    }
    this.resume = null;
    this.renderingState = RenderingStates.INITIAL;

    if (typeof rotation !== &#x27;undefined&#x27;) {
      this.rotation = rotation;
    }

    this.scale = scale || this.scale;

    var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: this.scale,
      rotation: totalRotation
    });

    div.style.width = Math.floor(this.viewport.width) + &#x27;px&#x27;;
    div.style.height = Math.floor(this.viewport.height) + &#x27;px&#x27;;

    while (div.hasChildNodes())
      div.removeChild(div.lastChild);
    div.removeAttribute(&#x27;data-loaded&#x27;);

    delete this.canvas;

    this.loadingIconDiv = document.createElement(&#x27;div&#x27;);
    this.loadingIconDiv.className = &#x27;loadingIcon&#x27;;
    div.appendChild(this.loadingIconDiv);
  };

  Object.defineProperty(this, &#x27;width&#x27;, {
    get: function PageView_getWidth() {
      return this.viewport.width;
    },
    enumerable: true
  });

  Object.defineProperty(this, &#x27;height&#x27;, {
    get: function PageView_getHeight() {
      return this.viewport.height;
    },
    enumerable: true
  });

  function setupAnnotations(annotationsDiv, pdfPage, viewport) {

    function bindLink(link, dest) {
      link.href = PDFView.getDestinationHash(dest);
      link.onclick = function pageViewSetupLinksOnclick() {
        if (dest)
          PDFView.navigateTo(dest);
        return false;
      };
      link.className = &#x27;internalLink&#x27;;
    }

    function bindNamedAction(link, action) {
      link.onclick = function pageViewSetupNamedActionOnClick() {
        // See PDF reference, table 8.45 - Named action
        switch (action) {
          case &#x27;GoToPage&#x27;:
            document.getElementById(&#x27;pageNumber&#x27;).focus();
            break;

          case &#x27;GoBack&#x27;:
            PDFHistory.back();
            break;

          case &#x27;GoForward&#x27;:
            PDFHistory.forward();
            break;

          case &#x27;NextPage&#x27;:
            PDFView.page++;
            break;

          case &#x27;PrevPage&#x27;:
            PDFView.page--;
            break;

          case &#x27;LastPage&#x27;:
            PDFView.page = PDFView.pages.length;
            break;

          case &#x27;FirstPage&#x27;:
            PDFView.page = 1;
            break;

          default:
            break; // No action according to spec
        }
        return false;
      };
      link.className = &#x27;internalLink&#x27;;
    }

    pdfPage.getAnnotations().then(function(annotationsData) {
      viewport = viewport.clone({ dontFlip: true });
      for (var i = 0; i &lt; annotationsData.length; i++) {
        var data = annotationsData[i];
        var annotation = PDFJS.Annotation.fromData(data);
        if (!annotation || !annotation.hasHtml()) {
          continue;
        }

        var element = annotation.getHtmlElement(pdfPage.commonObjs);
        mozL10n.translate(element);

        data = annotation.getData();
        var rect = data.rect;
        var view = pdfPage.view;
        rect = PDFJS.Util.normalizeRect([
          rect[0],
          view[3] - rect[1] + view[1],
          rect[2],
          view[3] - rect[3] + view[1]
        ]);
        element.style.left = rect[0] + &#x27;px&#x27;;
        element.style.top = rect[1] + &#x27;px&#x27;;
        element.style.position = &#x27;absolute&#x27;;

        var transform = viewport.transform;
        var transformStr = &#x27;matrix(&#x27; + transform.join(&#x27;,&#x27;) + &#x27;)&#x27;;
        CustomStyle.setProp(&#x27;transform&#x27;, element, transformStr);
        var transformOriginStr = -rect[0] + &#x27;px &#x27; + -rect[1] + &#x27;px&#x27;;
        CustomStyle.setProp(&#x27;transformOrigin&#x27;, element, transformOriginStr);

        if (data.subtype === &#x27;Link&#x27; &amp;&amp; !data.url) {
          if (data.action) {
            bindNamedAction(element, data.action);
          } else {
            bindLink(element, (&#x27;dest&#x27; in data) ? data.dest : null);
          }
        }

        annotationsDiv.appendChild(element);
      }
    });
  }

  this.getPagePoint = function pageViewGetPagePoint(x, y) {
    return this.viewport.convertToPdfPoint(x, y);
  };

  this.scrollIntoView = function pageViewScrollIntoView(dest) {
      if (!dest) {
        scrollIntoView(div);
        return;
      }
      if (PDFView.isPresentationMode) { // Avoid breaking presentation mode.
        PDFView.page = id;
        return;
      }

      var x = 0, y = 0;
      var width = 0, height = 0, widthScale, heightScale;
      var scale = 0;
      switch (dest[1].name) {
        case &#x27;XYZ&#x27;:
          x = dest[2];
          y = dest[3];
          scale = dest[4];
          // If x and/or y coordinates are not supplied, default to
          // _top_ left of the page (not the obvious bottom left,
          // since aligning the bottom of the intended page with the
          // top of the window is rarely helpful).
          x = x !== null ? x : 0;
          y = y !== null ? y : this.height / this.scale;
          break;
        case &#x27;Fit&#x27;:
        case &#x27;FitB&#x27;:
          scale = &#x27;page-fit&#x27;;
          break;
        case &#x27;FitH&#x27;:
        case &#x27;FitBH&#x27;:
          y = dest[2];
          scale = &#x27;page-width&#x27;;
          break;
        case &#x27;FitV&#x27;:
        case &#x27;FitBV&#x27;:
          x = dest[2];
          scale = &#x27;page-height&#x27;;
          break;
        case &#x27;FitR&#x27;:
          x = dest[2];
          y = dest[3];
          width = dest[4] - x;
          height = dest[5] - y;
          widthScale = (PDFView.container.clientWidth - SCROLLBAR_PADDING) /
            width / CSS_UNITS;
          heightScale = (PDFView.container.clientHeight - SCROLLBAR_PADDING) /
            height / CSS_UNITS;
          scale = Math.min(widthScale, heightScale);
          break;
        default:
          return;
      }

      if (scale &amp;&amp; scale !== PDFView.currentScale) {
        PDFView.parseScale(scale, true, true);
      } else if (PDFView.currentScale === UNKNOWN_SCALE) {
        PDFView.parseScale(DEFAULT_SCALE, true, true);
      }

      if (scale === &#x27;page-fit&#x27; &amp;&amp; !dest[4]) {
        scrollIntoView(div);
        return;
      }

      var boundingRect = [
        this.viewport.convertToViewportPoint(x, y),
        this.viewport.convertToViewportPoint(x + width, y + height)
      ];
      setTimeout(function pageViewScrollIntoViewRelayout() {
        // letting page to re-layout before scrolling
        var scale = PDFView.currentScale;
        var x = Math.min(boundingRect[0][0], boundingRect[1][0]);
        var y = Math.min(boundingRect[0][1], boundingRect[1][1]);
        var width = Math.abs(boundingRect[0][0] - boundingRect[1][0]);
        var height = Math.abs(boundingRect[0][1] - boundingRect[1][1]);

        scrollIntoView(div, {left: x, top: y, width: width, height: height});
      }, 0);
  };

  this.getTextContent = function pageviewGetTextContent() {
    if (!this.textContent) {
      this.textContent = this.pdfPage.getTextContent();
    }
    return this.textContent;
  };

  this.draw = function pageviewDraw(callback) {
    var pdfPage = this.pdfPage;

    if (!pdfPage) {
      var promise = PDFView.getPage(this.id);
      promise.then(function(pdfPage) {
        this.setPdfPage(pdfPage);
        this.draw(callback);
      }.bind(this));
      return;
    }

    if (this.renderingState !== RenderingStates.INITIAL) {
      console.error(&#x27;Must be in new state before drawing&#x27;);
    }

    this.renderingState = RenderingStates.RUNNING;

    var viewport = this.viewport;
    // Wrap the canvas so if it has a css transform for highdpi the overflow
    // will be hidden in FF.
    var canvasWrapper = document.createElement(&#x27;div&#x27;);
    canvasWrapper.style.width = div.style.width;
    canvasWrapper.style.height = div.style.height;
    canvasWrapper.classList.add(&#x27;canvasWrapper&#x27;);

    var canvas = document.createElement(&#x27;canvas&#x27;);
    canvas.id = &#x27;page&#x27; + this.id;
    canvasWrapper.appendChild(canvas);
    div.appendChild(canvasWrapper);
    this.canvas = canvas;

    var scale = this.scale;
    var outputScale = getOutputScale();
    canvas.width = Math.floor(viewport.width) * outputScale.sx;
    canvas.height = Math.floor(viewport.height) * outputScale.sy;

    var textLayerDiv = null;
    if (!PDFJS.disableTextLayer) {
      textLayerDiv = document.createElement(&#x27;div&#x27;);
      textLayerDiv.className = &#x27;textLayer&#x27;;
      textLayerDiv.style.width = canvas.width + &#x27;px&#x27;;
      textLayerDiv.style.height = canvas.height + &#x27;px&#x27;;
      div.appendChild(textLayerDiv);
    }
    var textLayer = this.textLayer =
          textLayerDiv ? new TextLayerBuilder({
              textLayerDiv: textLayerDiv,
              pageIndex: this.id - 1,
              lastScrollSource: PDFView
          }) : null;

    if (outputScale.scaled) {
      var cssScale = &#x27;scale(&#x27; + (1 / outputScale.sx) + &#x27;, &#x27; +
                                (1 / outputScale.sy) + &#x27;)&#x27;;
      CustomStyle.setProp(&#x27;transform&#x27; , canvas, cssScale);
      CustomStyle.setProp(&#x27;transformOrigin&#x27; , canvas, &#x27;0% 0%&#x27;);
      if (textLayerDiv) {
        CustomStyle.setProp(&#x27;transform&#x27; , textLayerDiv, cssScale);
        CustomStyle.setProp(&#x27;transformOrigin&#x27; , textLayerDiv, &#x27;0% 0%&#x27;);
      }
    }

    var ctx = canvas.getContext(&#x27;2d&#x27;);
    // TODO(mack): use data attributes to store these
    ctx._scaleX = outputScale.sx;
    ctx._scaleY = outputScale.sy;
    if (outputScale.scaled) {
      ctx.scale(outputScale.sx, outputScale.sy);
    }
//#if (FIREFOX || MOZCENTRAL)
//  // Checking if document fonts are used only once
//  var checkIfDocumentFontsUsed = !PDFView.pdfDocument.embeddedFontsUsed;
//#endif

    // Rendering area

    var self = this;
    function pageViewDrawCallback(error) {
      // The renderTask may have been replaced by a new one, so only remove the
      // reference to the renderTask if it matches the one that is triggering
      // this callback.
      if (renderTask === self.renderTask) {
        self.renderTask = null;
      }

      if (error === &#x27;cancelled&#x27;) {
        return;
      }

      self.renderingState = RenderingStates.FINISHED;

      if (self.loadingIconDiv) {
        div.removeChild(self.loadingIconDiv);
        delete self.loadingIconDiv;
      }

      if (error) {
        PDFView.error(mozL10n.get(&#x27;rendering_error&#x27;, null,
          &#x27;An error occurred while rendering the page.&#x27;), error);
      }

      self.stats = pdfPage.stats;
      self.updateStats();
      if (self.onAfterDraw)
        self.onAfterDraw();

      cache.push(self);

      var event = document.createEvent(&#x27;CustomEvent&#x27;);
      event.initCustomEvent(&#x27;pagerender&#x27;, true, true, {
        pageNumber: pdfPage.pageNumber
      });
      div.dispatchEvent(event);

      callback();
    }

    var renderContext = {
      canvasContext: ctx,
      viewport: this.viewport,
      textLayer: textLayer,
      continueCallback: function pdfViewcContinueCallback(cont) {
        if (PDFView.highestPriorityPage !== &#x27;page&#x27; + self.id) {
          self.renderingState = RenderingStates.PAUSED;
          self.resume = function resumeCallback() {
            self.renderingState = RenderingStates.RUNNING;
            cont();
          };
          return;
        }
        cont();
      }
    };
    var renderTask = this.renderTask = this.pdfPage.render(renderContext);

    this.renderTask.then(
      function pdfPageRenderCallback() {
        pageViewDrawCallback(null);
      },
      function pdfPageRenderError(error) {
        pageViewDrawCallback(error);
      }
    );

    if (textLayer) {
      this.getTextContent().then(
        function textContentResolved(textContent) {
          textLayer.setTextContent(textContent);
        }
      );
    }

    setupAnnotations(div, pdfPage, this.viewport);
    div.setAttribute(&#x27;data-loaded&#x27;, true);
  };

  this.updateStats = function pageViewUpdateStats() {
    if (!this.stats) {
      return;
    }

    if (PDFJS.pdfBug &amp;&amp; Stats.enabled) {
      var stats = this.stats;
      Stats.add(this.id, stats);
    }
  };
};

document.addEventListener(&#x27;DOMContentLoaded&#x27;, function webViewerLoad(evt) {
  PDFView.initialize();

//#if !(FIREFOX || MOZCENTRAL || CHROME)
  var params = PDFView.parseQueryString(document.location.search.substring(1));
  var file = params.file || DEFAULT_URL;
//#else
//var file = window.location.href.split(&#x27;#&#x27;)[0];
//#endif

//#if !(FIREFOX || MOZCENTRAL || CHROME)
  var fileInput = document.createElement(&#x27;input&#x27;);
  fileInput.id = &#x27;fileInput&#x27;;
  fileInput.className = &#x27;fileInput&#x27;;
  fileInput.setAttribute(&#x27;type&#x27;, &#x27;file&#x27;);
  fileInput.setAttribute(&#x27;style&#x27;,
    &#x27;visibility: hidden; position: fixed; right: 0; top: 0&#x27;);
  fileInput.oncontextmenu = noContextMenuHandler;
  document.body.appendChild(fileInput);

  if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {

  } else {
    document.getElementById(&#x27;fileInput&#x27;).value = null;
  }

  // Special debugging flags in the hash section of the URL.
  var hash = document.location.hash.substring(1);
  var hashParams = PDFView.parseQueryString(hash);

  if (&#x27;disableWorker&#x27; in hashParams) {
    PDFJS.disableWorker = (hashParams[&#x27;disableWorker&#x27;] === &#x27;true&#x27;);
  }

  if (&#x27;disableRange&#x27; in hashParams) {
    PDFJS.disableRange = (hashParams[&#x27;disableRange&#x27;] === &#x27;true&#x27;);
  }

  if (&#x27;disableAutoFetch&#x27; in hashParams) {
    PDFJS.disableAutoFetch = (hashParams[&#x27;disableAutoFetch&#x27;] === &#x27;true&#x27;);
  }

  if (&#x27;disableFontFace&#x27; in hashParams) {
    PDFJS.disableFontFace = (hashParams[&#x27;disableFontFace&#x27;] === &#x27;true&#x27;);
  }

  if (&#x27;disableHistory&#x27; in hashParams) {
    PDFJS.disableHistory = (hashParams[&#x27;disableHistory&#x27;] === &#x27;true&#x27;);
  }

//#if !(FIREFOX || MOZCENTRAL)
  var locale = navigator.language;
  if (&#x27;locale&#x27; in hashParams)
    locale = hashParams[&#x27;locale&#x27;];
  mozL10n.setLanguage(locale);
//#endif
//#if (FIREFOX || MOZCENTRAL)
//if (!PDFView.supportsDocumentFonts) {
//  PDFJS.disableFontFace = true;
//}
//#endif

  if (&#x27;textLayer&#x27; in hashParams) {
    switch (hashParams[&#x27;textLayer&#x27;]) {
      case &#x27;off&#x27;:
        PDFJS.disableTextLayer = true;
        break;
      case &#x27;visible&#x27;:
      case &#x27;shadow&#x27;:
      case &#x27;hover&#x27;:
        var viewer = document.getElementById(&#x27;viewer&#x27;);
        viewer.classList.add(&#x27;textLayer-&#x27; + hashParams[&#x27;textLayer&#x27;]);
        break;
    }
  }

//#if !(FIREFOX || MOZCENTRAL)
  if (&#x27;pdfBug&#x27; in hashParams) {
//#else
//if (&#x27;pdfBug&#x27; in hashParams &amp;&amp; FirefoxCom.requestSync(&#x27;pdfBugEnabled&#x27;)) {
//#endif
    PDFJS.pdfBug = true;
    var pdfBug = hashParams[&#x27;pdfBug&#x27;];
    var enabled = pdfBug.split(&#x27;,&#x27;);
    PDFBug.enable(enabled);
    PDFBug.init();
  }

  if (!PDFView.supportsFullscreen) {
    document.getElementById(&#x27;presentationMode&#x27;).classList.add(&#x27;hidden&#x27;);
  }

  if (PDFView.supportsIntegratedFind) {
    document.getElementById(&#x27;viewFind&#x27;).classList.add(&#x27;hidden&#x27;);
  }

  // Listen for warnings to trigger the fallback UI.  Errors should be caught
  // and call PDFView.error() so we don&#x27;t need to listen for those.
  PDFJS.LogManager.addLogger({
    warn: function() {
      PDFView.fallback();
    }
  });

  // Suppress context menus for some controls
  document.getElementById(&#x27;scaleSelect&#x27;).oncontextmenu = noContextMenuHandler;

  var mainContainer = document.getElementById(&#x27;mainContainer&#x27;);
  var outerContainer = document.getElementById(&#x27;outerContainer&#x27;);
  mainContainer.addEventListener(&#x27;transitionend&#x27;, function(e) {
    if (e.target == mainContainer) {
      var event = document.createEvent(&#x27;UIEvents&#x27;);
      event.initUIEvent(&#x27;resize&#x27;, false, false, window, 0);
      window.dispatchEvent(event);
    }
  }, true);

  document.getElementById(&#x27;previous&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.page--;
    });

  document.getElementById(&#x27;next&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.page++;
    });

  document.getElementById(&#x27;zoomIn&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.zoomIn();
    });

  document.getElementById(&#x27;zoomOut&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.zoomOut();
    });

  document.getElementById(&#x27;presentationMode&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.presentationMode();
    });

  document.getElementById(&#x27;pageNumber&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      this.select();
    });

  document.getElementById(&#x27;pageNumber&#x27;).addEventListener(&#x27;change&#x27;,
    function() {
      // Handle the user inputting a floating point number.
      PDFView.page = (this.value | 0);

      if (this.value !== (this.value | 0).toString()) {
        this.value = PDFView.page;
      }
    });

  document.getElementById(&#x27;scaleSelect&#x27;).addEventListener(&#x27;change&#x27;,
    function() {
      PDFView.parseScale(this.value);
    });

  document.getElementById(&#x27;firstPage&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.page = 1;
    });

  document.getElementById(&#x27;lastPage&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.page = PDFView.pdfDocument.numPages;
    });

  document.getElementById(&#x27;pageRotateCcw&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.rotatePages(-90);
    });

  document.getElementById(&#x27;pageRotateCw&#x27;).addEventListener(&#x27;click&#x27;,
    function() {
      PDFView.rotatePages(90);
    });

//#if (FIREFOX || MOZCENTRAL)
//PDFView.initPassiveLoading();
//return;
//#endif

//#if !B2G
  PDFView.open(file, 0);
//#endif
}, true);

function updateViewarea() {

  if (!PDFView.initialized)
    return;
  var visible = PDFView.getVisiblePages();
  var visiblePages = visible.views;
  if (visiblePages.length === 0) {
    return;
  }

  PDFView.renderHighestPriority();

  var currentId = PDFView.page;
  var firstPage = visible.first;

  for (var i = 0, ii = visiblePages.length, stillFullyVisible = false;
       i &lt; ii; ++i) {
    var page = visiblePages[i];

    if (page.percent &lt; 100)
      break;

    if (page.id === PDFView.page) {
      stillFullyVisible = true;
      break;
    }
  }

  if (!stillFullyVisible) {
    currentId = visiblePages[0].id;
  }

  if (!PDFView.isPresentationMode) {
    updateViewarea.inProgress = true; // used in &quot;set page&quot;
    PDFView.page = currentId;
    updateViewarea.inProgress = false;
  }

  var currentScale = PDFView.currentScale;
  var currentScaleValue = PDFView.currentScaleValue;
  var normalizedScaleValue = currentScaleValue == currentScale ?
    currentScale * 100 : currentScaleValue;

  var pageNumber = firstPage.id;
  var pdfOpenParams = &#x27;#page=&#x27; + pageNumber;
  pdfOpenParams += &#x27;&amp;zoom=&#x27; + normalizedScaleValue;
  var currentPage = PDFView.pages[pageNumber - 1];
  var topLeft = currentPage.getPagePoint(PDFView.container.scrollLeft,
    (PDFView.container.scrollTop - firstPage.y));
  pdfOpenParams += &#x27;,&#x27; + Math.round(topLeft[0]) + &#x27;,&#x27; + Math.round(topLeft[1]);

  var store = PDFView.store;
  store.initializedPromise.then(function() {
    store.set(&#x27;exists&#x27;, true);
    store.set(&#x27;page&#x27;, pageNumber);
    store.set(&#x27;zoom&#x27;, normalizedScaleValue);
    store.set(&#x27;scrollLeft&#x27;, Math.round(topLeft[0]));
    store.set(&#x27;scrollTop&#x27;, Math.round(topLeft[1]));
  });

  // Update the current bookmark in the browsing history.
  PDFHistory.updateCurrentBookmark(pdfOpenParams, pageNumber);
}

window.addEventListener(&#x27;resize&#x27;, function webViewerResize(evt) {
  if (PDFView.initialized &amp;&amp;
      (document.getElementById(&#x27;pageWidthOption&#x27;).selected ||
       document.getElementById(&#x27;pageFitOption&#x27;).selected ||
       document.getElementById(&#x27;pageAutoOption&#x27;).selected)) {
    PDFView.parseScale(document.getElementById(&#x27;scaleSelect&#x27;).value);
  }
  updateViewarea();
});

window.addEventListener(&#x27;hashchange&#x27;, function webViewerHashchange(evt) {
  if (PDFHistory.isHashChangeUnlocked) {
    PDFView.setHash(document.location.hash.substring(1));
  }
});

window.addEventListener(&#x27;change&#x27;, function webViewerChange(evt) {
  var files = evt.target.files;
  if (!files || files.length === 0)
    return;

  // Read the local file into a Uint8Array.
  var fileReader = new FileReader();
  fileReader.onload = function webViewerChangeFileReaderOnload(evt) {
    var buffer = evt.target.result;
    var uint8Array = new Uint8Array(buffer);
    PDFView.open(uint8Array, 0);
  };

  var file = files[0];
  fileReader.readAsArrayBuffer(file);

}, true);

function selectScaleOption(value) {
  var options = document.getElementById(&#x27;scaleSelect&#x27;).options;
  var predefinedValueFound = false;
  for (var i = 0; i &lt; options.length; i++) {
    var option = options[i];
    if (option.value != value) {
      option.selected = false;
      continue;
    }
    option.selected = true;
    predefinedValueFound = true;
  }
  return predefinedValueFound;
}

window.addEventListener(&#x27;localized&#x27;, function localized(evt) {
  document.getElementsByTagName(&#x27;html&#x27;)[0].dir = mozL10n.getDirection();

  // Adjust the width of the zoom box to fit the content.
  // Note: This is only done if the zoom box is actually visible,
  // since otherwise element.clientWidth will return 0.
  PDFView.animationStartedPromise.then(function() {
    var container = document.getElementById(&#x27;scaleSelectContainer&#x27;);
    if (container.clientWidth &gt; 0) {
      var select = document.getElementById(&#x27;scaleSelect&#x27;);
      select.setAttribute(&#x27;style&#x27;, &#x27;min-width: inherit;&#x27;);
      var width = select.clientWidth + SCALE_SELECT_CONTAINER_PADDING;
      select.setAttribute(&#x27;style&#x27;, &#x27;min-width: &#x27; +
                                   (width + SCALE_SELECT_PADDING) + &#x27;px;&#x27;);
      container.setAttribute(&#x27;style&#x27;, &#x27;min-width: &#x27; + width + &#x27;px; &#x27; +
                                      &#x27;max-width: &#x27; + width + &#x27;px;&#x27;);
    }
  });
}, true);

window.addEventListener(&#x27;scalechange&#x27;, function scalechange(evt) {
  document.getElementById(&#x27;zoomOut&#x27;).disabled = (evt.scale === MIN_SCALE);
  document.getElementById(&#x27;zoomIn&#x27;).disabled = (evt.scale === MAX_SCALE);

  var customScaleOption = document.getElementById(&#x27;customScaleOption&#x27;);
  customScaleOption.selected = false;

  if (!evt.resetAutoSettings &amp;&amp;
      (document.getElementById(&#x27;pageWidthOption&#x27;).selected ||
       document.getElementById(&#x27;pageFitOption&#x27;).selected ||
       document.getElementById(&#x27;pageAutoOption&#x27;).selected)) {
    updateViewarea();
    return;
  }

  var predefinedValueFound = selectScaleOption(&#x27;&#x27; + evt.scale);
  if (!predefinedValueFound) {
    customScaleOption.textContent = Math.round(evt.scale * 10000) / 100 + &#x27;%&#x27;;
    customScaleOption.selected = true;
  }
  updateViewarea();
}, true);

window.addEventListener(&#x27;pagechange&#x27;, function pagechange(evt) {
  var page = evt.pageNumber;
  if (PDFView.previousPageNumber !== page) {
    document.getElementById(&#x27;pageNumber&#x27;).value = page;
  }
  document.getElementById(&#x27;previous&#x27;).disabled = (page &lt;= 1);
  document.getElementById(&#x27;next&#x27;).disabled = (page &gt;= PDFView.pages.length);
}, true);

// Firefox specific event, so that we can prevent browser from zooming
window.addEventListener(&#x27;DOMMouseScroll&#x27;, function(evt) {
  if (evt.ctrlKey) {
    evt.preventDefault();

    var ticks = evt.detail;
    var direction = (ticks &gt; 0) ? &#x27;zoomOut&#x27; : &#x27;zoomIn&#x27;;
    for (var i = 0, length = Math.abs(ticks); i &lt; length; i++)
      PDFView[direction]();
  } else if (PDFView.isPresentationMode) {
    var FIREFOX_DELTA_FACTOR = -40;
    PDFView.mouseScroll(evt.detail * FIREFOX_DELTA_FACTOR);
  }
}, false);

window.addEventListener(&#x27;mousemove&#x27;, function mousemove(evt) {
  if (PDFView.isPresentationMode) {
    PDFView.showPresentationControls();
  }
}, false);

window.addEventListener(&#x27;mousedown&#x27;, function mousedown(evt) {
  if (PDFView.isPresentationMode &amp;&amp; evt.button === 0) {
    // Enable clicking of links in presentation mode.
    // Note: Only links that point to the currently loaded PDF document works.
    var targetHref = evt.target.href;
    var internalLink = targetHref &amp;&amp; (targetHref.replace(/#.*$/, &#x27;&#x27;) ===
                                      window.location.href.replace(/#.*$/, &#x27;&#x27;));
    if (!internalLink) {
      // Unless an internal link was clicked, advance a page in presentation
      // mode.
      evt.preventDefault();
      PDFView.page++;
    }
  }
}, false);

window.addEventListener(&#x27;click&#x27;, function click(evt) {
  if (PDFView.isPresentationMode &amp;&amp; evt.button === 0) {
    // Necessary since preventDefault() in &#x27;mousedown&#x27; won&#x27;t stop
    // the event propagation in all circumstances.
    evt.preventDefault();
  }
}, false);

window.addEventListener(&#x27;keydown&#x27;, function keydown(evt) {
  var handled = false;
  var cmd = (evt.ctrlKey ? 1 : 0) |
            (evt.altKey ? 2 : 0) |
            (evt.shiftKey ? 4 : 0) |
            (evt.metaKey ? 8 : 0);

  // First, handle the key bindings that are independent whether an input
  // control is selected or not.
  if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) {
    // either CTRL or META key with optional SHIFT.
    switch (evt.keyCode) {
      case 70: // f
        if (!PDFView.supportsIntegratedFind) {
          handled = true;
        }
        break;
      case 71: // g
        if (!PDFView.supportsIntegratedFind) {
          handled = true;
        }
        break;
      case 61: // FF/Mac &#x27;=&#x27;
      case 107: // FF &#x27;+&#x27; and &#x27;=&#x27;
      case 187: // Chrome &#x27;+&#x27;
      case 171: // FF with German keyboard
        PDFView.zoomIn();
        handled = true;
        break;
      case 173: // FF/Mac &#x27;-&#x27;
      case 109: // FF &#x27;-&#x27;
      case 189: // Chrome &#x27;-&#x27;
        PDFView.zoomOut();
        handled = true;
        break;
      case 48: // &#x27;0&#x27;
      case 96: // &#x27;0&#x27; on Numpad of Swedish keyboard
        PDFView.parseScale(DEFAULT_SCALE, true);
        handled = false; // keeping it unhandled (to restore page zoom to 100%)
        break;
    }
  }

  // CTRL+ALT or Option+Command
  if (cmd === 3 || cmd === 10) {
    switch (evt.keyCode) {
      case 80: // p
        PDFView.presentationMode();
        handled = true;
        break;
    }
  }

  if (handled) {
    evt.preventDefault();
    return;
  }

  // Some shortcuts should not get handled if a control/input element
  // is selected.
  var curElement = document.activeElement || document.querySelector(&#x27;:focus&#x27;);
  if (curElement &amp;&amp; (curElement.tagName.toUpperCase() === &#x27;INPUT&#x27; ||
                     curElement.tagName.toUpperCase() === &#x27;SELECT&#x27;)) {
    return;
  }
  var controlsElement = document.getElementById(&#x27;toolbar&#x27;);
  while (curElement) {
    if (curElement === controlsElement &amp;&amp; !PDFView.isPresentationMode)
      return; // ignoring if the &#x27;toolbar&#x27; element is focused
    curElement = curElement.parentNode;
  }

  if (cmd === 0) { // no control key pressed at all.
    switch (evt.keyCode) {
      case 38: // up arrow
      case 33: // pg up
      case 8: // backspace
        if (!PDFView.isPresentationMode &amp;&amp;
            PDFView.currentScaleValue !== &#x27;page-fit&#x27;) {
          break;
        }
        /* in presentation mode */
        /* falls through */
      case 37: // left arrow
        // horizontal scrolling using arrow keys
        if (PDFView.isHorizontalScrollbarEnabled) {
          break;
        }
        /* falls through */
      case 75: // &#x27;k&#x27;
      case 80: // &#x27;p&#x27;
        PDFView.page--;
        handled = true;
        break;
      case 27: // esc key
        break;
      case 40: // down arrow
      case 34: // pg down
      case 32: // spacebar
        if (!PDFView.isPresentationMode &amp;&amp;
            PDFView.currentScaleValue !== &#x27;page-fit&#x27;) {
          break;
        }
        /* falls through */
      case 39: // right arrow
        // horizontal scrolling using arrow keys
        if (PDFView.isHorizontalScrollbarEnabled) {
          break;
        }
        /* falls through */
      case 74: // &#x27;j&#x27;
      case 78: // &#x27;n&#x27;
        PDFView.page++;
        handled = true;
        break;

      case 36: // home
        if (PDFView.isPresentationMode) {
          PDFView.page = 1;
          handled = true;
        }
        break;
      case 35: // end
        if (PDFView.isPresentationMode) {
          PDFView.page = PDFView.pdfDocument.numPages;
          handled = true;
        }
        break;

      case 82: // &#x27;r&#x27;
        PDFView.rotatePages(90);
        break;
    }
  }

  if (cmd === 4) { // shift-key
    switch (evt.keyCode) {
      case 32: // spacebar
        if (!PDFView.isPresentationMode &amp;&amp;
            PDFView.currentScaleValue !== &#x27;page-fit&#x27;) {
          break;
        }
        PDFView.page--;
        handled = true;
        break;

      case 82: // &#x27;r&#x27;
        PDFView.rotatePages(-90);
        break;
    }
  }

  if (cmd === 2) { // alt-key
    switch (evt.keyCode) {
      case 37: // left arrow
        if (PDFView.isPresentationMode) {
          PDFHistory.back();
          handled = true;
        }
        break;
      case 39: // right arrow
        if (PDFView.isPresentationMode) {
          PDFHistory.forward();
          handled = true;
        }
        break;
    }
  }

  if (handled) {
    evt.preventDefault();
    PDFView.clearMouseScrollState();
  }
});

(function presentationModeClosure() {
  function presentationModeChange(e) {
    var isPresentationMode = document.fullscreenElement ||
                             document.mozFullScreen ||
                             document.webkitIsFullScreen;

    if (isPresentationMode) {
      PDFView.enterPresentationMode();
    } else {
      PDFView.exitPresentationMode();
    }
  }

  window.addEventListener(&#x27;fullscreenchange&#x27;, presentationModeChange, false);
  window.addEventListener(&#x27;mozfullscreenchange&#x27;, presentationModeChange, false);
  window.addEventListener(&#x27;webkitfullscreenchange&#x27;, presentationModeChange,
                          false);
})();

(function animationStartedClosure() {
  // The offsetParent is not set until the pdf.js iframe or object is visible.
  // Waiting for first animation.
  var requestAnimationFrame = window.requestAnimationFrame ||
                              window.mozRequestAnimationFrame ||
                              window.webkitRequestAnimationFrame ||
                              window.oRequestAnimationFrame ||
                              window.msRequestAnimationFrame ||
                              function startAtOnce(callback) { callback(); };
  PDFView.animationStartedPromise = new PDFJS.Promise();
  requestAnimationFrame(function onAnimationFrame() {
    PDFView.animationStartedPromise.resolve();
  });
})();

//#if B2G
//window.navigator.mozSetMessageHandler(&#x27;activity&#x27;, function(activity) {
//  var url = activity.source.data.url;
//  PDFJS.maxImageSize = 1024 * 1024;
//  PDFView.open(url);
//  var cancelButton = document.getElementById(&#x27;activityClose&#x27;);
//  cancelButton.addEventListener(&#x27;click&#x27;, function() {
//    activity.postResult(&#x27;close&#x27;);
//  });
//});
//#endif

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
