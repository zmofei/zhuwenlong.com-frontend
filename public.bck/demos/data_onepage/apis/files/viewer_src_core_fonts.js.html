<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>viewer\src\core\fonts.js - 资料库</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="资料库"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/_fileup.html">_fileup</a></li>
            
                <li><a href="../classes/db_print.html">db_print</a></li>
            
                <li><a href="../classes/disk.html">disk</a></li>
            
                <li><a href="../classes/fc.html">fc</a></li>
            
                <li><a href="../classes/select.html">select</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: viewer\src\core\fonts.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals assert, bytesToString, CIDToUnicodeMaps, error, ExpertCharset,
           ExpertSubsetCharset, FileReaderSync, GlyphsUnicode,
           info, isArray, isNum, ISOAdobeCharset, Stream,
           stringToBytes, TextDecoder, TODO, warn, Lexer, Util,
           FONT_IDENTITY_MATRIX */

&#x27;use strict&#x27;;

// Unicode Private Use Area
var CMAP_GLYPH_OFFSET = 0xE000;
var GLYPH_AREA_SIZE = 0x1900;
var SYMBOLIC_FONT_GLYPH_OFFSET = 0xF000;

// PDF Glyph Space Units are one Thousandth of a TextSpace Unit
// except for Type 3 fonts
var PDF_GLYPH_SPACE_UNITS = 1000;

// Hinting is currently disabled due to unknown problems on windows
// in tracemonkey and various other pdfs with type1 fonts.
var HINTING_ENABLED = false;

// Accented charactars are not displayed properly on windows, using this flag
// to control analysis of seac charstrings.
var SEAC_ANALYSIS_ENABLED = false;

var FontFlags = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};

var Encodings = {
  ExpertEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclamsmall&#x27;, &#x27;Hungarumlautsmall&#x27;, &#x27;&#x27;, &#x27;dollaroldstyle&#x27;,
    &#x27;dollarsuperior&#x27;, &#x27;ampersandsmall&#x27;, &#x27;Acutesmall&#x27;, &#x27;parenleftsuperior&#x27;,
    &#x27;parenrightsuperior&#x27;, &#x27;twodotenleader&#x27;, &#x27;onedotenleader&#x27;, &#x27;comma&#x27;,
    &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;fraction&#x27;, &#x27;zerooldstyle&#x27;, &#x27;oneoldstyle&#x27;,
    &#x27;twooldstyle&#x27;, &#x27;threeoldstyle&#x27;, &#x27;fouroldstyle&#x27;, &#x27;fiveoldstyle&#x27;,
    &#x27;sixoldstyle&#x27;, &#x27;sevenoldstyle&#x27;, &#x27;eightoldstyle&#x27;, &#x27;nineoldstyle&#x27;, &#x27;colon&#x27;,
    &#x27;semicolon&#x27;, &#x27;commasuperior&#x27;, &#x27;threequartersemdash&#x27;, &#x27;periodsuperior&#x27;,
    &#x27;questionsmall&#x27;, &#x27;&#x27;, &#x27;asuperior&#x27;, &#x27;bsuperior&#x27;, &#x27;centsuperior&#x27;, &#x27;dsuperior&#x27;,
    &#x27;esuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;isuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;lsuperior&#x27;, &#x27;msuperior&#x27;,
    &#x27;nsuperior&#x27;, &#x27;osuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;rsuperior&#x27;, &#x27;ssuperior&#x27;, &#x27;tsuperior&#x27;,
    &#x27;&#x27;, &#x27;ff&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;ffi&#x27;, &#x27;ffl&#x27;, &#x27;parenleftinferior&#x27;, &#x27;&#x27;,
    &#x27;parenrightinferior&#x27;, &#x27;Circumflexsmall&#x27;, &#x27;hyphensuperior&#x27;, &#x27;Gravesmall&#x27;,
    &#x27;Asmall&#x27;, &#x27;Bsmall&#x27;, &#x27;Csmall&#x27;, &#x27;Dsmall&#x27;, &#x27;Esmall&#x27;, &#x27;Fsmall&#x27;, &#x27;Gsmall&#x27;,
    &#x27;Hsmall&#x27;, &#x27;Ismall&#x27;, &#x27;Jsmall&#x27;, &#x27;Ksmall&#x27;, &#x27;Lsmall&#x27;, &#x27;Msmall&#x27;, &#x27;Nsmall&#x27;,
    &#x27;Osmall&#x27;, &#x27;Psmall&#x27;, &#x27;Qsmall&#x27;, &#x27;Rsmall&#x27;, &#x27;Ssmall&#x27;, &#x27;Tsmall&#x27;, &#x27;Usmall&#x27;,
    &#x27;Vsmall&#x27;, &#x27;Wsmall&#x27;, &#x27;Xsmall&#x27;, &#x27;Ysmall&#x27;, &#x27;Zsmall&#x27;, &#x27;colonmonetary&#x27;,
    &#x27;onefitted&#x27;, &#x27;rupiah&#x27;, &#x27;Tildesmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;exclamdownsmall&#x27;, &#x27;centoldstyle&#x27;, &#x27;Lslashsmall&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;Scaronsmall&#x27;, &#x27;Zcaronsmall&#x27;, &#x27;Dieresissmall&#x27;, &#x27;Brevesmall&#x27;,
    &#x27;Caronsmall&#x27;, &#x27;&#x27;, &#x27;Dotaccentsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Macronsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;figuredash&#x27;, &#x27;hypheninferior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Ogoneksmall&#x27;, &#x27;Ringsmall&#x27;,
    &#x27;Cedillasmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;onequarter&#x27;, &#x27;onehalf&#x27;, &#x27;threequarters&#x27;,
    &#x27;questiondownsmall&#x27;, &#x27;oneeighth&#x27;, &#x27;threeeighths&#x27;, &#x27;fiveeighths&#x27;,
    &#x27;seveneighths&#x27;, &#x27;onethird&#x27;, &#x27;twothirds&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;zerosuperior&#x27;,
    &#x27;onesuperior&#x27;, &#x27;twosuperior&#x27;, &#x27;threesuperior&#x27;, &#x27;foursuperior&#x27;,
    &#x27;fivesuperior&#x27;, &#x27;sixsuperior&#x27;, &#x27;sevensuperior&#x27;, &#x27;eightsuperior&#x27;,
    &#x27;ninesuperior&#x27;, &#x27;zeroinferior&#x27;, &#x27;oneinferior&#x27;, &#x27;twoinferior&#x27;,
    &#x27;threeinferior&#x27;, &#x27;fourinferior&#x27;, &#x27;fiveinferior&#x27;, &#x27;sixinferior&#x27;,
    &#x27;seveninferior&#x27;, &#x27;eightinferior&#x27;, &#x27;nineinferior&#x27;, &#x27;centinferior&#x27;,
    &#x27;dollarinferior&#x27;, &#x27;periodinferior&#x27;, &#x27;commainferior&#x27;, &#x27;Agravesmall&#x27;,
    &#x27;Aacutesmall&#x27;, &#x27;Acircumflexsmall&#x27;, &#x27;Atildesmall&#x27;, &#x27;Adieresissmall&#x27;,
    &#x27;Aringsmall&#x27;, &#x27;AEsmall&#x27;, &#x27;Ccedillasmall&#x27;, &#x27;Egravesmall&#x27;, &#x27;Eacutesmall&#x27;,
    &#x27;Ecircumflexsmall&#x27;, &#x27;Edieresissmall&#x27;, &#x27;Igravesmall&#x27;, &#x27;Iacutesmall&#x27;,
    &#x27;Icircumflexsmall&#x27;, &#x27;Idieresissmall&#x27;, &#x27;Ethsmall&#x27;, &#x27;Ntildesmall&#x27;,
    &#x27;Ogravesmall&#x27;, &#x27;Oacutesmall&#x27;, &#x27;Ocircumflexsmall&#x27;, &#x27;Otildesmall&#x27;,
    &#x27;Odieresissmall&#x27;, &#x27;OEsmall&#x27;, &#x27;Oslashsmall&#x27;, &#x27;Ugravesmall&#x27;, &#x27;Uacutesmall&#x27;,
    &#x27;Ucircumflexsmall&#x27;, &#x27;Udieresissmall&#x27;, &#x27;Yacutesmall&#x27;, &#x27;Thornsmall&#x27;,
    &#x27;Ydieresissmall&#x27;],
  MacExpertEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclamsmall&#x27;, &#x27;Hungarumlautsmall&#x27;, &#x27;centoldstyle&#x27;,
    &#x27;dollaroldstyle&#x27;, &#x27;dollarsuperior&#x27;, &#x27;ampersandsmall&#x27;, &#x27;Acutesmall&#x27;,
    &#x27;parenleftsuperior&#x27;, &#x27;parenrightsuperior&#x27;, &#x27;twodotenleader&#x27;,
    &#x27;onedotenleader&#x27;, &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;fraction&#x27;, &#x27;zerooldstyle&#x27;,
    &#x27;oneoldstyle&#x27;, &#x27;twooldstyle&#x27;, &#x27;threeoldstyle&#x27;, &#x27;fouroldstyle&#x27;,
    &#x27;fiveoldstyle&#x27;, &#x27;sixoldstyle&#x27;, &#x27;sevenoldstyle&#x27;, &#x27;eightoldstyle&#x27;,
    &#x27;nineoldstyle&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;&#x27;, &#x27;threequartersemdash&#x27;, &#x27;&#x27;,
    &#x27;questionsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Ethsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;onequarter&#x27;,
    &#x27;onehalf&#x27;, &#x27;threequarters&#x27;, &#x27;oneeighth&#x27;, &#x27;threeeighths&#x27;, &#x27;fiveeighths&#x27;,
    &#x27;seveneighths&#x27;, &#x27;onethird&#x27;, &#x27;twothirds&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;ff&#x27;,
    &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;ffi&#x27;, &#x27;ffl&#x27;, &#x27;parenleftinferior&#x27;, &#x27;&#x27;, &#x27;parenrightinferior&#x27;,
    &#x27;Circumflexsmall&#x27;, &#x27;hypheninferior&#x27;, &#x27;Gravesmall&#x27;, &#x27;Asmall&#x27;, &#x27;Bsmall&#x27;,
    &#x27;Csmall&#x27;, &#x27;Dsmall&#x27;, &#x27;Esmall&#x27;, &#x27;Fsmall&#x27;, &#x27;Gsmall&#x27;, &#x27;Hsmall&#x27;, &#x27;Ismall&#x27;,
    &#x27;Jsmall&#x27;, &#x27;Ksmall&#x27;, &#x27;Lsmall&#x27;, &#x27;Msmall&#x27;, &#x27;Nsmall&#x27;, &#x27;Osmall&#x27;, &#x27;Psmall&#x27;,
    &#x27;Qsmall&#x27;, &#x27;Rsmall&#x27;, &#x27;Ssmall&#x27;, &#x27;Tsmall&#x27;, &#x27;Usmall&#x27;, &#x27;Vsmall&#x27;, &#x27;Wsmall&#x27;,
    &#x27;Xsmall&#x27;, &#x27;Ysmall&#x27;, &#x27;Zsmall&#x27;, &#x27;colonmonetary&#x27;, &#x27;onefitted&#x27;, &#x27;rupiah&#x27;,
    &#x27;Tildesmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;asuperior&#x27;, &#x27;centsuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;Aacutesmall&#x27;, &#x27;Agravesmall&#x27;, &#x27;Acircumflexsmall&#x27;, &#x27;Adieresissmall&#x27;,
    &#x27;Atildesmall&#x27;, &#x27;Aringsmall&#x27;, &#x27;Ccedillasmall&#x27;, &#x27;Eacutesmall&#x27;, &#x27;Egravesmall&#x27;,
    &#x27;Ecircumflexsmall&#x27;, &#x27;Edieresissmall&#x27;, &#x27;Iacutesmall&#x27;, &#x27;Igravesmall&#x27;,
    &#x27;Icircumflexsmall&#x27;, &#x27;Idieresissmall&#x27;, &#x27;Ntildesmall&#x27;, &#x27;Oacutesmall&#x27;,
    &#x27;Ogravesmall&#x27;, &#x27;Ocircumflexsmall&#x27;, &#x27;Odieresissmall&#x27;, &#x27;Otildesmall&#x27;,
    &#x27;Uacutesmall&#x27;, &#x27;Ugravesmall&#x27;, &#x27;Ucircumflexsmall&#x27;, &#x27;Udieresissmall&#x27;, &#x27;&#x27;,
    &#x27;eightsuperior&#x27;, &#x27;fourinferior&#x27;, &#x27;threeinferior&#x27;, &#x27;sixinferior&#x27;,
    &#x27;eightinferior&#x27;, &#x27;seveninferior&#x27;, &#x27;Scaronsmall&#x27;, &#x27;&#x27;, &#x27;centinferior&#x27;,
    &#x27;twoinferior&#x27;, &#x27;&#x27;, &#x27;Dieresissmall&#x27;, &#x27;&#x27;, &#x27;Caronsmall&#x27;, &#x27;osuperior&#x27;,
    &#x27;fiveinferior&#x27;, &#x27;&#x27;, &#x27;commainferior&#x27;, &#x27;periodinferior&#x27;, &#x27;Yacutesmall&#x27;, &#x27;&#x27;,
    &#x27;dollarinferior&#x27;, &#x27;&#x27;, &#x27;Thornsmall&#x27;, &#x27;&#x27;, &#x27;nineinferior&#x27;, &#x27;zeroinferior&#x27;,
    &#x27;Zcaronsmall&#x27;, &#x27;AEsmall&#x27;, &#x27;Oslashsmall&#x27;, &#x27;questiondownsmall&#x27;,
    &#x27;oneinferior&#x27;, &#x27;Lslashsmall&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Cedillasmall&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;OEsmall&#x27;, &#x27;figuredash&#x27;, &#x27;hyphensuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;exclamdownsmall&#x27;, &#x27;&#x27;, &#x27;Ydieresissmall&#x27;, &#x27;&#x27;, &#x27;onesuperior&#x27;, &#x27;twosuperior&#x27;,
    &#x27;threesuperior&#x27;, &#x27;foursuperior&#x27;, &#x27;fivesuperior&#x27;, &#x27;sixsuperior&#x27;,
    &#x27;sevensuperior&#x27;, &#x27;ninesuperior&#x27;, &#x27;zerosuperior&#x27;, &#x27;&#x27;, &#x27;esuperior&#x27;,
    &#x27;rsuperior&#x27;, &#x27;tsuperior&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;isuperior&#x27;, &#x27;ssuperior&#x27;, &#x27;dsuperior&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;lsuperior&#x27;, &#x27;Ogoneksmall&#x27;, &#x27;Brevesmall&#x27;,
    &#x27;Macronsmall&#x27;, &#x27;bsuperior&#x27;, &#x27;nsuperior&#x27;, &#x27;msuperior&#x27;, &#x27;commasuperior&#x27;,
    &#x27;periodsuperior&#x27;, &#x27;Dotaccentsmall&#x27;, &#x27;Ringsmall&#x27;],
  MacRomanEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;,
    &#x27;ampersand&#x27;, &#x27;quotesingle&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;,
    &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;,
    &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;,
    &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;,
    &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;,
    &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;,
    &#x27;asciicircum&#x27;, &#x27;underscore&#x27;, &#x27;grave&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;,
    &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
    &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;, &#x27;&#x27;,
    &#x27;Adieresis&#x27;, &#x27;Aring&#x27;, &#x27;Ccedilla&#x27;, &#x27;Eacute&#x27;, &#x27;Ntilde&#x27;, &#x27;Odieresis&#x27;,
    &#x27;Udieresis&#x27;, &#x27;aacute&#x27;, &#x27;agrave&#x27;, &#x27;acircumflex&#x27;, &#x27;adieresis&#x27;, &#x27;atilde&#x27;,
    &#x27;aring&#x27;, &#x27;ccedilla&#x27;, &#x27;eacute&#x27;, &#x27;egrave&#x27;, &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;,
    &#x27;iacute&#x27;, &#x27;igrave&#x27;, &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;ntilde&#x27;, &#x27;oacute&#x27;,
    &#x27;ograve&#x27;, &#x27;ocircumflex&#x27;, &#x27;odieresis&#x27;, &#x27;otilde&#x27;, &#x27;uacute&#x27;, &#x27;ugrave&#x27;,
    &#x27;ucircumflex&#x27;, &#x27;udieresis&#x27;, &#x27;dagger&#x27;, &#x27;degree&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;,
    &#x27;section&#x27;, &#x27;bullet&#x27;, &#x27;paragraph&#x27;, &#x27;germandbls&#x27;, &#x27;registered&#x27;, &#x27;copyright&#x27;,
    &#x27;trademark&#x27;, &#x27;acute&#x27;, &#x27;dieresis&#x27;, &#x27;notequal&#x27;, &#x27;AE&#x27;, &#x27;Oslash&#x27;, &#x27;infinity&#x27;,
    &#x27;plusminus&#x27;, &#x27;lessequal&#x27;, &#x27;greaterequal&#x27;, &#x27;yen&#x27;, &#x27;mu&#x27;, &#x27;partialdiff&#x27;,
    &#x27;summation&#x27;, &#x27;product&#x27;, &#x27;pi&#x27;, &#x27;integral&#x27;, &#x27;ordfeminine&#x27;, &#x27;ordmasculine&#x27;,
    &#x27;Omega&#x27;, &#x27;ae&#x27;, &#x27;oslash&#x27;, &#x27;questiondown&#x27;, &#x27;exclamdown&#x27;, &#x27;logicalnot&#x27;,
    &#x27;radical&#x27;, &#x27;florin&#x27;, &#x27;approxequal&#x27;, &#x27;Delta&#x27;, &#x27;guillemotleft&#x27;,
    &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;, &#x27;&#x27;, &#x27;Agrave&#x27;, &#x27;Atilde&#x27;, &#x27;Otilde&#x27;, &#x27;OE&#x27;,
    &#x27;oe&#x27;, &#x27;endash&#x27;, &#x27;emdash&#x27;, &#x27;quotedblleft&#x27;, &#x27;quotedblright&#x27;, &#x27;quoteleft&#x27;,
    &#x27;quoteright&#x27;, &#x27;divide&#x27;, &#x27;lozenge&#x27;, &#x27;ydieresis&#x27;, &#x27;Ydieresis&#x27;, &#x27;fraction&#x27;,
    &#x27;currency&#x27;, &#x27;guilsinglleft&#x27;, &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;daggerdbl&#x27;,
    &#x27;periodcentered&#x27;, &#x27;quotesinglbase&#x27;, &#x27;quotedblbase&#x27;, &#x27;perthousand&#x27;,
    &#x27;Acircumflex&#x27;, &#x27;Ecircumflex&#x27;, &#x27;Aacute&#x27;, &#x27;Edieresis&#x27;, &#x27;Egrave&#x27;, &#x27;Iacute&#x27;,
    &#x27;Icircumflex&#x27;, &#x27;Idieresis&#x27;, &#x27;Igrave&#x27;, &#x27;Oacute&#x27;, &#x27;Ocircumflex&#x27;, &#x27;apple&#x27;,
    &#x27;Ograve&#x27;, &#x27;Uacute&#x27;, &#x27;Ucircumflex&#x27;, &#x27;Ugrave&#x27;, &#x27;dotlessi&#x27;, &#x27;circumflex&#x27;,
    &#x27;tilde&#x27;, &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;, &#x27;hungarumlaut&#x27;,
    &#x27;ogonek&#x27;, &#x27;caron&#x27;],
  StandardEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;,
    &#x27;ampersand&#x27;, &#x27;quoteright&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;,
    &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;,
    &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;,
    &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;,
    &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;,
    &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;,
    &#x27;asciicircum&#x27;, &#x27;underscore&#x27;, &#x27;quoteleft&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,
    &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;,
    &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;exclamdown&#x27;,
    &#x27;cent&#x27;, &#x27;sterling&#x27;, &#x27;fraction&#x27;, &#x27;yen&#x27;, &#x27;florin&#x27;, &#x27;section&#x27;, &#x27;currency&#x27;,
    &#x27;quotesingle&#x27;, &#x27;quotedblleft&#x27;, &#x27;guillemotleft&#x27;, &#x27;guilsinglleft&#x27;,
    &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;&#x27;, &#x27;endash&#x27;, &#x27;dagger&#x27;, &#x27;daggerdbl&#x27;,
    &#x27;periodcentered&#x27;, &#x27;&#x27;, &#x27;paragraph&#x27;, &#x27;bullet&#x27;, &#x27;quotesinglbase&#x27;,
    &#x27;quotedblbase&#x27;, &#x27;quotedblright&#x27;, &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;,
    &#x27;perthousand&#x27;, &#x27;&#x27;, &#x27;questiondown&#x27;, &#x27;&#x27;, &#x27;grave&#x27;, &#x27;acute&#x27;, &#x27;circumflex&#x27;,
    &#x27;tilde&#x27;, &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;dieresis&#x27;, &#x27;&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;,
    &#x27;&#x27;, &#x27;hungarumlaut&#x27;, &#x27;ogonek&#x27;, &#x27;caron&#x27;, &#x27;emdash&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;AE&#x27;, &#x27;&#x27;, &#x27;ordfeminine&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;Lslash&#x27;, &#x27;Oslash&#x27;, &#x27;OE&#x27;, &#x27;ordmasculine&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;ae&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;dotlessi&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;lslash&#x27;, &#x27;oslash&#x27;, &#x27;oe&#x27;, &#x27;germandbls&#x27;],
  WinAnsiEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;,
    &#x27;ampersand&#x27;, &#x27;quotesingle&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;,
    &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;,
    &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;,
    &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;,
    &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;,
    &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;,
    &#x27;asciicircum&#x27;, &#x27;underscore&#x27;, &#x27;grave&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;,
    &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,
    &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;,
    &#x27;bullet&#x27;, &#x27;Euro&#x27;, &#x27;bullet&#x27;, &#x27;quotesinglbase&#x27;, &#x27;florin&#x27;, &#x27;quotedblbase&#x27;,
    &#x27;ellipsis&#x27;, &#x27;dagger&#x27;, &#x27;daggerdbl&#x27;, &#x27;circumflex&#x27;, &#x27;perthousand&#x27;, &#x27;Scaron&#x27;,
    &#x27;guilsinglleft&#x27;, &#x27;OE&#x27;, &#x27;bullet&#x27;, &#x27;Zcaron&#x27;, &#x27;bullet&#x27;, &#x27;bullet&#x27;, &#x27;quoteleft&#x27;,
    &#x27;quoteright&#x27;, &#x27;quotedblleft&#x27;, &#x27;quotedblright&#x27;, &#x27;bullet&#x27;, &#x27;endash&#x27;,
    &#x27;emdash&#x27;, &#x27;tilde&#x27;, &#x27;trademark&#x27;, &#x27;scaron&#x27;, &#x27;guilsinglright&#x27;, &#x27;oe&#x27;, &#x27;bullet&#x27;,
    &#x27;zcaron&#x27;, &#x27;Ydieresis&#x27;, &#x27;&#x27;, &#x27;exclamdown&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;,
    &#x27;currency&#x27;, &#x27;yen&#x27;, &#x27;brokenbar&#x27;, &#x27;section&#x27;, &#x27;dieresis&#x27;, &#x27;copyright&#x27;,
    &#x27;ordfeminine&#x27;, &#x27;guillemotleft&#x27;, &#x27;logicalnot&#x27;, &#x27;hyphen&#x27;, &#x27;registered&#x27;,
    &#x27;macron&#x27;, &#x27;degree&#x27;, &#x27;plusminus&#x27;, &#x27;twosuperior&#x27;, &#x27;threesuperior&#x27;, &#x27;acute&#x27;,
    &#x27;mu&#x27;, &#x27;paragraph&#x27;, &#x27;periodcentered&#x27;, &#x27;cedilla&#x27;, &#x27;onesuperior&#x27;,
    &#x27;ordmasculine&#x27;, &#x27;guillemotright&#x27;, &#x27;onequarter&#x27;, &#x27;onehalf&#x27;, &#x27;threequarters&#x27;,
    &#x27;questiondown&#x27;, &#x27;Agrave&#x27;, &#x27;Aacute&#x27;, &#x27;Acircumflex&#x27;, &#x27;Atilde&#x27;, &#x27;Adieresis&#x27;,
    &#x27;Aring&#x27;, &#x27;AE&#x27;, &#x27;Ccedilla&#x27;, &#x27;Egrave&#x27;, &#x27;Eacute&#x27;, &#x27;Ecircumflex&#x27;, &#x27;Edieresis&#x27;,
    &#x27;Igrave&#x27;, &#x27;Iacute&#x27;, &#x27;Icircumflex&#x27;, &#x27;Idieresis&#x27;, &#x27;Eth&#x27;, &#x27;Ntilde&#x27;, &#x27;Ograve&#x27;,
    &#x27;Oacute&#x27;, &#x27;Ocircumflex&#x27;, &#x27;Otilde&#x27;, &#x27;Odieresis&#x27;, &#x27;multiply&#x27;, &#x27;Oslash&#x27;,
    &#x27;Ugrave&#x27;, &#x27;Uacute&#x27;, &#x27;Ucircumflex&#x27;, &#x27;Udieresis&#x27;, &#x27;Yacute&#x27;, &#x27;Thorn&#x27;,
    &#x27;germandbls&#x27;, &#x27;agrave&#x27;, &#x27;aacute&#x27;, &#x27;acircumflex&#x27;, &#x27;atilde&#x27;, &#x27;adieresis&#x27;,
    &#x27;aring&#x27;, &#x27;ae&#x27;, &#x27;ccedilla&#x27;, &#x27;egrave&#x27;, &#x27;eacute&#x27;, &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;,
    &#x27;igrave&#x27;, &#x27;iacute&#x27;, &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;eth&#x27;, &#x27;ntilde&#x27;, &#x27;ograve&#x27;,
    &#x27;oacute&#x27;, &#x27;ocircumflex&#x27;, &#x27;otilde&#x27;, &#x27;odieresis&#x27;, &#x27;divide&#x27;, &#x27;oslash&#x27;,
    &#x27;ugrave&#x27;, &#x27;uacute&#x27;, &#x27;ucircumflex&#x27;, &#x27;udieresis&#x27;, &#x27;yacute&#x27;, &#x27;thorn&#x27;,
    &#x27;ydieresis&#x27;],
  symbolsEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;universal&#x27;, &#x27;numbersign&#x27;, &#x27;existential&#x27;, &#x27;percent&#x27;,
    &#x27;ampersand&#x27;, &#x27;suchthat&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asteriskmath&#x27;, &#x27;plus&#x27;,
    &#x27;comma&#x27;, &#x27;minus&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;,
    &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;,
    &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;congruent&#x27;, &#x27;Alpha&#x27;, &#x27;Beta&#x27;, &#x27;Chi&#x27;,
    &#x27;Delta&#x27;, &#x27;Epsilon&#x27;, &#x27;Phi&#x27;, &#x27;Gamma&#x27;, &#x27;Eta&#x27;, &#x27;Iota&#x27;, &#x27;theta1&#x27;, &#x27;Kappa&#x27;,
    &#x27;Lambda&#x27;, &#x27;Mu&#x27;, &#x27;Nu&#x27;, &#x27;Omicron&#x27;, &#x27;Pi&#x27;, &#x27;Theta&#x27;, &#x27;Rho&#x27;, &#x27;Sigma&#x27;, &#x27;Tau&#x27;,
    &#x27;Upsilon&#x27;, &#x27;sigma1&#x27;, &#x27;Omega&#x27;, &#x27;Xi&#x27;, &#x27;Psi&#x27;, &#x27;Zeta&#x27;, &#x27;bracketleft&#x27;,
    &#x27;therefore&#x27;, &#x27;bracketright&#x27;, &#x27;perpendicular&#x27;, &#x27;underscore&#x27;, &#x27;radicalex&#x27;,
    &#x27;alpha&#x27;, &#x27;beta&#x27;, &#x27;chi&#x27;, &#x27;delta&#x27;, &#x27;epsilon&#x27;, &#x27;phi&#x27;, &#x27;gamma&#x27;, &#x27;eta&#x27;, &#x27;iota&#x27;,
    &#x27;phi1&#x27;, &#x27;kappa&#x27;, &#x27;lambda&#x27;, &#x27;mu&#x27;, &#x27;nu&#x27;, &#x27;omicron&#x27;, &#x27;pi&#x27;, &#x27;theta&#x27;, &#x27;rho&#x27;,
    &#x27;sigma&#x27;, &#x27;tau&#x27;, &#x27;upsilon&#x27;, &#x27;omega1&#x27;, &#x27;omega&#x27;, &#x27;xi&#x27;, &#x27;psi&#x27;, &#x27;zeta&#x27;,
    &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;similar&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;Euro&#x27;, &#x27;Upsilon1&#x27;, &#x27;minute&#x27;, &#x27;lessequal&#x27;,
    &#x27;fraction&#x27;, &#x27;infinity&#x27;, &#x27;florin&#x27;, &#x27;club&#x27;, &#x27;diamond&#x27;, &#x27;heart&#x27;, &#x27;spade&#x27;,
    &#x27;arrowboth&#x27;, &#x27;arrowleft&#x27;, &#x27;arrowup&#x27;, &#x27;arrowright&#x27;, &#x27;arrowdown&#x27;, &#x27;degree&#x27;,
    &#x27;plusminus&#x27;, &#x27;second&#x27;, &#x27;greaterequal&#x27;, &#x27;multiply&#x27;, &#x27;proportional&#x27;,
    &#x27;partialdiff&#x27;, &#x27;bullet&#x27;, &#x27;divide&#x27;, &#x27;notequal&#x27;, &#x27;equivalence&#x27;,
    &#x27;approxequal&#x27;, &#x27;ellipsis&#x27;, &#x27;arrowvertex&#x27;, &#x27;arrowhorizex&#x27;, &#x27;carriagereturn&#x27;,
    &#x27;aleph&#x27;, &#x27;Ifraktur&#x27;, &#x27;Rfraktur&#x27;, &#x27;weierstrass&#x27;, &#x27;circlemultiply&#x27;,
    &#x27;circleplus&#x27;, &#x27;emptyset&#x27;, &#x27;intersection&#x27;, &#x27;union&#x27;, &#x27;propersuperset&#x27;,
    &#x27;reflexsuperset&#x27;, &#x27;notsubset&#x27;, &#x27;propersubset&#x27;, &#x27;reflexsubset&#x27;, &#x27;element&#x27;,
    &#x27;notelement&#x27;, &#x27;angle&#x27;, &#x27;gradient&#x27;, &#x27;registerserif&#x27;, &#x27;copyrightserif&#x27;,
    &#x27;trademarkserif&#x27;, &#x27;product&#x27;, &#x27;radical&#x27;, &#x27;dotmath&#x27;, &#x27;logicalnot&#x27;,
    &#x27;logicaland&#x27;, &#x27;logicalor&#x27;, &#x27;arrowdblboth&#x27;, &#x27;arrowdblleft&#x27;, &#x27;arrowdblup&#x27;,
    &#x27;arrowdblright&#x27;, &#x27;arrowdbldown&#x27;, &#x27;lozenge&#x27;, &#x27;angleleft&#x27;, &#x27;registersans&#x27;,
    &#x27;copyrightsans&#x27;, &#x27;trademarksans&#x27;, &#x27;summation&#x27;, &#x27;parenlefttp&#x27;,
    &#x27;parenleftex&#x27;, &#x27;parenleftbt&#x27;, &#x27;bracketlefttp&#x27;, &#x27;bracketleftex&#x27;,
    &#x27;bracketleftbt&#x27;, &#x27;bracelefttp&#x27;, &#x27;braceleftmid&#x27;, &#x27;braceleftbt&#x27;, &#x27;braceex&#x27;,
    &#x27;&#x27;, &#x27;angleright&#x27;, &#x27;integral&#x27;, &#x27;integraltp&#x27;, &#x27;integralex&#x27;, &#x27;integralbt&#x27;,
    &#x27;parenrighttp&#x27;, &#x27;parenrightex&#x27;, &#x27;parenrightbt&#x27;, &#x27;bracketrighttp&#x27;,
    &#x27;bracketrightex&#x27;, &#x27;bracketrightbt&#x27;, &#x27;bracerighttp&#x27;, &#x27;bracerightmid&#x27;,
    &#x27;bracerightbt&#x27;],
  zapfDingbatsEncoding: [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;space&#x27;, &#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a202&#x27;, &#x27;a3&#x27;, &#x27;a4&#x27;, &#x27;a5&#x27;, &#x27;a119&#x27;, &#x27;a118&#x27;, &#x27;a117&#x27;,
    &#x27;a11&#x27;, &#x27;a12&#x27;, &#x27;a13&#x27;, &#x27;a14&#x27;, &#x27;a15&#x27;, &#x27;a16&#x27;, &#x27;a105&#x27;, &#x27;a17&#x27;, &#x27;a18&#x27;, &#x27;a19&#x27;,
    &#x27;a20&#x27;, &#x27;a21&#x27;, &#x27;a22&#x27;, &#x27;a23&#x27;, &#x27;a24&#x27;, &#x27;a25&#x27;, &#x27;a26&#x27;, &#x27;a27&#x27;, &#x27;a28&#x27;, &#x27;a6&#x27;, &#x27;a7&#x27;,
    &#x27;a8&#x27;, &#x27;a9&#x27;, &#x27;a10&#x27;, &#x27;a29&#x27;, &#x27;a30&#x27;, &#x27;a31&#x27;, &#x27;a32&#x27;, &#x27;a33&#x27;, &#x27;a34&#x27;, &#x27;a35&#x27;, &#x27;a36&#x27;,
    &#x27;a37&#x27;, &#x27;a38&#x27;, &#x27;a39&#x27;, &#x27;a40&#x27;, &#x27;a41&#x27;, &#x27;a42&#x27;, &#x27;a43&#x27;, &#x27;a44&#x27;, &#x27;a45&#x27;, &#x27;a46&#x27;,
    &#x27;a47&#x27;, &#x27;a48&#x27;, &#x27;a49&#x27;, &#x27;a50&#x27;, &#x27;a51&#x27;, &#x27;a52&#x27;, &#x27;a53&#x27;, &#x27;a54&#x27;, &#x27;a55&#x27;, &#x27;a56&#x27;,
    &#x27;a57&#x27;, &#x27;a58&#x27;, &#x27;a59&#x27;, &#x27;a60&#x27;, &#x27;a61&#x27;, &#x27;a62&#x27;, &#x27;a63&#x27;, &#x27;a64&#x27;, &#x27;a65&#x27;, &#x27;a66&#x27;,
    &#x27;a67&#x27;, &#x27;a68&#x27;, &#x27;a69&#x27;, &#x27;a70&#x27;, &#x27;a71&#x27;, &#x27;a72&#x27;, &#x27;a73&#x27;, &#x27;a74&#x27;, &#x27;a203&#x27;, &#x27;a75&#x27;,
    &#x27;a204&#x27;, &#x27;a76&#x27;, &#x27;a77&#x27;, &#x27;a78&#x27;, &#x27;a79&#x27;, &#x27;a81&#x27;, &#x27;a82&#x27;, &#x27;a83&#x27;, &#x27;a84&#x27;, &#x27;a97&#x27;,
    &#x27;a98&#x27;, &#x27;a99&#x27;, &#x27;a100&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;,
    &#x27;&#x27;, &#x27;&#x27;, &#x27;a101&#x27;, &#x27;a102&#x27;, &#x27;a103&#x27;, &#x27;a104&#x27;, &#x27;a106&#x27;, &#x27;a107&#x27;, &#x27;a108&#x27;, &#x27;a112&#x27;,
    &#x27;a111&#x27;, &#x27;a110&#x27;, &#x27;a109&#x27;, &#x27;a120&#x27;, &#x27;a121&#x27;, &#x27;a122&#x27;, &#x27;a123&#x27;, &#x27;a124&#x27;, &#x27;a125&#x27;,
    &#x27;a126&#x27;, &#x27;a127&#x27;, &#x27;a128&#x27;, &#x27;a129&#x27;, &#x27;a130&#x27;, &#x27;a131&#x27;, &#x27;a132&#x27;, &#x27;a133&#x27;, &#x27;a134&#x27;,
    &#x27;a135&#x27;, &#x27;a136&#x27;, &#x27;a137&#x27;, &#x27;a138&#x27;, &#x27;a139&#x27;, &#x27;a140&#x27;, &#x27;a141&#x27;, &#x27;a142&#x27;, &#x27;a143&#x27;,
    &#x27;a144&#x27;, &#x27;a145&#x27;, &#x27;a146&#x27;, &#x27;a147&#x27;, &#x27;a148&#x27;, &#x27;a149&#x27;, &#x27;a150&#x27;, &#x27;a151&#x27;, &#x27;a152&#x27;,
    &#x27;a153&#x27;, &#x27;a154&#x27;, &#x27;a155&#x27;, &#x27;a156&#x27;, &#x27;a157&#x27;, &#x27;a158&#x27;, &#x27;a159&#x27;, &#x27;a160&#x27;, &#x27;a161&#x27;,
    &#x27;a163&#x27;, &#x27;a164&#x27;, &#x27;a196&#x27;, &#x27;a165&#x27;, &#x27;a192&#x27;, &#x27;a166&#x27;, &#x27;a167&#x27;, &#x27;a168&#x27;, &#x27;a169&#x27;,
    &#x27;a170&#x27;, &#x27;a171&#x27;, &#x27;a172&#x27;, &#x27;a173&#x27;, &#x27;a162&#x27;, &#x27;a174&#x27;, &#x27;a175&#x27;, &#x27;a176&#x27;, &#x27;a177&#x27;,
    &#x27;a178&#x27;, &#x27;a179&#x27;, &#x27;a193&#x27;, &#x27;a180&#x27;, &#x27;a199&#x27;, &#x27;a181&#x27;, &#x27;a200&#x27;, &#x27;a182&#x27;, &#x27;&#x27;, &#x27;a201&#x27;,
    &#x27;a183&#x27;, &#x27;a184&#x27;, &#x27;a197&#x27;, &#x27;a185&#x27;, &#x27;a194&#x27;, &#x27;a198&#x27;, &#x27;a186&#x27;, &#x27;a195&#x27;, &#x27;a187&#x27;,
    &#x27;a188&#x27;, &#x27;a189&#x27;, &#x27;a190&#x27;, &#x27;a191&#x27;]
};

/**
 * Hold a map of decoded fonts and of the standard fourteen Type1
 * fonts and their acronyms.
 */
var stdFontMap = {
  &#x27;ArialNarrow&#x27;: &#x27;Helvetica&#x27;,
  &#x27;ArialNarrow-Bold&#x27;: &#x27;Helvetica-Bold&#x27;,
  &#x27;ArialNarrow-BoldItalic&#x27;: &#x27;Helvetica-BoldOblique&#x27;,
  &#x27;ArialNarrow-Italic&#x27;: &#x27;Helvetica-Oblique&#x27;,
  &#x27;ArialBlack&#x27;: &#x27;Helvetica&#x27;,
  &#x27;ArialBlack-Bold&#x27;: &#x27;Helvetica-Bold&#x27;,
  &#x27;ArialBlack-BoldItalic&#x27;: &#x27;Helvetica-BoldOblique&#x27;,
  &#x27;ArialBlack-Italic&#x27;: &#x27;Helvetica-Oblique&#x27;,
  &#x27;Arial&#x27;: &#x27;Helvetica&#x27;,
  &#x27;Arial-Bold&#x27;: &#x27;Helvetica-Bold&#x27;,
  &#x27;Arial-BoldItalic&#x27;: &#x27;Helvetica-BoldOblique&#x27;,
  &#x27;Arial-Italic&#x27;: &#x27;Helvetica-Oblique&#x27;,
  &#x27;Arial-BoldItalicMT&#x27;: &#x27;Helvetica-BoldOblique&#x27;,
  &#x27;Arial-BoldMT&#x27;: &#x27;Helvetica-Bold&#x27;,
  &#x27;Arial-ItalicMT&#x27;: &#x27;Helvetica-Oblique&#x27;,
  &#x27;ArialMT&#x27;: &#x27;Helvetica&#x27;,
  &#x27;Courier-Bold&#x27;: &#x27;Courier-Bold&#x27;,
  &#x27;Courier-BoldItalic&#x27;: &#x27;Courier-BoldOblique&#x27;,
  &#x27;Courier-Italic&#x27;: &#x27;Courier-Oblique&#x27;,
  &#x27;CourierNew&#x27;: &#x27;Courier&#x27;,
  &#x27;CourierNew-Bold&#x27;: &#x27;Courier-Bold&#x27;,
  &#x27;CourierNew-BoldItalic&#x27;: &#x27;Courier-BoldOblique&#x27;,
  &#x27;CourierNew-Italic&#x27;: &#x27;Courier-Oblique&#x27;,
  &#x27;CourierNewPS-BoldItalicMT&#x27;: &#x27;Courier-BoldOblique&#x27;,
  &#x27;CourierNewPS-BoldMT&#x27;: &#x27;Courier-Bold&#x27;,
  &#x27;CourierNewPS-ItalicMT&#x27;: &#x27;Courier-Oblique&#x27;,
  &#x27;CourierNewPSMT&#x27;: &#x27;Courier&#x27;,
  &#x27;Helvetica-Bold&#x27;: &#x27;Helvetica-Bold&#x27;,
  &#x27;Helvetica-BoldItalic&#x27;: &#x27;Helvetica-BoldOblique&#x27;,
  &#x27;Helvetica-Italic&#x27;: &#x27;Helvetica-Oblique&#x27;,
  &#x27;Symbol-Bold&#x27;: &#x27;Symbol&#x27;,
  &#x27;Symbol-BoldItalic&#x27;: &#x27;Symbol&#x27;,
  &#x27;Symbol-Italic&#x27;: &#x27;Symbol&#x27;,
  &#x27;TimesNewRoman&#x27;: &#x27;Times-Roman&#x27;,
  &#x27;TimesNewRoman-Bold&#x27;: &#x27;Times-Bold&#x27;,
  &#x27;TimesNewRoman-BoldItalic&#x27;: &#x27;Times-BoldItalic&#x27;,
  &#x27;TimesNewRoman-Italic&#x27;: &#x27;Times-Italic&#x27;,
  &#x27;TimesNewRomanPS&#x27;: &#x27;Times-Roman&#x27;,
  &#x27;TimesNewRomanPS-Bold&#x27;: &#x27;Times-Bold&#x27;,
  &#x27;TimesNewRomanPS-BoldItalic&#x27;: &#x27;Times-BoldItalic&#x27;,
  &#x27;TimesNewRomanPS-BoldItalicMT&#x27;: &#x27;Times-BoldItalic&#x27;,
  &#x27;TimesNewRomanPS-BoldMT&#x27;: &#x27;Times-Bold&#x27;,
  &#x27;TimesNewRomanPS-Italic&#x27;: &#x27;Times-Italic&#x27;,
  &#x27;TimesNewRomanPS-ItalicMT&#x27;: &#x27;Times-Italic&#x27;,
  &#x27;TimesNewRomanPSMT&#x27;: &#x27;Times-Roman&#x27;,
  &#x27;TimesNewRomanPSMT-Bold&#x27;: &#x27;Times-Bold&#x27;,
  &#x27;TimesNewRomanPSMT-BoldItalic&#x27;: &#x27;Times-BoldItalic&#x27;,
  &#x27;TimesNewRomanPSMT-Italic&#x27;: &#x27;Times-Italic&#x27;
};

/**
 * Holds the map of the non-standard fonts that might be included as a standard
 * fonts without glyph data.
 */
var nonStdFontMap = {
  &#x27;ComicSansMS&#x27;: &#x27;Comic Sans MS&#x27;,
  &#x27;ComicSansMS-Bold&#x27;: &#x27;Comic Sans MS-Bold&#x27;,
  &#x27;ComicSansMS-BoldItalic&#x27;: &#x27;Comic Sans MS-BoldItalic&#x27;,
  &#x27;ComicSansMS-Italic&#x27;: &#x27;Comic Sans MS-Italic&#x27;,
  &#x27;LucidaConsole&#x27;: &#x27;Courier&#x27;,
  &#x27;LucidaConsole-Bold&#x27;: &#x27;Courier-Bold&#x27;,
  &#x27;LucidaConsole-BoldItalic&#x27;: &#x27;Courier-BoldOblique&#x27;,
  &#x27;LucidaConsole-Italic&#x27;: &#x27;Courier-Oblique&#x27;,
  &#x27;MS-Gothic&#x27;: &#x27;MS Gothic&#x27;,
  &#x27;MS-Gothic-Bold&#x27;: &#x27;MS Gothic-Bold&#x27;,
  &#x27;MS-Gothic-BoldItalic&#x27;: &#x27;MS Gothic-BoldItalic&#x27;,
  &#x27;MS-Gothic-Italic&#x27;: &#x27;MS Gothic-Italic&#x27;,
  &#x27;MS-Mincho&#x27;: &#x27;MS Mincho&#x27;,
  &#x27;MS-Mincho-Bold&#x27;: &#x27;MS Mincho-Bold&#x27;,
  &#x27;MS-Mincho-BoldItalic&#x27;: &#x27;MS Mincho-BoldItalic&#x27;,
  &#x27;MS-Mincho-Italic&#x27;: &#x27;MS Mincho-Italic&#x27;,
  &#x27;MS-PGothic&#x27;: &#x27;MS PGothic&#x27;,
  &#x27;MS-PGothic-Bold&#x27;: &#x27;MS PGothic-Bold&#x27;,
  &#x27;MS-PGothic-BoldItalic&#x27;: &#x27;MS PGothic-BoldItalic&#x27;,
  &#x27;MS-PGothic-Italic&#x27;: &#x27;MS PGothic-Italic&#x27;,
  &#x27;MS-PMincho&#x27;: &#x27;MS PMincho&#x27;,
  &#x27;MS-PMincho-Bold&#x27;: &#x27;MS PMincho-Bold&#x27;,
  &#x27;MS-PMincho-BoldItalic&#x27;: &#x27;MS PMincho-BoldItalic&#x27;,
  &#x27;MS-PMincho-Italic&#x27;: &#x27;MS PMincho-Italic&#x27;,
};

var serifFonts = {
  &#x27;Adobe Jenson&#x27;: true, &#x27;Adobe Text&#x27;: true, &#x27;Albertus&#x27;: true,
  &#x27;Aldus&#x27;: true, &#x27;Alexandria&#x27;: true, &#x27;Algerian&#x27;: true,
  &#x27;American Typewriter&#x27;: true, &#x27;Antiqua&#x27;: true, &#x27;Apex&#x27;: true,
  &#x27;Arno&#x27;: true, &#x27;Aster&#x27;: true, &#x27;Aurora&#x27;: true,
  &#x27;Baskerville&#x27;: true, &#x27;Bell&#x27;: true, &#x27;Bembo&#x27;: true,
  &#x27;Bembo Schoolbook&#x27;: true, &#x27;Benguiat&#x27;: true, &#x27;Berkeley Old Style&#x27;: true,
  &#x27;Bernhard Modern&#x27;: true, &#x27;Berthold City&#x27;: true, &#x27;Bodoni&#x27;: true,
  &#x27;Bauer Bodoni&#x27;: true, &#x27;Book Antiqua&#x27;: true, &#x27;Bookman&#x27;: true,
  &#x27;Bordeaux Roman&#x27;: true, &#x27;Californian FB&#x27;: true, &#x27;Calisto&#x27;: true,
  &#x27;Calvert&#x27;: true, &#x27;Capitals&#x27;: true, &#x27;Cambria&#x27;: true,
  &#x27;Cartier&#x27;: true, &#x27;Caslon&#x27;: true, &#x27;Catull&#x27;: true,
  &#x27;Centaur&#x27;: true, &#x27;Century Old Style&#x27;: true, &#x27;Century Schoolbook&#x27;: true,
  &#x27;Chaparral&#x27;: true, &#x27;Charis SIL&#x27;: true, &#x27;Cheltenham&#x27;: true,
  &#x27;Cholla Slab&#x27;: true, &#x27;Clarendon&#x27;: true, &#x27;Clearface&#x27;: true,
  &#x27;Cochin&#x27;: true, &#x27;Colonna&#x27;: true, &#x27;Computer Modern&#x27;: true,
  &#x27;Concrete Roman&#x27;: true, &#x27;Constantia&#x27;: true, &#x27;Cooper Black&#x27;: true,
  &#x27;Corona&#x27;: true, &#x27;Ecotype&#x27;: true, &#x27;Egyptienne&#x27;: true,
  &#x27;Elephant&#x27;: true, &#x27;Excelsior&#x27;: true, &#x27;Fairfield&#x27;: true,
  &#x27;FF Scala&#x27;: true, &#x27;Folkard&#x27;: true, &#x27;Footlight&#x27;: true,
  &#x27;FreeSerif&#x27;: true, &#x27;Friz Quadrata&#x27;: true, &#x27;Garamond&#x27;: true,
  &#x27;Gentium&#x27;: true, &#x27;Georgia&#x27;: true, &#x27;Gloucester&#x27;: true,
  &#x27;Goudy Old Style&#x27;: true, &#x27;Goudy Schoolbook&#x27;: true, &#x27;Goudy Pro Font&#x27;: true,
  &#x27;Granjon&#x27;: true, &#x27;Guardian Egyptian&#x27;: true, &#x27;Heather&#x27;: true,
  &#x27;Hercules&#x27;: true, &#x27;High Tower Text&#x27;: true, &#x27;Hiroshige&#x27;: true,
  &#x27;Hoefler Text&#x27;: true, &#x27;Humana Serif&#x27;: true, &#x27;Imprint&#x27;: true,
  &#x27;Ionic No. 5&#x27;: true, &#x27;Janson&#x27;: true, &#x27;Joanna&#x27;: true,
  &#x27;Korinna&#x27;: true, &#x27;Lexicon&#x27;: true, &#x27;Liberation Serif&#x27;: true,
  &#x27;Linux Libertine&#x27;: true, &#x27;Literaturnaya&#x27;: true, &#x27;Lucida&#x27;: true,
  &#x27;Lucida Bright&#x27;: true, &#x27;Melior&#x27;: true, &#x27;Memphis&#x27;: true,
  &#x27;Miller&#x27;: true, &#x27;Minion&#x27;: true, &#x27;Modern&#x27;: true,
  &#x27;Mona Lisa&#x27;: true, &#x27;Mrs Eaves&#x27;: true, &#x27;MS Serif&#x27;: true,
  &#x27;Museo Slab&#x27;: true, &#x27;New York&#x27;: true, &#x27;Nimbus Roman&#x27;: true,
  &#x27;NPS Rawlinson Roadway&#x27;: true, &#x27;Palatino&#x27;: true, &#x27;Perpetua&#x27;: true,
  &#x27;Plantin&#x27;: true, &#x27;Plantin Schoolbook&#x27;: true, &#x27;Playbill&#x27;: true,
  &#x27;Poor Richard&#x27;: true, &#x27;Rawlinson Roadway&#x27;: true, &#x27;Renault&#x27;: true,
  &#x27;Requiem&#x27;: true, &#x27;Rockwell&#x27;: true, &#x27;Roman&#x27;: true,
  &#x27;Rotis Serif&#x27;: true, &#x27;Sabon&#x27;: true, &#x27;Scala&#x27;: true,
  &#x27;Seagull&#x27;: true, &#x27;Sistina&#x27;: true, &#x27;Souvenir&#x27;: true,
  &#x27;STIX&#x27;: true, &#x27;Stone Informal&#x27;: true, &#x27;Stone Serif&#x27;: true,
  &#x27;Sylfaen&#x27;: true, &#x27;Times&#x27;: true, &#x27;Trajan&#x27;: true,
  &#x27;Trinité&#x27;: true, &#x27;Trump Mediaeval&#x27;: true, &#x27;Utopia&#x27;: true,
  &#x27;Vale Type&#x27;: true, &#x27;Bitstream Vera&#x27;: true, &#x27;Vera Serif&#x27;: true,
  &#x27;Versailles&#x27;: true, &#x27;Wanted&#x27;: true, &#x27;Weiss&#x27;: true,
  &#x27;Wide Latin&#x27;: true, &#x27;Windsor&#x27;: true, &#x27;XITS&#x27;: true
};

var symbolsFonts = {
  &#x27;Dingbats&#x27;: true, &#x27;Symbol&#x27;: true, &#x27;ZapfDingbats&#x27;: true
};

var CMapConverterList = {
  &#x27;H&#x27;: jis7ToUnicode,
  &#x27;V&#x27;: jis7ToUnicode,
  &#x27;EUC-H&#x27;: eucjpToUnicode,
  &#x27;EUC-V&#x27;: eucjpToUnicode,
  &#x27;83pv-RKSJ-H&#x27;: sjis83pvToUnicode,
  &#x27;90pv-RKSJ-H&#x27;: sjis90pvToUnicode,
  &#x27;90ms-RKSJ-H&#x27;: sjisToUnicode,
  &#x27;90ms-RKSJ-V&#x27;: sjisToUnicode,
  &#x27;90msp-RKSJ-H&#x27;: sjisToUnicode,
  &#x27;90msp-RKSJ-V&#x27;: sjisToUnicode,
  &#x27;GBK-EUC-H&#x27;: gbkToUnicode,
  &#x27;GBKp-EUC-H&#x27;: gbkToUnicode,
  &#x27;B5pc-H&#x27;: big5ToUnicode,
  &#x27;ETenms-B5-H&#x27;: big5ToUnicode,
  &#x27;ETenms-B5-V&#x27;: big5ToUnicode,
};

// CMaps using Hankaku (Halfwidth) Latin glyphs instead of proportional one.
// We need to distinguish them to get correct widths from CIDFont dicts.
var HalfwidthCMaps = {
  &#x27;H&#x27;: true,
  &#x27;V&#x27;: true,
  &#x27;EUC-H&#x27;: true,
  &#x27;EUC-V&#x27;: true,
  &#x27;90ms-RKSJ-H&#x27;: true,
  &#x27;90ms-RKSJ-V&#x27;: true,
  &#x27;UniJIS-UCS2-HW-H&#x27;: true,
  &#x27;UniJIS-UCS2-HW-V&#x27;: true
};

var decodeBytes;
if (typeof TextDecoder !== &#x27;undefined&#x27;) {
  // The encodings supported by TextDecoder can be found at:
  // http://encoding.spec.whatwg.org/#concept-encoding-get
  decodeBytes = function(bytes, encoding, fatal) {
    return new TextDecoder(encoding, {fatal: !!fatal}).decode(bytes);
  };
} else if (typeof FileReaderSync !== &#x27;undefined&#x27;) {
  decodeBytes = function(bytes, encoding) {
    return new FileReaderSync().readAsText(new Blob([bytes]), encoding);
  };
} else {
  // Clear the list so that decodeBytes will never be called.
  CMapConverterList = {};
}

function jis7ToUnicode(str) {
  var bytes = stringToBytes(str);
  var length = bytes.length;
  for (var i = 0; i &lt; length; ++i) {
    bytes[i] |= 0x80;
  }
  return decodeBytes(bytes, &#x27;euc-jp&#x27;);
}

function eucjpToUnicode(str) {
  return decodeBytes(stringToBytes(str), &#x27;euc-jp&#x27;);
}

function sjisToUnicode(str) {
  return decodeBytes(stringToBytes(str), &#x27;shift_jis&#x27;);
}

function sjis83pvToUnicode(str) {
  var bytes = stringToBytes(str);
  try {
    // TODO: 83pv has incompatible mappings in ed40..ee9c range.
    return decodeBytes(bytes, &#x27;shift_jis&#x27;, true);
  } catch (e) {
    TODO(&#x27;Unsupported 83pv character found&#x27;);
    // Just retry without checking errors for now.
    return decodeBytes(bytes, &#x27;shift_jis&#x27;);
  }
}

function sjis90pvToUnicode(str) {
  var bytes = stringToBytes(str);
  try {
    // TODO: 90pv has incompatible mappings in 8740..879c and eb41..ee9c.
    return decodeBytes(bytes, &#x27;shift_jis&#x27;, true);
  } catch (e) {
    TODO(&#x27;Unsupported 90pv character found&#x27;);
    // Just retry without checking errors for now.
    return decodeBytes(bytes, &#x27;shift_jis&#x27;);
  }
}

function gbkToUnicode(str) {
  return decodeBytes(stringToBytes(str), &#x27;gbk&#x27;);
}

function big5ToUnicode(str) {
  return decodeBytes(stringToBytes(str), &#x27;big5&#x27;);
}

// Some characters, e.g. copyrightserif, mapped to the private use area and
// might not be displayed using standard fonts. Mapping/hacking well-known chars
// to the similar equivalents in the normal characters range.
function mapPrivateUseChars(code) {
  switch (code) {
    case 0xF8E9: // copyrightsans
    case 0xF6D9: // copyrightserif
      return 0x00A9; // copyright
    default:
      return code;
  }
}

var UnicodeRanges = [
  { &#x27;begin&#x27;: 0x0000, &#x27;end&#x27;: 0x007F }, // Basic Latin
  { &#x27;begin&#x27;: 0x0080, &#x27;end&#x27;: 0x00FF }, // Latin-1 Supplement
  { &#x27;begin&#x27;: 0x0100, &#x27;end&#x27;: 0x017F }, // Latin Extended-A
  { &#x27;begin&#x27;: 0x0180, &#x27;end&#x27;: 0x024F }, // Latin Extended-B
  { &#x27;begin&#x27;: 0x0250, &#x27;end&#x27;: 0x02AF }, // IPA Extensions
  { &#x27;begin&#x27;: 0x02B0, &#x27;end&#x27;: 0x02FF }, // Spacing Modifier Letters
  { &#x27;begin&#x27;: 0x0300, &#x27;end&#x27;: 0x036F }, // Combining Diacritical Marks
  { &#x27;begin&#x27;: 0x0370, &#x27;end&#x27;: 0x03FF }, // Greek and Coptic
  { &#x27;begin&#x27;: 0x2C80, &#x27;end&#x27;: 0x2CFF }, // Coptic
  { &#x27;begin&#x27;: 0x0400, &#x27;end&#x27;: 0x04FF }, // Cyrillic
  { &#x27;begin&#x27;: 0x0530, &#x27;end&#x27;: 0x058F }, // Armenian
  { &#x27;begin&#x27;: 0x0590, &#x27;end&#x27;: 0x05FF }, // Hebrew
  { &#x27;begin&#x27;: 0xA500, &#x27;end&#x27;: 0xA63F }, // Vai
  { &#x27;begin&#x27;: 0x0600, &#x27;end&#x27;: 0x06FF }, // Arabic
  { &#x27;begin&#x27;: 0x07C0, &#x27;end&#x27;: 0x07FF }, // NKo
  { &#x27;begin&#x27;: 0x0900, &#x27;end&#x27;: 0x097F }, // Devanagari
  { &#x27;begin&#x27;: 0x0980, &#x27;end&#x27;: 0x09FF }, // Bengali
  { &#x27;begin&#x27;: 0x0A00, &#x27;end&#x27;: 0x0A7F }, // Gurmukhi
  { &#x27;begin&#x27;: 0x0A80, &#x27;end&#x27;: 0x0AFF }, // Gujarati
  { &#x27;begin&#x27;: 0x0B00, &#x27;end&#x27;: 0x0B7F }, // Oriya
  { &#x27;begin&#x27;: 0x0B80, &#x27;end&#x27;: 0x0BFF }, // Tamil
  { &#x27;begin&#x27;: 0x0C00, &#x27;end&#x27;: 0x0C7F }, // Telugu
  { &#x27;begin&#x27;: 0x0C80, &#x27;end&#x27;: 0x0CFF }, // Kannada
  { &#x27;begin&#x27;: 0x0D00, &#x27;end&#x27;: 0x0D7F }, // Malayalam
  { &#x27;begin&#x27;: 0x0E00, &#x27;end&#x27;: 0x0E7F }, // Thai
  { &#x27;begin&#x27;: 0x0E80, &#x27;end&#x27;: 0x0EFF }, // Lao
  { &#x27;begin&#x27;: 0x10A0, &#x27;end&#x27;: 0x10FF }, // Georgian
  { &#x27;begin&#x27;: 0x1B00, &#x27;end&#x27;: 0x1B7F }, // Balinese
  { &#x27;begin&#x27;: 0x1100, &#x27;end&#x27;: 0x11FF }, // Hangul Jamo
  { &#x27;begin&#x27;: 0x1E00, &#x27;end&#x27;: 0x1EFF }, // Latin Extended Additional
  { &#x27;begin&#x27;: 0x1F00, &#x27;end&#x27;: 0x1FFF }, // Greek Extended
  { &#x27;begin&#x27;: 0x2000, &#x27;end&#x27;: 0x206F }, // General Punctuation
  { &#x27;begin&#x27;: 0x2070, &#x27;end&#x27;: 0x209F }, // Superscripts And Subscripts
  { &#x27;begin&#x27;: 0x20A0, &#x27;end&#x27;: 0x20CF }, // Currency Symbol
  { &#x27;begin&#x27;: 0x20D0, &#x27;end&#x27;: 0x20FF }, // Combining Diacritical Marks For Symbols
  { &#x27;begin&#x27;: 0x2100, &#x27;end&#x27;: 0x214F }, // Letterlike Symbols
  { &#x27;begin&#x27;: 0x2150, &#x27;end&#x27;: 0x218F }, // Number Forms
  { &#x27;begin&#x27;: 0x2190, &#x27;end&#x27;: 0x21FF }, // Arrows
  { &#x27;begin&#x27;: 0x2200, &#x27;end&#x27;: 0x22FF }, // Mathematical Operators
  { &#x27;begin&#x27;: 0x2300, &#x27;end&#x27;: 0x23FF }, // Miscellaneous Technical
  { &#x27;begin&#x27;: 0x2400, &#x27;end&#x27;: 0x243F }, // Control Pictures
  { &#x27;begin&#x27;: 0x2440, &#x27;end&#x27;: 0x245F }, // Optical Character Recognition
  { &#x27;begin&#x27;: 0x2460, &#x27;end&#x27;: 0x24FF }, // Enclosed Alphanumerics
  { &#x27;begin&#x27;: 0x2500, &#x27;end&#x27;: 0x257F }, // Box Drawing
  { &#x27;begin&#x27;: 0x2580, &#x27;end&#x27;: 0x259F }, // Block Elements
  { &#x27;begin&#x27;: 0x25A0, &#x27;end&#x27;: 0x25FF }, // Geometric Shapes
  { &#x27;begin&#x27;: 0x2600, &#x27;end&#x27;: 0x26FF }, // Miscellaneous Symbols
  { &#x27;begin&#x27;: 0x2700, &#x27;end&#x27;: 0x27BF }, // Dingbats
  { &#x27;begin&#x27;: 0x3000, &#x27;end&#x27;: 0x303F }, // CJK Symbols And Punctuation
  { &#x27;begin&#x27;: 0x3040, &#x27;end&#x27;: 0x309F }, // Hiragana
  { &#x27;begin&#x27;: 0x30A0, &#x27;end&#x27;: 0x30FF }, // Katakana
  { &#x27;begin&#x27;: 0x3100, &#x27;end&#x27;: 0x312F }, // Bopomofo
  { &#x27;begin&#x27;: 0x3130, &#x27;end&#x27;: 0x318F }, // Hangul Compatibility Jamo
  { &#x27;begin&#x27;: 0xA840, &#x27;end&#x27;: 0xA87F }, // Phags-pa
  { &#x27;begin&#x27;: 0x3200, &#x27;end&#x27;: 0x32FF }, // Enclosed CJK Letters And Months
  { &#x27;begin&#x27;: 0x3300, &#x27;end&#x27;: 0x33FF }, // CJK Compatibility
  { &#x27;begin&#x27;: 0xAC00, &#x27;end&#x27;: 0xD7AF }, // Hangul Syllables
  { &#x27;begin&#x27;: 0xD800, &#x27;end&#x27;: 0xDFFF }, // Non-Plane 0 *
  { &#x27;begin&#x27;: 0x10900, &#x27;end&#x27;: 0x1091F }, // Phoenicia
  { &#x27;begin&#x27;: 0x4E00, &#x27;end&#x27;: 0x9FFF }, // CJK Unified Ideographs
  { &#x27;begin&#x27;: 0xE000, &#x27;end&#x27;: 0xF8FF }, // Private Use Area (plane 0)
  { &#x27;begin&#x27;: 0x31C0, &#x27;end&#x27;: 0x31EF }, // CJK Strokes
  { &#x27;begin&#x27;: 0xFB00, &#x27;end&#x27;: 0xFB4F }, // Alphabetic Presentation Forms
  { &#x27;begin&#x27;: 0xFB50, &#x27;end&#x27;: 0xFDFF }, // Arabic Presentation Forms-A
  { &#x27;begin&#x27;: 0xFE20, &#x27;end&#x27;: 0xFE2F }, // Combining Half Marks
  { &#x27;begin&#x27;: 0xFE10, &#x27;end&#x27;: 0xFE1F }, // Vertical Forms
  { &#x27;begin&#x27;: 0xFE50, &#x27;end&#x27;: 0xFE6F }, // Small Form Variants
  { &#x27;begin&#x27;: 0xFE70, &#x27;end&#x27;: 0xFEFF }, // Arabic Presentation Forms-B
  { &#x27;begin&#x27;: 0xFF00, &#x27;end&#x27;: 0xFFEF }, // Halfwidth And Fullwidth Forms
  { &#x27;begin&#x27;: 0xFFF0, &#x27;end&#x27;: 0xFFFF }, // Specials
  { &#x27;begin&#x27;: 0x0F00, &#x27;end&#x27;: 0x0FFF }, // Tibetan
  { &#x27;begin&#x27;: 0x0700, &#x27;end&#x27;: 0x074F }, // Syriac
  { &#x27;begin&#x27;: 0x0780, &#x27;end&#x27;: 0x07BF }, // Thaana
  { &#x27;begin&#x27;: 0x0D80, &#x27;end&#x27;: 0x0DFF }, // Sinhala
  { &#x27;begin&#x27;: 0x1000, &#x27;end&#x27;: 0x109F }, // Myanmar
  { &#x27;begin&#x27;: 0x1200, &#x27;end&#x27;: 0x137F }, // Ethiopic
  { &#x27;begin&#x27;: 0x13A0, &#x27;end&#x27;: 0x13FF }, // Cherokee
  { &#x27;begin&#x27;: 0x1400, &#x27;end&#x27;: 0x167F }, // Unified Canadian Aboriginal Syllabics
  { &#x27;begin&#x27;: 0x1680, &#x27;end&#x27;: 0x169F }, // Ogham
  { &#x27;begin&#x27;: 0x16A0, &#x27;end&#x27;: 0x16FF }, // Runic
  { &#x27;begin&#x27;: 0x1780, &#x27;end&#x27;: 0x17FF }, // Khmer
  { &#x27;begin&#x27;: 0x1800, &#x27;end&#x27;: 0x18AF }, // Mongolian
  { &#x27;begin&#x27;: 0x2800, &#x27;end&#x27;: 0x28FF }, // Braille Patterns
  { &#x27;begin&#x27;: 0xA000, &#x27;end&#x27;: 0xA48F }, // Yi Syllables
  { &#x27;begin&#x27;: 0x1700, &#x27;end&#x27;: 0x171F }, // Tagalog
  { &#x27;begin&#x27;: 0x10300, &#x27;end&#x27;: 0x1032F }, // Old Italic
  { &#x27;begin&#x27;: 0x10330, &#x27;end&#x27;: 0x1034F }, // Gothic
  { &#x27;begin&#x27;: 0x10400, &#x27;end&#x27;: 0x1044F }, // Deseret
  { &#x27;begin&#x27;: 0x1D000, &#x27;end&#x27;: 0x1D0FF }, // Byzantine Musical Symbols
  { &#x27;begin&#x27;: 0x1D400, &#x27;end&#x27;: 0x1D7FF }, // Mathematical Alphanumeric Symbols
  { &#x27;begin&#x27;: 0xFF000, &#x27;end&#x27;: 0xFFFFD }, // Private Use (plane 15)
  { &#x27;begin&#x27;: 0xFE00, &#x27;end&#x27;: 0xFE0F }, // Variation Selectors
  { &#x27;begin&#x27;: 0xE0000, &#x27;end&#x27;: 0xE007F }, // Tags
  { &#x27;begin&#x27;: 0x1900, &#x27;end&#x27;: 0x194F }, // Limbu
  { &#x27;begin&#x27;: 0x1950, &#x27;end&#x27;: 0x197F }, // Tai Le
  { &#x27;begin&#x27;: 0x1980, &#x27;end&#x27;: 0x19DF }, // New Tai Lue
  { &#x27;begin&#x27;: 0x1A00, &#x27;end&#x27;: 0x1A1F }, // Buginese
  { &#x27;begin&#x27;: 0x2C00, &#x27;end&#x27;: 0x2C5F }, // Glagolitic
  { &#x27;begin&#x27;: 0x2D30, &#x27;end&#x27;: 0x2D7F }, // Tifinagh
  { &#x27;begin&#x27;: 0x4DC0, &#x27;end&#x27;: 0x4DFF }, // Yijing Hexagram Symbols
  { &#x27;begin&#x27;: 0xA800, &#x27;end&#x27;: 0xA82F }, // Syloti Nagri
  { &#x27;begin&#x27;: 0x10000, &#x27;end&#x27;: 0x1007F }, // Linear B Syllabary
  { &#x27;begin&#x27;: 0x10140, &#x27;end&#x27;: 0x1018F }, // Ancient Greek Numbers
  { &#x27;begin&#x27;: 0x10380, &#x27;end&#x27;: 0x1039F }, // Ugaritic
  { &#x27;begin&#x27;: 0x103A0, &#x27;end&#x27;: 0x103DF }, // Old Persian
  { &#x27;begin&#x27;: 0x10450, &#x27;end&#x27;: 0x1047F }, // Shavian
  { &#x27;begin&#x27;: 0x10480, &#x27;end&#x27;: 0x104AF }, // Osmanya
  { &#x27;begin&#x27;: 0x10800, &#x27;end&#x27;: 0x1083F }, // Cypriot Syllabary
  { &#x27;begin&#x27;: 0x10A00, &#x27;end&#x27;: 0x10A5F }, // Kharoshthi
  { &#x27;begin&#x27;: 0x1D300, &#x27;end&#x27;: 0x1D35F }, // Tai Xuan Jing Symbols
  { &#x27;begin&#x27;: 0x12000, &#x27;end&#x27;: 0x123FF }, // Cuneiform
  { &#x27;begin&#x27;: 0x1D360, &#x27;end&#x27;: 0x1D37F }, // Counting Rod Numerals
  { &#x27;begin&#x27;: 0x1B80, &#x27;end&#x27;: 0x1BBF }, // Sundanese
  { &#x27;begin&#x27;: 0x1C00, &#x27;end&#x27;: 0x1C4F }, // Lepcha
  { &#x27;begin&#x27;: 0x1C50, &#x27;end&#x27;: 0x1C7F }, // Ol Chiki
  { &#x27;begin&#x27;: 0xA880, &#x27;end&#x27;: 0xA8DF }, // Saurashtra
  { &#x27;begin&#x27;: 0xA900, &#x27;end&#x27;: 0xA92F }, // Kayah Li
  { &#x27;begin&#x27;: 0xA930, &#x27;end&#x27;: 0xA95F }, // Rejang
  { &#x27;begin&#x27;: 0xAA00, &#x27;end&#x27;: 0xAA5F }, // Cham
  { &#x27;begin&#x27;: 0x10190, &#x27;end&#x27;: 0x101CF }, // Ancient Symbols
  { &#x27;begin&#x27;: 0x101D0, &#x27;end&#x27;: 0x101FF }, // Phaistos Disc
  { &#x27;begin&#x27;: 0x102A0, &#x27;end&#x27;: 0x102DF }, // Carian
  { &#x27;begin&#x27;: 0x1F030, &#x27;end&#x27;: 0x1F09F }  // Domino Tiles
];

var MacStandardGlyphOrdering = [
  &#x27;.notdef&#x27;, &#x27;.null&#x27;, &#x27;nonmarkingreturn&#x27;, &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;,
  &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;, &#x27;ampersand&#x27;, &#x27;quotesingle&#x27;, &#x27;parenleft&#x27;,
  &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;, &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;,
  &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;,
  &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;, &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;,
  &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;,
  &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;,
  &#x27;backslash&#x27;, &#x27;bracketright&#x27;, &#x27;asciicircum&#x27;, &#x27;underscore&#x27;, &#x27;grave&#x27;, &#x27;a&#x27;, &#x27;b&#x27;,
  &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;,
  &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;,
  &#x27;asciitilde&#x27;, &#x27;Adieresis&#x27;, &#x27;Aring&#x27;, &#x27;Ccedilla&#x27;, &#x27;Eacute&#x27;, &#x27;Ntilde&#x27;,
  &#x27;Odieresis&#x27;, &#x27;Udieresis&#x27;, &#x27;aacute&#x27;, &#x27;agrave&#x27;, &#x27;acircumflex&#x27;, &#x27;adieresis&#x27;,
  &#x27;atilde&#x27;, &#x27;aring&#x27;, &#x27;ccedilla&#x27;, &#x27;eacute&#x27;, &#x27;egrave&#x27;, &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;,
  &#x27;iacute&#x27;, &#x27;igrave&#x27;, &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;ntilde&#x27;, &#x27;oacute&#x27;, &#x27;ograve&#x27;,
  &#x27;ocircumflex&#x27;, &#x27;odieresis&#x27;, &#x27;otilde&#x27;, &#x27;uacute&#x27;, &#x27;ugrave&#x27;, &#x27;ucircumflex&#x27;,
  &#x27;udieresis&#x27;, &#x27;dagger&#x27;, &#x27;degree&#x27;, &#x27;cent&#x27;, &#x27;sterling&#x27;, &#x27;section&#x27;, &#x27;bullet&#x27;,
  &#x27;paragraph&#x27;, &#x27;germandbls&#x27;, &#x27;registered&#x27;, &#x27;copyright&#x27;, &#x27;trademark&#x27;, &#x27;acute&#x27;,
  &#x27;dieresis&#x27;, &#x27;notequal&#x27;, &#x27;AE&#x27;, &#x27;Oslash&#x27;, &#x27;infinity&#x27;, &#x27;plusminus&#x27;, &#x27;lessequal&#x27;,
  &#x27;greaterequal&#x27;, &#x27;yen&#x27;, &#x27;mu&#x27;, &#x27;partialdiff&#x27;, &#x27;summation&#x27;, &#x27;product&#x27;, &#x27;pi&#x27;,
  &#x27;integral&#x27;, &#x27;ordfeminine&#x27;, &#x27;ordmasculine&#x27;, &#x27;Omega&#x27;, &#x27;ae&#x27;, &#x27;oslash&#x27;,
  &#x27;questiondown&#x27;, &#x27;exclamdown&#x27;, &#x27;logicalnot&#x27;, &#x27;radical&#x27;, &#x27;florin&#x27;,
  &#x27;approxequal&#x27;, &#x27;Delta&#x27;, &#x27;guillemotleft&#x27;, &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;,
  &#x27;nonbreakingspace&#x27;, &#x27;Agrave&#x27;, &#x27;Atilde&#x27;, &#x27;Otilde&#x27;, &#x27;OE&#x27;, &#x27;oe&#x27;, &#x27;endash&#x27;,
  &#x27;emdash&#x27;, &#x27;quotedblleft&#x27;, &#x27;quotedblright&#x27;, &#x27;quoteleft&#x27;, &#x27;quoteright&#x27;,
  &#x27;divide&#x27;, &#x27;lozenge&#x27;, &#x27;ydieresis&#x27;, &#x27;Ydieresis&#x27;, &#x27;fraction&#x27;, &#x27;currency&#x27;,
  &#x27;guilsinglleft&#x27;, &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;daggerdbl&#x27;, &#x27;periodcentered&#x27;,
  &#x27;quotesinglbase&#x27;, &#x27;quotedblbase&#x27;, &#x27;perthousand&#x27;, &#x27;Acircumflex&#x27;,
  &#x27;Ecircumflex&#x27;, &#x27;Aacute&#x27;, &#x27;Edieresis&#x27;, &#x27;Egrave&#x27;, &#x27;Iacute&#x27;, &#x27;Icircumflex&#x27;,
  &#x27;Idieresis&#x27;, &#x27;Igrave&#x27;, &#x27;Oacute&#x27;, &#x27;Ocircumflex&#x27;, &#x27;apple&#x27;, &#x27;Ograve&#x27;, &#x27;Uacute&#x27;,
  &#x27;Ucircumflex&#x27;, &#x27;Ugrave&#x27;, &#x27;dotlessi&#x27;, &#x27;circumflex&#x27;, &#x27;tilde&#x27;, &#x27;macron&#x27;,
  &#x27;breve&#x27;, &#x27;dotaccent&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;, &#x27;hungarumlaut&#x27;, &#x27;ogonek&#x27;, &#x27;caron&#x27;,
  &#x27;Lslash&#x27;, &#x27;lslash&#x27;, &#x27;Scaron&#x27;, &#x27;scaron&#x27;, &#x27;Zcaron&#x27;, &#x27;zcaron&#x27;, &#x27;brokenbar&#x27;,
  &#x27;Eth&#x27;, &#x27;eth&#x27;, &#x27;Yacute&#x27;, &#x27;yacute&#x27;, &#x27;Thorn&#x27;, &#x27;thorn&#x27;, &#x27;minus&#x27;, &#x27;multiply&#x27;,
  &#x27;onesuperior&#x27;, &#x27;twosuperior&#x27;, &#x27;threesuperior&#x27;, &#x27;onehalf&#x27;, &#x27;onequarter&#x27;,
  &#x27;threequarters&#x27;, &#x27;franc&#x27;, &#x27;Gbreve&#x27;, &#x27;gbreve&#x27;, &#x27;Idotaccent&#x27;, &#x27;Scedilla&#x27;,
  &#x27;scedilla&#x27;, &#x27;Cacute&#x27;, &#x27;cacute&#x27;, &#x27;Ccaron&#x27;, &#x27;ccaron&#x27;, &#x27;dcroat&#x27;];

function getUnicodeRangeFor(value) {
  for (var i = 0, ii = UnicodeRanges.length; i &lt; ii; i++) {
    var range = UnicodeRanges[i];
    if (value &gt;= range.begin &amp;&amp; value &lt; range.end)
      return i;
  }
  return -1;
}

function isRTLRangeFor(value) {
  var range = UnicodeRanges[13];
  if (value &gt;= range.begin &amp;&amp; value &lt; range.end)
    return true;
  range = UnicodeRanges[11];
  if (value &gt;= range.begin &amp;&amp; value &lt; range.end)
    return true;
  return false;
}

function isSpecialUnicode(unicode) {
  return (unicode &lt;= 0x1F || (unicode &gt;= 127 &amp;&amp; unicode &lt; GLYPH_AREA_SIZE)) ||
    (unicode &gt;= CMAP_GLYPH_OFFSET &amp;&amp;
    unicode &lt; CMAP_GLYPH_OFFSET + GLYPH_AREA_SIZE);
}

// The normalization table is obtained by filtering the Unicode characters
// database with &lt;compat&gt; entries.
var NormalizedUnicodes = {
  &#x27;\u00A8&#x27;: &#x27;\u0020\u0308&#x27;,
  &#x27;\u00AF&#x27;: &#x27;\u0020\u0304&#x27;,
  &#x27;\u00B4&#x27;: &#x27;\u0020\u0301&#x27;,
  &#x27;\u00B5&#x27;: &#x27;\u03BC&#x27;,
  &#x27;\u00B8&#x27;: &#x27;\u0020\u0327&#x27;,
  &#x27;\u0132&#x27;: &#x27;\u0049\u004A&#x27;,
  &#x27;\u0133&#x27;: &#x27;\u0069\u006A&#x27;,
  &#x27;\u013F&#x27;: &#x27;\u004C\u00B7&#x27;,
  &#x27;\u0140&#x27;: &#x27;\u006C\u00B7&#x27;,
  &#x27;\u0149&#x27;: &#x27;\u02BC\u006E&#x27;,
  &#x27;\u017F&#x27;: &#x27;\u0073&#x27;,
  &#x27;\u01C4&#x27;: &#x27;\u0044\u017D&#x27;,
  &#x27;\u01C5&#x27;: &#x27;\u0044\u017E&#x27;,
  &#x27;\u01C6&#x27;: &#x27;\u0064\u017E&#x27;,
  &#x27;\u01C7&#x27;: &#x27;\u004C\u004A&#x27;,
  &#x27;\u01C8&#x27;: &#x27;\u004C\u006A&#x27;,
  &#x27;\u01C9&#x27;: &#x27;\u006C\u006A&#x27;,
  &#x27;\u01CA&#x27;: &#x27;\u004E\u004A&#x27;,
  &#x27;\u01CB&#x27;: &#x27;\u004E\u006A&#x27;,
  &#x27;\u01CC&#x27;: &#x27;\u006E\u006A&#x27;,
  &#x27;\u01F1&#x27;: &#x27;\u0044\u005A&#x27;,
  &#x27;\u01F2&#x27;: &#x27;\u0044\u007A&#x27;,
  &#x27;\u01F3&#x27;: &#x27;\u0064\u007A&#x27;,
  &#x27;\u02D8&#x27;: &#x27;\u0020\u0306&#x27;,
  &#x27;\u02D9&#x27;: &#x27;\u0020\u0307&#x27;,
  &#x27;\u02DA&#x27;: &#x27;\u0020\u030A&#x27;,
  &#x27;\u02DB&#x27;: &#x27;\u0020\u0328&#x27;,
  &#x27;\u02DC&#x27;: &#x27;\u0020\u0303&#x27;,
  &#x27;\u02DD&#x27;: &#x27;\u0020\u030B&#x27;,
  &#x27;\u037A&#x27;: &#x27;\u0020\u0345&#x27;,
  &#x27;\u0384&#x27;: &#x27;\u0020\u0301&#x27;,
  &#x27;\u03D0&#x27;: &#x27;\u03B2&#x27;,
  &#x27;\u03D1&#x27;: &#x27;\u03B8&#x27;,
  &#x27;\u03D2&#x27;: &#x27;\u03A5&#x27;,
  &#x27;\u03D5&#x27;: &#x27;\u03C6&#x27;,
  &#x27;\u03D6&#x27;: &#x27;\u03C0&#x27;,
  &#x27;\u03F0&#x27;: &#x27;\u03BA&#x27;,
  &#x27;\u03F1&#x27;: &#x27;\u03C1&#x27;,
  &#x27;\u03F2&#x27;: &#x27;\u03C2&#x27;,
  &#x27;\u03F4&#x27;: &#x27;\u0398&#x27;,
  &#x27;\u03F5&#x27;: &#x27;\u03B5&#x27;,
  &#x27;\u03F9&#x27;: &#x27;\u03A3&#x27;,
  &#x27;\u0587&#x27;: &#x27;\u0565\u0582&#x27;,
  &#x27;\u0675&#x27;: &#x27;\u0627\u0674&#x27;,
  &#x27;\u0676&#x27;: &#x27;\u0648\u0674&#x27;,
  &#x27;\u0677&#x27;: &#x27;\u06C7\u0674&#x27;,
  &#x27;\u0678&#x27;: &#x27;\u064A\u0674&#x27;,
  &#x27;\u0E33&#x27;: &#x27;\u0E4D\u0E32&#x27;,
  &#x27;\u0EB3&#x27;: &#x27;\u0ECD\u0EB2&#x27;,
  &#x27;\u0EDC&#x27;: &#x27;\u0EAB\u0E99&#x27;,
  &#x27;\u0EDD&#x27;: &#x27;\u0EAB\u0EA1&#x27;,
  &#x27;\u0F77&#x27;: &#x27;\u0FB2\u0F81&#x27;,
  &#x27;\u0F79&#x27;: &#x27;\u0FB3\u0F81&#x27;,
  &#x27;\u1E9A&#x27;: &#x27;\u0061\u02BE&#x27;,
  &#x27;\u1FBD&#x27;: &#x27;\u0020\u0313&#x27;,
  &#x27;\u1FBF&#x27;: &#x27;\u0020\u0313&#x27;,
  &#x27;\u1FC0&#x27;: &#x27;\u0020\u0342&#x27;,
  &#x27;\u1FFE&#x27;: &#x27;\u0020\u0314&#x27;,
  &#x27;\u2002&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2003&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2004&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2005&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2006&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2008&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2009&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u200A&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u2017&#x27;: &#x27;\u0020\u0333&#x27;,
  &#x27;\u2024&#x27;: &#x27;\u002E&#x27;,
  &#x27;\u2025&#x27;: &#x27;\u002E\u002E&#x27;,
  &#x27;\u2026&#x27;: &#x27;\u002E\u002E\u002E&#x27;,
  &#x27;\u2033&#x27;: &#x27;\u2032\u2032&#x27;,
  &#x27;\u2034&#x27;: &#x27;\u2032\u2032\u2032&#x27;,
  &#x27;\u2036&#x27;: &#x27;\u2035\u2035&#x27;,
  &#x27;\u2037&#x27;: &#x27;\u2035\u2035\u2035&#x27;,
  &#x27;\u203C&#x27;: &#x27;\u0021\u0021&#x27;,
  &#x27;\u203E&#x27;: &#x27;\u0020\u0305&#x27;,
  &#x27;\u2047&#x27;: &#x27;\u003F\u003F&#x27;,
  &#x27;\u2048&#x27;: &#x27;\u003F\u0021&#x27;,
  &#x27;\u2049&#x27;: &#x27;\u0021\u003F&#x27;,
  &#x27;\u2057&#x27;: &#x27;\u2032\u2032\u2032\u2032&#x27;,
  &#x27;\u205F&#x27;: &#x27;\u0020&#x27;,
  &#x27;\u20A8&#x27;: &#x27;\u0052\u0073&#x27;,
  &#x27;\u2100&#x27;: &#x27;\u0061\u002F\u0063&#x27;,
  &#x27;\u2101&#x27;: &#x27;\u0061\u002F\u0073&#x27;,
  &#x27;\u2103&#x27;: &#x27;\u00B0\u0043&#x27;,
  &#x27;\u2105&#x27;: &#x27;\u0063\u002F\u006F&#x27;,
  &#x27;\u2106&#x27;: &#x27;\u0063\u002F\u0075&#x27;,
  &#x27;\u2107&#x27;: &#x27;\u0190&#x27;,
  &#x27;\u2109&#x27;: &#x27;\u00B0\u0046&#x27;,
  &#x27;\u2116&#x27;: &#x27;\u004E\u006F&#x27;,
  &#x27;\u2121&#x27;: &#x27;\u0054\u0045\u004C&#x27;,
  &#x27;\u2135&#x27;: &#x27;\u05D0&#x27;,
  &#x27;\u2136&#x27;: &#x27;\u05D1&#x27;,
  &#x27;\u2137&#x27;: &#x27;\u05D2&#x27;,
  &#x27;\u2138&#x27;: &#x27;\u05D3&#x27;,
  &#x27;\u213B&#x27;: &#x27;\u0046\u0041\u0058&#x27;,
  &#x27;\u2160&#x27;: &#x27;\u0049&#x27;,
  &#x27;\u2161&#x27;: &#x27;\u0049\u0049&#x27;,
  &#x27;\u2162&#x27;: &#x27;\u0049\u0049\u0049&#x27;,
  &#x27;\u2163&#x27;: &#x27;\u0049\u0056&#x27;,
  &#x27;\u2164&#x27;: &#x27;\u0056&#x27;,
  &#x27;\u2165&#x27;: &#x27;\u0056\u0049&#x27;,
  &#x27;\u2166&#x27;: &#x27;\u0056\u0049\u0049&#x27;,
  &#x27;\u2167&#x27;: &#x27;\u0056\u0049\u0049\u0049&#x27;,
  &#x27;\u2168&#x27;: &#x27;\u0049\u0058&#x27;,
  &#x27;\u2169&#x27;: &#x27;\u0058&#x27;,
  &#x27;\u216A&#x27;: &#x27;\u0058\u0049&#x27;,
  &#x27;\u216B&#x27;: &#x27;\u0058\u0049\u0049&#x27;,
  &#x27;\u216C&#x27;: &#x27;\u004C&#x27;,
  &#x27;\u216D&#x27;: &#x27;\u0043&#x27;,
  &#x27;\u216E&#x27;: &#x27;\u0044&#x27;,
  &#x27;\u216F&#x27;: &#x27;\u004D&#x27;,
  &#x27;\u2170&#x27;: &#x27;\u0069&#x27;,
  &#x27;\u2171&#x27;: &#x27;\u0069\u0069&#x27;,
  &#x27;\u2172&#x27;: &#x27;\u0069\u0069\u0069&#x27;,
  &#x27;\u2173&#x27;: &#x27;\u0069\u0076&#x27;,
  &#x27;\u2174&#x27;: &#x27;\u0076&#x27;,
  &#x27;\u2175&#x27;: &#x27;\u0076\u0069&#x27;,
  &#x27;\u2176&#x27;: &#x27;\u0076\u0069\u0069&#x27;,
  &#x27;\u2177&#x27;: &#x27;\u0076\u0069\u0069\u0069&#x27;,
  &#x27;\u2178&#x27;: &#x27;\u0069\u0078&#x27;,
  &#x27;\u2179&#x27;: &#x27;\u0078&#x27;,
  &#x27;\u217A&#x27;: &#x27;\u0078\u0069&#x27;,
  &#x27;\u217B&#x27;: &#x27;\u0078\u0069\u0069&#x27;,
  &#x27;\u217C&#x27;: &#x27;\u006C&#x27;,
  &#x27;\u217D&#x27;: &#x27;\u0063&#x27;,
  &#x27;\u217E&#x27;: &#x27;\u0064&#x27;,
  &#x27;\u217F&#x27;: &#x27;\u006D&#x27;,
  &#x27;\u222C&#x27;: &#x27;\u222B\u222B&#x27;,
  &#x27;\u222D&#x27;: &#x27;\u222B\u222B\u222B&#x27;,
  &#x27;\u222F&#x27;: &#x27;\u222E\u222E&#x27;,
  &#x27;\u2230&#x27;: &#x27;\u222E\u222E\u222E&#x27;,
  &#x27;\u2474&#x27;: &#x27;\u0028\u0031\u0029&#x27;,
  &#x27;\u2475&#x27;: &#x27;\u0028\u0032\u0029&#x27;,
  &#x27;\u2476&#x27;: &#x27;\u0028\u0033\u0029&#x27;,
  &#x27;\u2477&#x27;: &#x27;\u0028\u0034\u0029&#x27;,
  &#x27;\u2478&#x27;: &#x27;\u0028\u0035\u0029&#x27;,
  &#x27;\u2479&#x27;: &#x27;\u0028\u0036\u0029&#x27;,
  &#x27;\u247A&#x27;: &#x27;\u0028\u0037\u0029&#x27;,
  &#x27;\u247B&#x27;: &#x27;\u0028\u0038\u0029&#x27;,
  &#x27;\u247C&#x27;: &#x27;\u0028\u0039\u0029&#x27;,
  &#x27;\u247D&#x27;: &#x27;\u0028\u0031\u0030\u0029&#x27;,
  &#x27;\u247E&#x27;: &#x27;\u0028\u0031\u0031\u0029&#x27;,
  &#x27;\u247F&#x27;: &#x27;\u0028\u0031\u0032\u0029&#x27;,
  &#x27;\u2480&#x27;: &#x27;\u0028\u0031\u0033\u0029&#x27;,
  &#x27;\u2481&#x27;: &#x27;\u0028\u0031\u0034\u0029&#x27;,
  &#x27;\u2482&#x27;: &#x27;\u0028\u0031\u0035\u0029&#x27;,
  &#x27;\u2483&#x27;: &#x27;\u0028\u0031\u0036\u0029&#x27;,
  &#x27;\u2484&#x27;: &#x27;\u0028\u0031\u0037\u0029&#x27;,
  &#x27;\u2485&#x27;: &#x27;\u0028\u0031\u0038\u0029&#x27;,
  &#x27;\u2486&#x27;: &#x27;\u0028\u0031\u0039\u0029&#x27;,
  &#x27;\u2487&#x27;: &#x27;\u0028\u0032\u0030\u0029&#x27;,
  &#x27;\u2488&#x27;: &#x27;\u0031\u002E&#x27;,
  &#x27;\u2489&#x27;: &#x27;\u0032\u002E&#x27;,
  &#x27;\u248A&#x27;: &#x27;\u0033\u002E&#x27;,
  &#x27;\u248B&#x27;: &#x27;\u0034\u002E&#x27;,
  &#x27;\u248C&#x27;: &#x27;\u0035\u002E&#x27;,
  &#x27;\u248D&#x27;: &#x27;\u0036\u002E&#x27;,
  &#x27;\u248E&#x27;: &#x27;\u0037\u002E&#x27;,
  &#x27;\u248F&#x27;: &#x27;\u0038\u002E&#x27;,
  &#x27;\u2490&#x27;: &#x27;\u0039\u002E&#x27;,
  &#x27;\u2491&#x27;: &#x27;\u0031\u0030\u002E&#x27;,
  &#x27;\u2492&#x27;: &#x27;\u0031\u0031\u002E&#x27;,
  &#x27;\u2493&#x27;: &#x27;\u0031\u0032\u002E&#x27;,
  &#x27;\u2494&#x27;: &#x27;\u0031\u0033\u002E&#x27;,
  &#x27;\u2495&#x27;: &#x27;\u0031\u0034\u002E&#x27;,
  &#x27;\u2496&#x27;: &#x27;\u0031\u0035\u002E&#x27;,
  &#x27;\u2497&#x27;: &#x27;\u0031\u0036\u002E&#x27;,
  &#x27;\u2498&#x27;: &#x27;\u0031\u0037\u002E&#x27;,
  &#x27;\u2499&#x27;: &#x27;\u0031\u0038\u002E&#x27;,
  &#x27;\u249A&#x27;: &#x27;\u0031\u0039\u002E&#x27;,
  &#x27;\u249B&#x27;: &#x27;\u0032\u0030\u002E&#x27;,
  &#x27;\u249C&#x27;: &#x27;\u0028\u0061\u0029&#x27;,
  &#x27;\u249D&#x27;: &#x27;\u0028\u0062\u0029&#x27;,
  &#x27;\u249E&#x27;: &#x27;\u0028\u0063\u0029&#x27;,
  &#x27;\u249F&#x27;: &#x27;\u0028\u0064\u0029&#x27;,
  &#x27;\u24A0&#x27;: &#x27;\u0028\u0065\u0029&#x27;,
  &#x27;\u24A1&#x27;: &#x27;\u0028\u0066\u0029&#x27;,
  &#x27;\u24A2&#x27;: &#x27;\u0028\u0067\u0029&#x27;,
  &#x27;\u24A3&#x27;: &#x27;\u0028\u0068\u0029&#x27;,
  &#x27;\u24A4&#x27;: &#x27;\u0028\u0069\u0029&#x27;,
  &#x27;\u24A5&#x27;: &#x27;\u0028\u006A\u0029&#x27;,
  &#x27;\u24A6&#x27;: &#x27;\u0028\u006B\u0029&#x27;,
  &#x27;\u24A7&#x27;: &#x27;\u0028\u006C\u0029&#x27;,
  &#x27;\u24A8&#x27;: &#x27;\u0028\u006D\u0029&#x27;,
  &#x27;\u24A9&#x27;: &#x27;\u0028\u006E\u0029&#x27;,
  &#x27;\u24AA&#x27;: &#x27;\u0028\u006F\u0029&#x27;,
  &#x27;\u24AB&#x27;: &#x27;\u0028\u0070\u0029&#x27;,
  &#x27;\u24AC&#x27;: &#x27;\u0028\u0071\u0029&#x27;,
  &#x27;\u24AD&#x27;: &#x27;\u0028\u0072\u0029&#x27;,
  &#x27;\u24AE&#x27;: &#x27;\u0028\u0073\u0029&#x27;,
  &#x27;\u24AF&#x27;: &#x27;\u0028\u0074\u0029&#x27;,
  &#x27;\u24B0&#x27;: &#x27;\u0028\u0075\u0029&#x27;,
  &#x27;\u24B1&#x27;: &#x27;\u0028\u0076\u0029&#x27;,
  &#x27;\u24B2&#x27;: &#x27;\u0028\u0077\u0029&#x27;,
  &#x27;\u24B3&#x27;: &#x27;\u0028\u0078\u0029&#x27;,
  &#x27;\u24B4&#x27;: &#x27;\u0028\u0079\u0029&#x27;,
  &#x27;\u24B5&#x27;: &#x27;\u0028\u007A\u0029&#x27;,
  &#x27;\u2A0C&#x27;: &#x27;\u222B\u222B\u222B\u222B&#x27;,
  &#x27;\u2A74&#x27;: &#x27;\u003A\u003A\u003D&#x27;,
  &#x27;\u2A75&#x27;: &#x27;\u003D\u003D&#x27;,
  &#x27;\u2A76&#x27;: &#x27;\u003D\u003D\u003D&#x27;,
  &#x27;\u2E9F&#x27;: &#x27;\u6BCD&#x27;,
  &#x27;\u2EF3&#x27;: &#x27;\u9F9F&#x27;,
  &#x27;\u2F00&#x27;: &#x27;\u4E00&#x27;,
  &#x27;\u2F01&#x27;: &#x27;\u4E28&#x27;,
  &#x27;\u2F02&#x27;: &#x27;\u4E36&#x27;,
  &#x27;\u2F03&#x27;: &#x27;\u4E3F&#x27;,
  &#x27;\u2F04&#x27;: &#x27;\u4E59&#x27;,
  &#x27;\u2F05&#x27;: &#x27;\u4E85&#x27;,
  &#x27;\u2F06&#x27;: &#x27;\u4E8C&#x27;,
  &#x27;\u2F07&#x27;: &#x27;\u4EA0&#x27;,
  &#x27;\u2F08&#x27;: &#x27;\u4EBA&#x27;,
  &#x27;\u2F09&#x27;: &#x27;\u513F&#x27;,
  &#x27;\u2F0A&#x27;: &#x27;\u5165&#x27;,
  &#x27;\u2F0B&#x27;: &#x27;\u516B&#x27;,
  &#x27;\u2F0C&#x27;: &#x27;\u5182&#x27;,
  &#x27;\u2F0D&#x27;: &#x27;\u5196&#x27;,
  &#x27;\u2F0E&#x27;: &#x27;\u51AB&#x27;,
  &#x27;\u2F0F&#x27;: &#x27;\u51E0&#x27;,
  &#x27;\u2F10&#x27;: &#x27;\u51F5&#x27;,
  &#x27;\u2F11&#x27;: &#x27;\u5200&#x27;,
  &#x27;\u2F12&#x27;: &#x27;\u529B&#x27;,
  &#x27;\u2F13&#x27;: &#x27;\u52F9&#x27;,
  &#x27;\u2F14&#x27;: &#x27;\u5315&#x27;,
  &#x27;\u2F15&#x27;: &#x27;\u531A&#x27;,
  &#x27;\u2F16&#x27;: &#x27;\u5338&#x27;,
  &#x27;\u2F17&#x27;: &#x27;\u5341&#x27;,
  &#x27;\u2F18&#x27;: &#x27;\u535C&#x27;,
  &#x27;\u2F19&#x27;: &#x27;\u5369&#x27;,
  &#x27;\u2F1A&#x27;: &#x27;\u5382&#x27;,
  &#x27;\u2F1B&#x27;: &#x27;\u53B6&#x27;,
  &#x27;\u2F1C&#x27;: &#x27;\u53C8&#x27;,
  &#x27;\u2F1D&#x27;: &#x27;\u53E3&#x27;,
  &#x27;\u2F1E&#x27;: &#x27;\u56D7&#x27;,
  &#x27;\u2F1F&#x27;: &#x27;\u571F&#x27;,
  &#x27;\u2F20&#x27;: &#x27;\u58EB&#x27;,
  &#x27;\u2F21&#x27;: &#x27;\u5902&#x27;,
  &#x27;\u2F22&#x27;: &#x27;\u590A&#x27;,
  &#x27;\u2F23&#x27;: &#x27;\u5915&#x27;,
  &#x27;\u2F24&#x27;: &#x27;\u5927&#x27;,
  &#x27;\u2F25&#x27;: &#x27;\u5973&#x27;,
  &#x27;\u2F26&#x27;: &#x27;\u5B50&#x27;,
  &#x27;\u2F27&#x27;: &#x27;\u5B80&#x27;,
  &#x27;\u2F28&#x27;: &#x27;\u5BF8&#x27;,
  &#x27;\u2F29&#x27;: &#x27;\u5C0F&#x27;,
  &#x27;\u2F2A&#x27;: &#x27;\u5C22&#x27;,
  &#x27;\u2F2B&#x27;: &#x27;\u5C38&#x27;,
  &#x27;\u2F2C&#x27;: &#x27;\u5C6E&#x27;,
  &#x27;\u2F2D&#x27;: &#x27;\u5C71&#x27;,
  &#x27;\u2F2E&#x27;: &#x27;\u5DDB&#x27;,
  &#x27;\u2F2F&#x27;: &#x27;\u5DE5&#x27;,
  &#x27;\u2F30&#x27;: &#x27;\u5DF1&#x27;,
  &#x27;\u2F31&#x27;: &#x27;\u5DFE&#x27;,
  &#x27;\u2F32&#x27;: &#x27;\u5E72&#x27;,
  &#x27;\u2F33&#x27;: &#x27;\u5E7A&#x27;,
  &#x27;\u2F34&#x27;: &#x27;\u5E7F&#x27;,
  &#x27;\u2F35&#x27;: &#x27;\u5EF4&#x27;,
  &#x27;\u2F36&#x27;: &#x27;\u5EFE&#x27;,
  &#x27;\u2F37&#x27;: &#x27;\u5F0B&#x27;,
  &#x27;\u2F38&#x27;: &#x27;\u5F13&#x27;,
  &#x27;\u2F39&#x27;: &#x27;\u5F50&#x27;,
  &#x27;\u2F3A&#x27;: &#x27;\u5F61&#x27;,
  &#x27;\u2F3B&#x27;: &#x27;\u5F73&#x27;,
  &#x27;\u2F3C&#x27;: &#x27;\u5FC3&#x27;,
  &#x27;\u2F3D&#x27;: &#x27;\u6208&#x27;,
  &#x27;\u2F3E&#x27;: &#x27;\u6236&#x27;,
  &#x27;\u2F3F&#x27;: &#x27;\u624B&#x27;,
  &#x27;\u2F40&#x27;: &#x27;\u652F&#x27;,
  &#x27;\u2F41&#x27;: &#x27;\u6534&#x27;,
  &#x27;\u2F42&#x27;: &#x27;\u6587&#x27;,
  &#x27;\u2F43&#x27;: &#x27;\u6597&#x27;,
  &#x27;\u2F44&#x27;: &#x27;\u65A4&#x27;,
  &#x27;\u2F45&#x27;: &#x27;\u65B9&#x27;,
  &#x27;\u2F46&#x27;: &#x27;\u65E0&#x27;,
  &#x27;\u2F47&#x27;: &#x27;\u65E5&#x27;,
  &#x27;\u2F48&#x27;: &#x27;\u66F0&#x27;,
  &#x27;\u2F49&#x27;: &#x27;\u6708&#x27;,
  &#x27;\u2F4A&#x27;: &#x27;\u6728&#x27;,
  &#x27;\u2F4B&#x27;: &#x27;\u6B20&#x27;,
  &#x27;\u2F4C&#x27;: &#x27;\u6B62&#x27;,
  &#x27;\u2F4D&#x27;: &#x27;\u6B79&#x27;,
  &#x27;\u2F4E&#x27;: &#x27;\u6BB3&#x27;,
  &#x27;\u2F4F&#x27;: &#x27;\u6BCB&#x27;,
  &#x27;\u2F50&#x27;: &#x27;\u6BD4&#x27;,
  &#x27;\u2F51&#x27;: &#x27;\u6BDB&#x27;,
  &#x27;\u2F52&#x27;: &#x27;\u6C0F&#x27;,
  &#x27;\u2F53&#x27;: &#x27;\u6C14&#x27;,
  &#x27;\u2F54&#x27;: &#x27;\u6C34&#x27;,
  &#x27;\u2F55&#x27;: &#x27;\u706B&#x27;,
  &#x27;\u2F56&#x27;: &#x27;\u722A&#x27;,
  &#x27;\u2F57&#x27;: &#x27;\u7236&#x27;,
  &#x27;\u2F58&#x27;: &#x27;\u723B&#x27;,
  &#x27;\u2F59&#x27;: &#x27;\u723F&#x27;,
  &#x27;\u2F5A&#x27;: &#x27;\u7247&#x27;,
  &#x27;\u2F5B&#x27;: &#x27;\u7259&#x27;,
  &#x27;\u2F5C&#x27;: &#x27;\u725B&#x27;,
  &#x27;\u2F5D&#x27;: &#x27;\u72AC&#x27;,
  &#x27;\u2F5E&#x27;: &#x27;\u7384&#x27;,
  &#x27;\u2F5F&#x27;: &#x27;\u7389&#x27;,
  &#x27;\u2F60&#x27;: &#x27;\u74DC&#x27;,
  &#x27;\u2F61&#x27;: &#x27;\u74E6&#x27;,
  &#x27;\u2F62&#x27;: &#x27;\u7518&#x27;,
  &#x27;\u2F63&#x27;: &#x27;\u751F&#x27;,
  &#x27;\u2F64&#x27;: &#x27;\u7528&#x27;,
  &#x27;\u2F65&#x27;: &#x27;\u7530&#x27;,
  &#x27;\u2F66&#x27;: &#x27;\u758B&#x27;,
  &#x27;\u2F67&#x27;: &#x27;\u7592&#x27;,
  &#x27;\u2F68&#x27;: &#x27;\u7676&#x27;,
  &#x27;\u2F69&#x27;: &#x27;\u767D&#x27;,
  &#x27;\u2F6A&#x27;: &#x27;\u76AE&#x27;,
  &#x27;\u2F6B&#x27;: &#x27;\u76BF&#x27;,
  &#x27;\u2F6C&#x27;: &#x27;\u76EE&#x27;,
  &#x27;\u2F6D&#x27;: &#x27;\u77DB&#x27;,
  &#x27;\u2F6E&#x27;: &#x27;\u77E2&#x27;,
  &#x27;\u2F6F&#x27;: &#x27;\u77F3&#x27;,
  &#x27;\u2F70&#x27;: &#x27;\u793A&#x27;,
  &#x27;\u2F71&#x27;: &#x27;\u79B8&#x27;,
  &#x27;\u2F72&#x27;: &#x27;\u79BE&#x27;,
  &#x27;\u2F73&#x27;: &#x27;\u7A74&#x27;,
  &#x27;\u2F74&#x27;: &#x27;\u7ACB&#x27;,
  &#x27;\u2F75&#x27;: &#x27;\u7AF9&#x27;,
  &#x27;\u2F76&#x27;: &#x27;\u7C73&#x27;,
  &#x27;\u2F77&#x27;: &#x27;\u7CF8&#x27;,
  &#x27;\u2F78&#x27;: &#x27;\u7F36&#x27;,
  &#x27;\u2F79&#x27;: &#x27;\u7F51&#x27;,
  &#x27;\u2F7A&#x27;: &#x27;\u7F8A&#x27;,
  &#x27;\u2F7B&#x27;: &#x27;\u7FBD&#x27;,
  &#x27;\u2F7C&#x27;: &#x27;\u8001&#x27;,
  &#x27;\u2F7D&#x27;: &#x27;\u800C&#x27;,
  &#x27;\u2F7E&#x27;: &#x27;\u8012&#x27;,
  &#x27;\u2F7F&#x27;: &#x27;\u8033&#x27;,
  &#x27;\u2F80&#x27;: &#x27;\u807F&#x27;,
  &#x27;\u2F81&#x27;: &#x27;\u8089&#x27;,
  &#x27;\u2F82&#x27;: &#x27;\u81E3&#x27;,
  &#x27;\u2F83&#x27;: &#x27;\u81EA&#x27;,
  &#x27;\u2F84&#x27;: &#x27;\u81F3&#x27;,
  &#x27;\u2F85&#x27;: &#x27;\u81FC&#x27;,
  &#x27;\u2F86&#x27;: &#x27;\u820C&#x27;,
  &#x27;\u2F87&#x27;: &#x27;\u821B&#x27;,
  &#x27;\u2F88&#x27;: &#x27;\u821F&#x27;,
  &#x27;\u2F89&#x27;: &#x27;\u826E&#x27;,
  &#x27;\u2F8A&#x27;: &#x27;\u8272&#x27;,
  &#x27;\u2F8B&#x27;: &#x27;\u8278&#x27;,
  &#x27;\u2F8C&#x27;: &#x27;\u864D&#x27;,
  &#x27;\u2F8D&#x27;: &#x27;\u866B&#x27;,
  &#x27;\u2F8E&#x27;: &#x27;\u8840&#x27;,
  &#x27;\u2F8F&#x27;: &#x27;\u884C&#x27;,
  &#x27;\u2F90&#x27;: &#x27;\u8863&#x27;,
  &#x27;\u2F91&#x27;: &#x27;\u897E&#x27;,
  &#x27;\u2F92&#x27;: &#x27;\u898B&#x27;,
  &#x27;\u2F93&#x27;: &#x27;\u89D2&#x27;,
  &#x27;\u2F94&#x27;: &#x27;\u8A00&#x27;,
  &#x27;\u2F95&#x27;: &#x27;\u8C37&#x27;,
  &#x27;\u2F96&#x27;: &#x27;\u8C46&#x27;,
  &#x27;\u2F97&#x27;: &#x27;\u8C55&#x27;,
  &#x27;\u2F98&#x27;: &#x27;\u8C78&#x27;,
  &#x27;\u2F99&#x27;: &#x27;\u8C9D&#x27;,
  &#x27;\u2F9A&#x27;: &#x27;\u8D64&#x27;,
  &#x27;\u2F9B&#x27;: &#x27;\u8D70&#x27;,
  &#x27;\u2F9C&#x27;: &#x27;\u8DB3&#x27;,
  &#x27;\u2F9D&#x27;: &#x27;\u8EAB&#x27;,
  &#x27;\u2F9E&#x27;: &#x27;\u8ECA&#x27;,
  &#x27;\u2F9F&#x27;: &#x27;\u8F9B&#x27;,
  &#x27;\u2FA0&#x27;: &#x27;\u8FB0&#x27;,
  &#x27;\u2FA1&#x27;: &#x27;\u8FB5&#x27;,
  &#x27;\u2FA2&#x27;: &#x27;\u9091&#x27;,
  &#x27;\u2FA3&#x27;: &#x27;\u9149&#x27;,
  &#x27;\u2FA4&#x27;: &#x27;\u91C6&#x27;,
  &#x27;\u2FA5&#x27;: &#x27;\u91CC&#x27;,
  &#x27;\u2FA6&#x27;: &#x27;\u91D1&#x27;,
  &#x27;\u2FA7&#x27;: &#x27;\u9577&#x27;,
  &#x27;\u2FA8&#x27;: &#x27;\u9580&#x27;,
  &#x27;\u2FA9&#x27;: &#x27;\u961C&#x27;,
  &#x27;\u2FAA&#x27;: &#x27;\u96B6&#x27;,
  &#x27;\u2FAB&#x27;: &#x27;\u96B9&#x27;,
  &#x27;\u2FAC&#x27;: &#x27;\u96E8&#x27;,
  &#x27;\u2FAD&#x27;: &#x27;\u9751&#x27;,
  &#x27;\u2FAE&#x27;: &#x27;\u975E&#x27;,
  &#x27;\u2FAF&#x27;: &#x27;\u9762&#x27;,
  &#x27;\u2FB0&#x27;: &#x27;\u9769&#x27;,
  &#x27;\u2FB1&#x27;: &#x27;\u97CB&#x27;,
  &#x27;\u2FB2&#x27;: &#x27;\u97ED&#x27;,
  &#x27;\u2FB3&#x27;: &#x27;\u97F3&#x27;,
  &#x27;\u2FB4&#x27;: &#x27;\u9801&#x27;,
  &#x27;\u2FB5&#x27;: &#x27;\u98A8&#x27;,
  &#x27;\u2FB6&#x27;: &#x27;\u98DB&#x27;,
  &#x27;\u2FB7&#x27;: &#x27;\u98DF&#x27;,
  &#x27;\u2FB8&#x27;: &#x27;\u9996&#x27;,
  &#x27;\u2FB9&#x27;: &#x27;\u9999&#x27;,
  &#x27;\u2FBA&#x27;: &#x27;\u99AC&#x27;,
  &#x27;\u2FBB&#x27;: &#x27;\u9AA8&#x27;,
  &#x27;\u2FBC&#x27;: &#x27;\u9AD8&#x27;,
  &#x27;\u2FBD&#x27;: &#x27;\u9ADF&#x27;,
  &#x27;\u2FBE&#x27;: &#x27;\u9B25&#x27;,
  &#x27;\u2FBF&#x27;: &#x27;\u9B2F&#x27;,
  &#x27;\u2FC0&#x27;: &#x27;\u9B32&#x27;,
  &#x27;\u2FC1&#x27;: &#x27;\u9B3C&#x27;,
  &#x27;\u2FC2&#x27;: &#x27;\u9B5A&#x27;,
  &#x27;\u2FC3&#x27;: &#x27;\u9CE5&#x27;,
  &#x27;\u2FC4&#x27;: &#x27;\u9E75&#x27;,
  &#x27;\u2FC5&#x27;: &#x27;\u9E7F&#x27;,
  &#x27;\u2FC6&#x27;: &#x27;\u9EA5&#x27;,
  &#x27;\u2FC7&#x27;: &#x27;\u9EBB&#x27;,
  &#x27;\u2FC8&#x27;: &#x27;\u9EC3&#x27;,
  &#x27;\u2FC9&#x27;: &#x27;\u9ECD&#x27;,
  &#x27;\u2FCA&#x27;: &#x27;\u9ED1&#x27;,
  &#x27;\u2FCB&#x27;: &#x27;\u9EF9&#x27;,
  &#x27;\u2FCC&#x27;: &#x27;\u9EFD&#x27;,
  &#x27;\u2FCD&#x27;: &#x27;\u9F0E&#x27;,
  &#x27;\u2FCE&#x27;: &#x27;\u9F13&#x27;,
  &#x27;\u2FCF&#x27;: &#x27;\u9F20&#x27;,
  &#x27;\u2FD0&#x27;: &#x27;\u9F3B&#x27;,
  &#x27;\u2FD1&#x27;: &#x27;\u9F4A&#x27;,
  &#x27;\u2FD2&#x27;: &#x27;\u9F52&#x27;,
  &#x27;\u2FD3&#x27;: &#x27;\u9F8D&#x27;,
  &#x27;\u2FD4&#x27;: &#x27;\u9F9C&#x27;,
  &#x27;\u2FD5&#x27;: &#x27;\u9FA0&#x27;,
  &#x27;\u3036&#x27;: &#x27;\u3012&#x27;,
  &#x27;\u3038&#x27;: &#x27;\u5341&#x27;,
  &#x27;\u3039&#x27;: &#x27;\u5344&#x27;,
  &#x27;\u303A&#x27;: &#x27;\u5345&#x27;,
  &#x27;\u309B&#x27;: &#x27;\u0020\u3099&#x27;,
  &#x27;\u309C&#x27;: &#x27;\u0020\u309A&#x27;,
  &#x27;\u3131&#x27;: &#x27;\u1100&#x27;,
  &#x27;\u3132&#x27;: &#x27;\u1101&#x27;,
  &#x27;\u3133&#x27;: &#x27;\u11AA&#x27;,
  &#x27;\u3134&#x27;: &#x27;\u1102&#x27;,
  &#x27;\u3135&#x27;: &#x27;\u11AC&#x27;,
  &#x27;\u3136&#x27;: &#x27;\u11AD&#x27;,
  &#x27;\u3137&#x27;: &#x27;\u1103&#x27;,
  &#x27;\u3138&#x27;: &#x27;\u1104&#x27;,
  &#x27;\u3139&#x27;: &#x27;\u1105&#x27;,
  &#x27;\u313A&#x27;: &#x27;\u11B0&#x27;,
  &#x27;\u313B&#x27;: &#x27;\u11B1&#x27;,
  &#x27;\u313C&#x27;: &#x27;\u11B2&#x27;,
  &#x27;\u313D&#x27;: &#x27;\u11B3&#x27;,
  &#x27;\u313E&#x27;: &#x27;\u11B4&#x27;,
  &#x27;\u313F&#x27;: &#x27;\u11B5&#x27;,
  &#x27;\u3140&#x27;: &#x27;\u111A&#x27;,
  &#x27;\u3141&#x27;: &#x27;\u1106&#x27;,
  &#x27;\u3142&#x27;: &#x27;\u1107&#x27;,
  &#x27;\u3143&#x27;: &#x27;\u1108&#x27;,
  &#x27;\u3144&#x27;: &#x27;\u1121&#x27;,
  &#x27;\u3145&#x27;: &#x27;\u1109&#x27;,
  &#x27;\u3146&#x27;: &#x27;\u110A&#x27;,
  &#x27;\u3147&#x27;: &#x27;\u110B&#x27;,
  &#x27;\u3148&#x27;: &#x27;\u110C&#x27;,
  &#x27;\u3149&#x27;: &#x27;\u110D&#x27;,
  &#x27;\u314A&#x27;: &#x27;\u110E&#x27;,
  &#x27;\u314B&#x27;: &#x27;\u110F&#x27;,
  &#x27;\u314C&#x27;: &#x27;\u1110&#x27;,
  &#x27;\u314D&#x27;: &#x27;\u1111&#x27;,
  &#x27;\u314E&#x27;: &#x27;\u1112&#x27;,
  &#x27;\u314F&#x27;: &#x27;\u1161&#x27;,
  &#x27;\u3150&#x27;: &#x27;\u1162&#x27;,
  &#x27;\u3151&#x27;: &#x27;\u1163&#x27;,
  &#x27;\u3152&#x27;: &#x27;\u1164&#x27;,
  &#x27;\u3153&#x27;: &#x27;\u1165&#x27;,
  &#x27;\u3154&#x27;: &#x27;\u1166&#x27;,
  &#x27;\u3155&#x27;: &#x27;\u1167&#x27;,
  &#x27;\u3156&#x27;: &#x27;\u1168&#x27;,
  &#x27;\u3157&#x27;: &#x27;\u1169&#x27;,
  &#x27;\u3158&#x27;: &#x27;\u116A&#x27;,
  &#x27;\u3159&#x27;: &#x27;\u116B&#x27;,
  &#x27;\u315A&#x27;: &#x27;\u116C&#x27;,
  &#x27;\u315B&#x27;: &#x27;\u116D&#x27;,
  &#x27;\u315C&#x27;: &#x27;\u116E&#x27;,
  &#x27;\u315D&#x27;: &#x27;\u116F&#x27;,
  &#x27;\u315E&#x27;: &#x27;\u1170&#x27;,
  &#x27;\u315F&#x27;: &#x27;\u1171&#x27;,
  &#x27;\u3160&#x27;: &#x27;\u1172&#x27;,
  &#x27;\u3161&#x27;: &#x27;\u1173&#x27;,
  &#x27;\u3162&#x27;: &#x27;\u1174&#x27;,
  &#x27;\u3163&#x27;: &#x27;\u1175&#x27;,
  &#x27;\u3164&#x27;: &#x27;\u1160&#x27;,
  &#x27;\u3165&#x27;: &#x27;\u1114&#x27;,
  &#x27;\u3166&#x27;: &#x27;\u1115&#x27;,
  &#x27;\u3167&#x27;: &#x27;\u11C7&#x27;,
  &#x27;\u3168&#x27;: &#x27;\u11C8&#x27;,
  &#x27;\u3169&#x27;: &#x27;\u11CC&#x27;,
  &#x27;\u316A&#x27;: &#x27;\u11CE&#x27;,
  &#x27;\u316B&#x27;: &#x27;\u11D3&#x27;,
  &#x27;\u316C&#x27;: &#x27;\u11D7&#x27;,
  &#x27;\u316D&#x27;: &#x27;\u11D9&#x27;,
  &#x27;\u316E&#x27;: &#x27;\u111C&#x27;,
  &#x27;\u316F&#x27;: &#x27;\u11DD&#x27;,
  &#x27;\u3170&#x27;: &#x27;\u11DF&#x27;,
  &#x27;\u3171&#x27;: &#x27;\u111D&#x27;,
  &#x27;\u3172&#x27;: &#x27;\u111E&#x27;,
  &#x27;\u3173&#x27;: &#x27;\u1120&#x27;,
  &#x27;\u3174&#x27;: &#x27;\u1122&#x27;,
  &#x27;\u3175&#x27;: &#x27;\u1123&#x27;,
  &#x27;\u3176&#x27;: &#x27;\u1127&#x27;,
  &#x27;\u3177&#x27;: &#x27;\u1129&#x27;,
  &#x27;\u3178&#x27;: &#x27;\u112B&#x27;,
  &#x27;\u3179&#x27;: &#x27;\u112C&#x27;,
  &#x27;\u317A&#x27;: &#x27;\u112D&#x27;,
  &#x27;\u317B&#x27;: &#x27;\u112E&#x27;,
  &#x27;\u317C&#x27;: &#x27;\u112F&#x27;,
  &#x27;\u317D&#x27;: &#x27;\u1132&#x27;,
  &#x27;\u317E&#x27;: &#x27;\u1136&#x27;,
  &#x27;\u317F&#x27;: &#x27;\u1140&#x27;,
  &#x27;\u3180&#x27;: &#x27;\u1147&#x27;,
  &#x27;\u3181&#x27;: &#x27;\u114C&#x27;,
  &#x27;\u3182&#x27;: &#x27;\u11F1&#x27;,
  &#x27;\u3183&#x27;: &#x27;\u11F2&#x27;,
  &#x27;\u3184&#x27;: &#x27;\u1157&#x27;,
  &#x27;\u3185&#x27;: &#x27;\u1158&#x27;,
  &#x27;\u3186&#x27;: &#x27;\u1159&#x27;,
  &#x27;\u3187&#x27;: &#x27;\u1184&#x27;,
  &#x27;\u3188&#x27;: &#x27;\u1185&#x27;,
  &#x27;\u3189&#x27;: &#x27;\u1188&#x27;,
  &#x27;\u318A&#x27;: &#x27;\u1191&#x27;,
  &#x27;\u318B&#x27;: &#x27;\u1192&#x27;,
  &#x27;\u318C&#x27;: &#x27;\u1194&#x27;,
  &#x27;\u318D&#x27;: &#x27;\u119E&#x27;,
  &#x27;\u318E&#x27;: &#x27;\u11A1&#x27;,
  &#x27;\u3200&#x27;: &#x27;\u0028\u1100\u0029&#x27;,
  &#x27;\u3201&#x27;: &#x27;\u0028\u1102\u0029&#x27;,
  &#x27;\u3202&#x27;: &#x27;\u0028\u1103\u0029&#x27;,
  &#x27;\u3203&#x27;: &#x27;\u0028\u1105\u0029&#x27;,
  &#x27;\u3204&#x27;: &#x27;\u0028\u1106\u0029&#x27;,
  &#x27;\u3205&#x27;: &#x27;\u0028\u1107\u0029&#x27;,
  &#x27;\u3206&#x27;: &#x27;\u0028\u1109\u0029&#x27;,
  &#x27;\u3207&#x27;: &#x27;\u0028\u110B\u0029&#x27;,
  &#x27;\u3208&#x27;: &#x27;\u0028\u110C\u0029&#x27;,
  &#x27;\u3209&#x27;: &#x27;\u0028\u110E\u0029&#x27;,
  &#x27;\u320A&#x27;: &#x27;\u0028\u110F\u0029&#x27;,
  &#x27;\u320B&#x27;: &#x27;\u0028\u1110\u0029&#x27;,
  &#x27;\u320C&#x27;: &#x27;\u0028\u1111\u0029&#x27;,
  &#x27;\u320D&#x27;: &#x27;\u0028\u1112\u0029&#x27;,
  &#x27;\u320E&#x27;: &#x27;\u0028\u1100\u1161\u0029&#x27;,
  &#x27;\u320F&#x27;: &#x27;\u0028\u1102\u1161\u0029&#x27;,
  &#x27;\u3210&#x27;: &#x27;\u0028\u1103\u1161\u0029&#x27;,
  &#x27;\u3211&#x27;: &#x27;\u0028\u1105\u1161\u0029&#x27;,
  &#x27;\u3212&#x27;: &#x27;\u0028\u1106\u1161\u0029&#x27;,
  &#x27;\u3213&#x27;: &#x27;\u0028\u1107\u1161\u0029&#x27;,
  &#x27;\u3214&#x27;: &#x27;\u0028\u1109\u1161\u0029&#x27;,
  &#x27;\u3215&#x27;: &#x27;\u0028\u110B\u1161\u0029&#x27;,
  &#x27;\u3216&#x27;: &#x27;\u0028\u110C\u1161\u0029&#x27;,
  &#x27;\u3217&#x27;: &#x27;\u0028\u110E\u1161\u0029&#x27;,
  &#x27;\u3218&#x27;: &#x27;\u0028\u110F\u1161\u0029&#x27;,
  &#x27;\u3219&#x27;: &#x27;\u0028\u1110\u1161\u0029&#x27;,
  &#x27;\u321A&#x27;: &#x27;\u0028\u1111\u1161\u0029&#x27;,
  &#x27;\u321B&#x27;: &#x27;\u0028\u1112\u1161\u0029&#x27;,
  &#x27;\u321C&#x27;: &#x27;\u0028\u110C\u116E\u0029&#x27;,
  &#x27;\u321D&#x27;: &#x27;\u0028\u110B\u1169\u110C\u1165\u11AB\u0029&#x27;,
  &#x27;\u321E&#x27;: &#x27;\u0028\u110B\u1169\u1112\u116E\u0029&#x27;,
  &#x27;\u3220&#x27;: &#x27;\u0028\u4E00\u0029&#x27;,
  &#x27;\u3221&#x27;: &#x27;\u0028\u4E8C\u0029&#x27;,
  &#x27;\u3222&#x27;: &#x27;\u0028\u4E09\u0029&#x27;,
  &#x27;\u3223&#x27;: &#x27;\u0028\u56DB\u0029&#x27;,
  &#x27;\u3224&#x27;: &#x27;\u0028\u4E94\u0029&#x27;,
  &#x27;\u3225&#x27;: &#x27;\u0028\u516D\u0029&#x27;,
  &#x27;\u3226&#x27;: &#x27;\u0028\u4E03\u0029&#x27;,
  &#x27;\u3227&#x27;: &#x27;\u0028\u516B\u0029&#x27;,
  &#x27;\u3228&#x27;: &#x27;\u0028\u4E5D\u0029&#x27;,
  &#x27;\u3229&#x27;: &#x27;\u0028\u5341\u0029&#x27;,
  &#x27;\u322A&#x27;: &#x27;\u0028\u6708\u0029&#x27;,
  &#x27;\u322B&#x27;: &#x27;\u0028\u706B\u0029&#x27;,
  &#x27;\u322C&#x27;: &#x27;\u0028\u6C34\u0029&#x27;,
  &#x27;\u322D&#x27;: &#x27;\u0028\u6728\u0029&#x27;,
  &#x27;\u322E&#x27;: &#x27;\u0028\u91D1\u0029&#x27;,
  &#x27;\u322F&#x27;: &#x27;\u0028\u571F\u0029&#x27;,
  &#x27;\u3230&#x27;: &#x27;\u0028\u65E5\u0029&#x27;,
  &#x27;\u3231&#x27;: &#x27;\u0028\u682A\u0029&#x27;,
  &#x27;\u3232&#x27;: &#x27;\u0028\u6709\u0029&#x27;,
  &#x27;\u3233&#x27;: &#x27;\u0028\u793E\u0029&#x27;,
  &#x27;\u3234&#x27;: &#x27;\u0028\u540D\u0029&#x27;,
  &#x27;\u3235&#x27;: &#x27;\u0028\u7279\u0029&#x27;,
  &#x27;\u3236&#x27;: &#x27;\u0028\u8CA1\u0029&#x27;,
  &#x27;\u3237&#x27;: &#x27;\u0028\u795D\u0029&#x27;,
  &#x27;\u3238&#x27;: &#x27;\u0028\u52B4\u0029&#x27;,
  &#x27;\u3239&#x27;: &#x27;\u0028\u4EE3\u0029&#x27;,
  &#x27;\u323A&#x27;: &#x27;\u0028\u547C\u0029&#x27;,
  &#x27;\u323B&#x27;: &#x27;\u0028\u5B66\u0029&#x27;,
  &#x27;\u323C&#x27;: &#x27;\u0028\u76E3\u0029&#x27;,
  &#x27;\u323D&#x27;: &#x27;\u0028\u4F01\u0029&#x27;,
  &#x27;\u323E&#x27;: &#x27;\u0028\u8CC7\u0029&#x27;,
  &#x27;\u323F&#x27;: &#x27;\u0028\u5354\u0029&#x27;,
  &#x27;\u3240&#x27;: &#x27;\u0028\u796D\u0029&#x27;,
  &#x27;\u3241&#x27;: &#x27;\u0028\u4F11\u0029&#x27;,
  &#x27;\u3242&#x27;: &#x27;\u0028\u81EA\u0029&#x27;,
  &#x27;\u3243&#x27;: &#x27;\u0028\u81F3\u0029&#x27;,
  &#x27;\u32C0&#x27;: &#x27;\u0031\u6708&#x27;,
  &#x27;\u32C1&#x27;: &#x27;\u0032\u6708&#x27;,
  &#x27;\u32C2&#x27;: &#x27;\u0033\u6708&#x27;,
  &#x27;\u32C3&#x27;: &#x27;\u0034\u6708&#x27;,
  &#x27;\u32C4&#x27;: &#x27;\u0035\u6708&#x27;,
  &#x27;\u32C5&#x27;: &#x27;\u0036\u6708&#x27;,
  &#x27;\u32C6&#x27;: &#x27;\u0037\u6708&#x27;,
  &#x27;\u32C7&#x27;: &#x27;\u0038\u6708&#x27;,
  &#x27;\u32C8&#x27;: &#x27;\u0039\u6708&#x27;,
  &#x27;\u32C9&#x27;: &#x27;\u0031\u0030\u6708&#x27;,
  &#x27;\u32CA&#x27;: &#x27;\u0031\u0031\u6708&#x27;,
  &#x27;\u32CB&#x27;: &#x27;\u0031\u0032\u6708&#x27;,
  &#x27;\u3358&#x27;: &#x27;\u0030\u70B9&#x27;,
  &#x27;\u3359&#x27;: &#x27;\u0031\u70B9&#x27;,
  &#x27;\u335A&#x27;: &#x27;\u0032\u70B9&#x27;,
  &#x27;\u335B&#x27;: &#x27;\u0033\u70B9&#x27;,
  &#x27;\u335C&#x27;: &#x27;\u0034\u70B9&#x27;,
  &#x27;\u335D&#x27;: &#x27;\u0035\u70B9&#x27;,
  &#x27;\u335E&#x27;: &#x27;\u0036\u70B9&#x27;,
  &#x27;\u335F&#x27;: &#x27;\u0037\u70B9&#x27;,
  &#x27;\u3360&#x27;: &#x27;\u0038\u70B9&#x27;,
  &#x27;\u3361&#x27;: &#x27;\u0039\u70B9&#x27;,
  &#x27;\u3362&#x27;: &#x27;\u0031\u0030\u70B9&#x27;,
  &#x27;\u3363&#x27;: &#x27;\u0031\u0031\u70B9&#x27;,
  &#x27;\u3364&#x27;: &#x27;\u0031\u0032\u70B9&#x27;,
  &#x27;\u3365&#x27;: &#x27;\u0031\u0033\u70B9&#x27;,
  &#x27;\u3366&#x27;: &#x27;\u0031\u0034\u70B9&#x27;,
  &#x27;\u3367&#x27;: &#x27;\u0031\u0035\u70B9&#x27;,
  &#x27;\u3368&#x27;: &#x27;\u0031\u0036\u70B9&#x27;,
  &#x27;\u3369&#x27;: &#x27;\u0031\u0037\u70B9&#x27;,
  &#x27;\u336A&#x27;: &#x27;\u0031\u0038\u70B9&#x27;,
  &#x27;\u336B&#x27;: &#x27;\u0031\u0039\u70B9&#x27;,
  &#x27;\u336C&#x27;: &#x27;\u0032\u0030\u70B9&#x27;,
  &#x27;\u336D&#x27;: &#x27;\u0032\u0031\u70B9&#x27;,
  &#x27;\u336E&#x27;: &#x27;\u0032\u0032\u70B9&#x27;,
  &#x27;\u336F&#x27;: &#x27;\u0032\u0033\u70B9&#x27;,
  &#x27;\u3370&#x27;: &#x27;\u0032\u0034\u70B9&#x27;,
  &#x27;\u33E0&#x27;: &#x27;\u0031\u65E5&#x27;,
  &#x27;\u33E1&#x27;: &#x27;\u0032\u65E5&#x27;,
  &#x27;\u33E2&#x27;: &#x27;\u0033\u65E5&#x27;,
  &#x27;\u33E3&#x27;: &#x27;\u0034\u65E5&#x27;,
  &#x27;\u33E4&#x27;: &#x27;\u0035\u65E5&#x27;,
  &#x27;\u33E5&#x27;: &#x27;\u0036\u65E5&#x27;,
  &#x27;\u33E6&#x27;: &#x27;\u0037\u65E5&#x27;,
  &#x27;\u33E7&#x27;: &#x27;\u0038\u65E5&#x27;,
  &#x27;\u33E8&#x27;: &#x27;\u0039\u65E5&#x27;,
  &#x27;\u33E9&#x27;: &#x27;\u0031\u0030\u65E5&#x27;,
  &#x27;\u33EA&#x27;: &#x27;\u0031\u0031\u65E5&#x27;,
  &#x27;\u33EB&#x27;: &#x27;\u0031\u0032\u65E5&#x27;,
  &#x27;\u33EC&#x27;: &#x27;\u0031\u0033\u65E5&#x27;,
  &#x27;\u33ED&#x27;: &#x27;\u0031\u0034\u65E5&#x27;,
  &#x27;\u33EE&#x27;: &#x27;\u0031\u0035\u65E5&#x27;,
  &#x27;\u33EF&#x27;: &#x27;\u0031\u0036\u65E5&#x27;,
  &#x27;\u33F0&#x27;: &#x27;\u0031\u0037\u65E5&#x27;,
  &#x27;\u33F1&#x27;: &#x27;\u0031\u0038\u65E5&#x27;,
  &#x27;\u33F2&#x27;: &#x27;\u0031\u0039\u65E5&#x27;,
  &#x27;\u33F3&#x27;: &#x27;\u0032\u0030\u65E5&#x27;,
  &#x27;\u33F4&#x27;: &#x27;\u0032\u0031\u65E5&#x27;,
  &#x27;\u33F5&#x27;: &#x27;\u0032\u0032\u65E5&#x27;,
  &#x27;\u33F6&#x27;: &#x27;\u0032\u0033\u65E5&#x27;,
  &#x27;\u33F7&#x27;: &#x27;\u0032\u0034\u65E5&#x27;,
  &#x27;\u33F8&#x27;: &#x27;\u0032\u0035\u65E5&#x27;,
  &#x27;\u33F9&#x27;: &#x27;\u0032\u0036\u65E5&#x27;,
  &#x27;\u33FA&#x27;: &#x27;\u0032\u0037\u65E5&#x27;,
  &#x27;\u33FB&#x27;: &#x27;\u0032\u0038\u65E5&#x27;,
  &#x27;\u33FC&#x27;: &#x27;\u0032\u0039\u65E5&#x27;,
  &#x27;\u33FD&#x27;: &#x27;\u0033\u0030\u65E5&#x27;,
  &#x27;\u33FE&#x27;: &#x27;\u0033\u0031\u65E5&#x27;,
  &#x27;\uFB00&#x27;: &#x27;\u0066\u0066&#x27;,
  &#x27;\uFB01&#x27;: &#x27;\u0066\u0069&#x27;,
  &#x27;\uFB02&#x27;: &#x27;\u0066\u006C&#x27;,
  &#x27;\uFB03&#x27;: &#x27;\u0066\u0066\u0069&#x27;,
  &#x27;\uFB04&#x27;: &#x27;\u0066\u0066\u006C&#x27;,
  &#x27;\uFB05&#x27;: &#x27;\u017F\u0074&#x27;,
  &#x27;\uFB06&#x27;: &#x27;\u0073\u0074&#x27;,
  &#x27;\uFB13&#x27;: &#x27;\u0574\u0576&#x27;,
  &#x27;\uFB14&#x27;: &#x27;\u0574\u0565&#x27;,
  &#x27;\uFB15&#x27;: &#x27;\u0574\u056B&#x27;,
  &#x27;\uFB16&#x27;: &#x27;\u057E\u0576&#x27;,
  &#x27;\uFB17&#x27;: &#x27;\u0574\u056D&#x27;,
  &#x27;\uFB4F&#x27;: &#x27;\u05D0\u05DC&#x27;,
  &#x27;\uFB50&#x27;: &#x27;\u0671&#x27;,
  &#x27;\uFB51&#x27;: &#x27;\u0671&#x27;,
  &#x27;\uFB52&#x27;: &#x27;\u067B&#x27;,
  &#x27;\uFB53&#x27;: &#x27;\u067B&#x27;,
  &#x27;\uFB54&#x27;: &#x27;\u067B&#x27;,
  &#x27;\uFB55&#x27;: &#x27;\u067B&#x27;,
  &#x27;\uFB56&#x27;: &#x27;\u067E&#x27;,
  &#x27;\uFB57&#x27;: &#x27;\u067E&#x27;,
  &#x27;\uFB58&#x27;: &#x27;\u067E&#x27;,
  &#x27;\uFB59&#x27;: &#x27;\u067E&#x27;,
  &#x27;\uFB5A&#x27;: &#x27;\u0680&#x27;,
  &#x27;\uFB5B&#x27;: &#x27;\u0680&#x27;,
  &#x27;\uFB5C&#x27;: &#x27;\u0680&#x27;,
  &#x27;\uFB5D&#x27;: &#x27;\u0680&#x27;,
  &#x27;\uFB5E&#x27;: &#x27;\u067A&#x27;,
  &#x27;\uFB5F&#x27;: &#x27;\u067A&#x27;,
  &#x27;\uFB60&#x27;: &#x27;\u067A&#x27;,
  &#x27;\uFB61&#x27;: &#x27;\u067A&#x27;,
  &#x27;\uFB62&#x27;: &#x27;\u067F&#x27;,
  &#x27;\uFB63&#x27;: &#x27;\u067F&#x27;,
  &#x27;\uFB64&#x27;: &#x27;\u067F&#x27;,
  &#x27;\uFB65&#x27;: &#x27;\u067F&#x27;,
  &#x27;\uFB66&#x27;: &#x27;\u0679&#x27;,
  &#x27;\uFB67&#x27;: &#x27;\u0679&#x27;,
  &#x27;\uFB68&#x27;: &#x27;\u0679&#x27;,
  &#x27;\uFB69&#x27;: &#x27;\u0679&#x27;,
  &#x27;\uFB6A&#x27;: &#x27;\u06A4&#x27;,
  &#x27;\uFB6B&#x27;: &#x27;\u06A4&#x27;,
  &#x27;\uFB6C&#x27;: &#x27;\u06A4&#x27;,
  &#x27;\uFB6D&#x27;: &#x27;\u06A4&#x27;,
  &#x27;\uFB6E&#x27;: &#x27;\u06A6&#x27;,
  &#x27;\uFB6F&#x27;: &#x27;\u06A6&#x27;,
  &#x27;\uFB70&#x27;: &#x27;\u06A6&#x27;,
  &#x27;\uFB71&#x27;: &#x27;\u06A6&#x27;,
  &#x27;\uFB72&#x27;: &#x27;\u0684&#x27;,
  &#x27;\uFB73&#x27;: &#x27;\u0684&#x27;,
  &#x27;\uFB74&#x27;: &#x27;\u0684&#x27;,
  &#x27;\uFB75&#x27;: &#x27;\u0684&#x27;,
  &#x27;\uFB76&#x27;: &#x27;\u0683&#x27;,
  &#x27;\uFB77&#x27;: &#x27;\u0683&#x27;,
  &#x27;\uFB78&#x27;: &#x27;\u0683&#x27;,
  &#x27;\uFB79&#x27;: &#x27;\u0683&#x27;,
  &#x27;\uFB7A&#x27;: &#x27;\u0686&#x27;,
  &#x27;\uFB7B&#x27;: &#x27;\u0686&#x27;,
  &#x27;\uFB7C&#x27;: &#x27;\u0686&#x27;,
  &#x27;\uFB7D&#x27;: &#x27;\u0686&#x27;,
  &#x27;\uFB7E&#x27;: &#x27;\u0687&#x27;,
  &#x27;\uFB7F&#x27;: &#x27;\u0687&#x27;,
  &#x27;\uFB80&#x27;: &#x27;\u0687&#x27;,
  &#x27;\uFB81&#x27;: &#x27;\u0687&#x27;,
  &#x27;\uFB82&#x27;: &#x27;\u068D&#x27;,
  &#x27;\uFB83&#x27;: &#x27;\u068D&#x27;,
  &#x27;\uFB84&#x27;: &#x27;\u068C&#x27;,
  &#x27;\uFB85&#x27;: &#x27;\u068C&#x27;,
  &#x27;\uFB86&#x27;: &#x27;\u068E&#x27;,
  &#x27;\uFB87&#x27;: &#x27;\u068E&#x27;,
  &#x27;\uFB88&#x27;: &#x27;\u0688&#x27;,
  &#x27;\uFB89&#x27;: &#x27;\u0688&#x27;,
  &#x27;\uFB8A&#x27;: &#x27;\u0698&#x27;,
  &#x27;\uFB8B&#x27;: &#x27;\u0698&#x27;,
  &#x27;\uFB8C&#x27;: &#x27;\u0691&#x27;,
  &#x27;\uFB8D&#x27;: &#x27;\u0691&#x27;,
  &#x27;\uFB8E&#x27;: &#x27;\u06A9&#x27;,
  &#x27;\uFB8F&#x27;: &#x27;\u06A9&#x27;,
  &#x27;\uFB90&#x27;: &#x27;\u06A9&#x27;,
  &#x27;\uFB91&#x27;: &#x27;\u06A9&#x27;,
  &#x27;\uFB92&#x27;: &#x27;\u06AF&#x27;,
  &#x27;\uFB93&#x27;: &#x27;\u06AF&#x27;,
  &#x27;\uFB94&#x27;: &#x27;\u06AF&#x27;,
  &#x27;\uFB95&#x27;: &#x27;\u06AF&#x27;,
  &#x27;\uFB96&#x27;: &#x27;\u06B3&#x27;,
  &#x27;\uFB97&#x27;: &#x27;\u06B3&#x27;,
  &#x27;\uFB98&#x27;: &#x27;\u06B3&#x27;,
  &#x27;\uFB99&#x27;: &#x27;\u06B3&#x27;,
  &#x27;\uFB9A&#x27;: &#x27;\u06B1&#x27;,
  &#x27;\uFB9B&#x27;: &#x27;\u06B1&#x27;,
  &#x27;\uFB9C&#x27;: &#x27;\u06B1&#x27;,
  &#x27;\uFB9D&#x27;: &#x27;\u06B1&#x27;,
  &#x27;\uFB9E&#x27;: &#x27;\u06BA&#x27;,
  &#x27;\uFB9F&#x27;: &#x27;\u06BA&#x27;,
  &#x27;\uFBA0&#x27;: &#x27;\u06BB&#x27;,
  &#x27;\uFBA1&#x27;: &#x27;\u06BB&#x27;,
  &#x27;\uFBA2&#x27;: &#x27;\u06BB&#x27;,
  &#x27;\uFBA3&#x27;: &#x27;\u06BB&#x27;,
  &#x27;\uFBA4&#x27;: &#x27;\u06C0&#x27;,
  &#x27;\uFBA5&#x27;: &#x27;\u06C0&#x27;,
  &#x27;\uFBA6&#x27;: &#x27;\u06C1&#x27;,
  &#x27;\uFBA7&#x27;: &#x27;\u06C1&#x27;,
  &#x27;\uFBA8&#x27;: &#x27;\u06C1&#x27;,
  &#x27;\uFBA9&#x27;: &#x27;\u06C1&#x27;,
  &#x27;\uFBAA&#x27;: &#x27;\u06BE&#x27;,
  &#x27;\uFBAB&#x27;: &#x27;\u06BE&#x27;,
  &#x27;\uFBAC&#x27;: &#x27;\u06BE&#x27;,
  &#x27;\uFBAD&#x27;: &#x27;\u06BE&#x27;,
  &#x27;\uFBAE&#x27;: &#x27;\u06D2&#x27;,
  &#x27;\uFBAF&#x27;: &#x27;\u06D2&#x27;,
  &#x27;\uFBB0&#x27;: &#x27;\u06D3&#x27;,
  &#x27;\uFBB1&#x27;: &#x27;\u06D3&#x27;,
  &#x27;\uFBD3&#x27;: &#x27;\u06AD&#x27;,
  &#x27;\uFBD4&#x27;: &#x27;\u06AD&#x27;,
  &#x27;\uFBD5&#x27;: &#x27;\u06AD&#x27;,
  &#x27;\uFBD6&#x27;: &#x27;\u06AD&#x27;,
  &#x27;\uFBD7&#x27;: &#x27;\u06C7&#x27;,
  &#x27;\uFBD8&#x27;: &#x27;\u06C7&#x27;,
  &#x27;\uFBD9&#x27;: &#x27;\u06C6&#x27;,
  &#x27;\uFBDA&#x27;: &#x27;\u06C6&#x27;,
  &#x27;\uFBDB&#x27;: &#x27;\u06C8&#x27;,
  &#x27;\uFBDC&#x27;: &#x27;\u06C8&#x27;,
  &#x27;\uFBDD&#x27;: &#x27;\u0677&#x27;,
  &#x27;\uFBDE&#x27;: &#x27;\u06CB&#x27;,
  &#x27;\uFBDF&#x27;: &#x27;\u06CB&#x27;,
  &#x27;\uFBE0&#x27;: &#x27;\u06C5&#x27;,
  &#x27;\uFBE1&#x27;: &#x27;\u06C5&#x27;,
  &#x27;\uFBE2&#x27;: &#x27;\u06C9&#x27;,
  &#x27;\uFBE3&#x27;: &#x27;\u06C9&#x27;,
  &#x27;\uFBE4&#x27;: &#x27;\u06D0&#x27;,
  &#x27;\uFBE5&#x27;: &#x27;\u06D0&#x27;,
  &#x27;\uFBE6&#x27;: &#x27;\u06D0&#x27;,
  &#x27;\uFBE7&#x27;: &#x27;\u06D0&#x27;,
  &#x27;\uFBE8&#x27;: &#x27;\u0649&#x27;,
  &#x27;\uFBE9&#x27;: &#x27;\u0649&#x27;,
  &#x27;\uFBEA&#x27;: &#x27;\u0626\u0627&#x27;,
  &#x27;\uFBEB&#x27;: &#x27;\u0626\u0627&#x27;,
  &#x27;\uFBEC&#x27;: &#x27;\u0626\u06D5&#x27;,
  &#x27;\uFBED&#x27;: &#x27;\u0626\u06D5&#x27;,
  &#x27;\uFBEE&#x27;: &#x27;\u0626\u0648&#x27;,
  &#x27;\uFBEF&#x27;: &#x27;\u0626\u0648&#x27;,
  &#x27;\uFBF0&#x27;: &#x27;\u0626\u06C7&#x27;,
  &#x27;\uFBF1&#x27;: &#x27;\u0626\u06C7&#x27;,
  &#x27;\uFBF2&#x27;: &#x27;\u0626\u06C6&#x27;,
  &#x27;\uFBF3&#x27;: &#x27;\u0626\u06C6&#x27;,
  &#x27;\uFBF4&#x27;: &#x27;\u0626\u06C8&#x27;,
  &#x27;\uFBF5&#x27;: &#x27;\u0626\u06C8&#x27;,
  &#x27;\uFBF6&#x27;: &#x27;\u0626\u06D0&#x27;,
  &#x27;\uFBF7&#x27;: &#x27;\u0626\u06D0&#x27;,
  &#x27;\uFBF8&#x27;: &#x27;\u0626\u06D0&#x27;,
  &#x27;\uFBF9&#x27;: &#x27;\u0626\u0649&#x27;,
  &#x27;\uFBFA&#x27;: &#x27;\u0626\u0649&#x27;,
  &#x27;\uFBFB&#x27;: &#x27;\u0626\u0649&#x27;,
  &#x27;\uFBFC&#x27;: &#x27;\u06CC&#x27;,
  &#x27;\uFBFD&#x27;: &#x27;\u06CC&#x27;,
  &#x27;\uFBFE&#x27;: &#x27;\u06CC&#x27;,
  &#x27;\uFBFF&#x27;: &#x27;\u06CC&#x27;,
  &#x27;\uFC00&#x27;: &#x27;\u0626\u062C&#x27;,
  &#x27;\uFC01&#x27;: &#x27;\u0626\u062D&#x27;,
  &#x27;\uFC02&#x27;: &#x27;\u0626\u0645&#x27;,
  &#x27;\uFC03&#x27;: &#x27;\u0626\u0649&#x27;,
  &#x27;\uFC04&#x27;: &#x27;\u0626\u064A&#x27;,
  &#x27;\uFC05&#x27;: &#x27;\u0628\u062C&#x27;,
  &#x27;\uFC06&#x27;: &#x27;\u0628\u062D&#x27;,
  &#x27;\uFC07&#x27;: &#x27;\u0628\u062E&#x27;,
  &#x27;\uFC08&#x27;: &#x27;\u0628\u0645&#x27;,
  &#x27;\uFC09&#x27;: &#x27;\u0628\u0649&#x27;,
  &#x27;\uFC0A&#x27;: &#x27;\u0628\u064A&#x27;,
  &#x27;\uFC0B&#x27;: &#x27;\u062A\u062C&#x27;,
  &#x27;\uFC0C&#x27;: &#x27;\u062A\u062D&#x27;,
  &#x27;\uFC0D&#x27;: &#x27;\u062A\u062E&#x27;,
  &#x27;\uFC0E&#x27;: &#x27;\u062A\u0645&#x27;,
  &#x27;\uFC0F&#x27;: &#x27;\u062A\u0649&#x27;,
  &#x27;\uFC10&#x27;: &#x27;\u062A\u064A&#x27;,
  &#x27;\uFC11&#x27;: &#x27;\u062B\u062C&#x27;,
  &#x27;\uFC12&#x27;: &#x27;\u062B\u0645&#x27;,
  &#x27;\uFC13&#x27;: &#x27;\u062B\u0649&#x27;,
  &#x27;\uFC14&#x27;: &#x27;\u062B\u064A&#x27;,
  &#x27;\uFC15&#x27;: &#x27;\u062C\u062D&#x27;,
  &#x27;\uFC16&#x27;: &#x27;\u062C\u0645&#x27;,
  &#x27;\uFC17&#x27;: &#x27;\u062D\u062C&#x27;,
  &#x27;\uFC18&#x27;: &#x27;\u062D\u0645&#x27;,
  &#x27;\uFC19&#x27;: &#x27;\u062E\u062C&#x27;,
  &#x27;\uFC1A&#x27;: &#x27;\u062E\u062D&#x27;,
  &#x27;\uFC1B&#x27;: &#x27;\u062E\u0645&#x27;,
  &#x27;\uFC1C&#x27;: &#x27;\u0633\u062C&#x27;,
  &#x27;\uFC1D&#x27;: &#x27;\u0633\u062D&#x27;,
  &#x27;\uFC1E&#x27;: &#x27;\u0633\u062E&#x27;,
  &#x27;\uFC1F&#x27;: &#x27;\u0633\u0645&#x27;,
  &#x27;\uFC20&#x27;: &#x27;\u0635\u062D&#x27;,
  &#x27;\uFC21&#x27;: &#x27;\u0635\u0645&#x27;,
  &#x27;\uFC22&#x27;: &#x27;\u0636\u062C&#x27;,
  &#x27;\uFC23&#x27;: &#x27;\u0636\u062D&#x27;,
  &#x27;\uFC24&#x27;: &#x27;\u0636\u062E&#x27;,
  &#x27;\uFC25&#x27;: &#x27;\u0636\u0645&#x27;,
  &#x27;\uFC26&#x27;: &#x27;\u0637\u062D&#x27;,
  &#x27;\uFC27&#x27;: &#x27;\u0637\u0645&#x27;,
  &#x27;\uFC28&#x27;: &#x27;\u0638\u0645&#x27;,
  &#x27;\uFC29&#x27;: &#x27;\u0639\u062C&#x27;,
  &#x27;\uFC2A&#x27;: &#x27;\u0639\u0645&#x27;,
  &#x27;\uFC2B&#x27;: &#x27;\u063A\u062C&#x27;,
  &#x27;\uFC2C&#x27;: &#x27;\u063A\u0645&#x27;,
  &#x27;\uFC2D&#x27;: &#x27;\u0641\u062C&#x27;,
  &#x27;\uFC2E&#x27;: &#x27;\u0641\u062D&#x27;,
  &#x27;\uFC2F&#x27;: &#x27;\u0641\u062E&#x27;,
  &#x27;\uFC30&#x27;: &#x27;\u0641\u0645&#x27;,
  &#x27;\uFC31&#x27;: &#x27;\u0641\u0649&#x27;,
  &#x27;\uFC32&#x27;: &#x27;\u0641\u064A&#x27;,
  &#x27;\uFC33&#x27;: &#x27;\u0642\u062D&#x27;,
  &#x27;\uFC34&#x27;: &#x27;\u0642\u0645&#x27;,
  &#x27;\uFC35&#x27;: &#x27;\u0642\u0649&#x27;,
  &#x27;\uFC36&#x27;: &#x27;\u0642\u064A&#x27;,
  &#x27;\uFC37&#x27;: &#x27;\u0643\u0627&#x27;,
  &#x27;\uFC38&#x27;: &#x27;\u0643\u062C&#x27;,
  &#x27;\uFC39&#x27;: &#x27;\u0643\u062D&#x27;,
  &#x27;\uFC3A&#x27;: &#x27;\u0643\u062E&#x27;,
  &#x27;\uFC3B&#x27;: &#x27;\u0643\u0644&#x27;,
  &#x27;\uFC3C&#x27;: &#x27;\u0643\u0645&#x27;,
  &#x27;\uFC3D&#x27;: &#x27;\u0643\u0649&#x27;,
  &#x27;\uFC3E&#x27;: &#x27;\u0643\u064A&#x27;,
  &#x27;\uFC3F&#x27;: &#x27;\u0644\u062C&#x27;,
  &#x27;\uFC40&#x27;: &#x27;\u0644\u062D&#x27;,
  &#x27;\uFC41&#x27;: &#x27;\u0644\u062E&#x27;,
  &#x27;\uFC42&#x27;: &#x27;\u0644\u0645&#x27;,
  &#x27;\uFC43&#x27;: &#x27;\u0644\u0649&#x27;,
  &#x27;\uFC44&#x27;: &#x27;\u0644\u064A&#x27;,
  &#x27;\uFC45&#x27;: &#x27;\u0645\u062C&#x27;,
  &#x27;\uFC46&#x27;: &#x27;\u0645\u062D&#x27;,
  &#x27;\uFC47&#x27;: &#x27;\u0645\u062E&#x27;,
  &#x27;\uFC48&#x27;: &#x27;\u0645\u0645&#x27;,
  &#x27;\uFC49&#x27;: &#x27;\u0645\u0649&#x27;,
  &#x27;\uFC4A&#x27;: &#x27;\u0645\u064A&#x27;,
  &#x27;\uFC4B&#x27;: &#x27;\u0646\u062C&#x27;,
  &#x27;\uFC4C&#x27;: &#x27;\u0646\u062D&#x27;,
  &#x27;\uFC4D&#x27;: &#x27;\u0646\u062E&#x27;,
  &#x27;\uFC4E&#x27;: &#x27;\u0646\u0645&#x27;,
  &#x27;\uFC4F&#x27;: &#x27;\u0646\u0649&#x27;,
  &#x27;\uFC50&#x27;: &#x27;\u0646\u064A&#x27;,
  &#x27;\uFC51&#x27;: &#x27;\u0647\u062C&#x27;,
  &#x27;\uFC52&#x27;: &#x27;\u0647\u0645&#x27;,
  &#x27;\uFC53&#x27;: &#x27;\u0647\u0649&#x27;,
  &#x27;\uFC54&#x27;: &#x27;\u0647\u064A&#x27;,
  &#x27;\uFC55&#x27;: &#x27;\u064A\u062C&#x27;,
  &#x27;\uFC56&#x27;: &#x27;\u064A\u062D&#x27;,
  &#x27;\uFC57&#x27;: &#x27;\u064A\u062E&#x27;,
  &#x27;\uFC58&#x27;: &#x27;\u064A\u0645&#x27;,
  &#x27;\uFC59&#x27;: &#x27;\u064A\u0649&#x27;,
  &#x27;\uFC5A&#x27;: &#x27;\u064A\u064A&#x27;,
  &#x27;\uFC5B&#x27;: &#x27;\u0630\u0670&#x27;,
  &#x27;\uFC5C&#x27;: &#x27;\u0631\u0670&#x27;,
  &#x27;\uFC5D&#x27;: &#x27;\u0649\u0670&#x27;,
  &#x27;\uFC5E&#x27;: &#x27;\u0020\u064C\u0651&#x27;,
  &#x27;\uFC5F&#x27;: &#x27;\u0020\u064D\u0651&#x27;,
  &#x27;\uFC60&#x27;: &#x27;\u0020\u064E\u0651&#x27;,
  &#x27;\uFC61&#x27;: &#x27;\u0020\u064F\u0651&#x27;,
  &#x27;\uFC62&#x27;: &#x27;\u0020\u0650\u0651&#x27;,
  &#x27;\uFC63&#x27;: &#x27;\u0020\u0651\u0670&#x27;,
  &#x27;\uFC64&#x27;: &#x27;\u0626\u0631&#x27;,
  &#x27;\uFC65&#x27;: &#x27;\u0626\u0632&#x27;,
  &#x27;\uFC66&#x27;: &#x27;\u0626\u0645&#x27;,
  &#x27;\uFC67&#x27;: &#x27;\u0626\u0646&#x27;,
  &#x27;\uFC68&#x27;: &#x27;\u0626\u0649&#x27;,
  &#x27;\uFC69&#x27;: &#x27;\u0626\u064A&#x27;,
  &#x27;\uFC6A&#x27;: &#x27;\u0628\u0631&#x27;,
  &#x27;\uFC6B&#x27;: &#x27;\u0628\u0632&#x27;,
  &#x27;\uFC6C&#x27;: &#x27;\u0628\u0645&#x27;,
  &#x27;\uFC6D&#x27;: &#x27;\u0628\u0646&#x27;,
  &#x27;\uFC6E&#x27;: &#x27;\u0628\u0649&#x27;,
  &#x27;\uFC6F&#x27;: &#x27;\u0628\u064A&#x27;,
  &#x27;\uFC70&#x27;: &#x27;\u062A\u0631&#x27;,
  &#x27;\uFC71&#x27;: &#x27;\u062A\u0632&#x27;,
  &#x27;\uFC72&#x27;: &#x27;\u062A\u0645&#x27;,
  &#x27;\uFC73&#x27;: &#x27;\u062A\u0646&#x27;,
  &#x27;\uFC74&#x27;: &#x27;\u062A\u0649&#x27;,
  &#x27;\uFC75&#x27;: &#x27;\u062A\u064A&#x27;,
  &#x27;\uFC76&#x27;: &#x27;\u062B\u0631&#x27;,
  &#x27;\uFC77&#x27;: &#x27;\u062B\u0632&#x27;,
  &#x27;\uFC78&#x27;: &#x27;\u062B\u0645&#x27;,
  &#x27;\uFC79&#x27;: &#x27;\u062B\u0646&#x27;,
  &#x27;\uFC7A&#x27;: &#x27;\u062B\u0649&#x27;,
  &#x27;\uFC7B&#x27;: &#x27;\u062B\u064A&#x27;,
  &#x27;\uFC7C&#x27;: &#x27;\u0641\u0649&#x27;,
  &#x27;\uFC7D&#x27;: &#x27;\u0641\u064A&#x27;,
  &#x27;\uFC7E&#x27;: &#x27;\u0642\u0649&#x27;,
  &#x27;\uFC7F&#x27;: &#x27;\u0642\u064A&#x27;,
  &#x27;\uFC80&#x27;: &#x27;\u0643\u0627&#x27;,
  &#x27;\uFC81&#x27;: &#x27;\u0643\u0644&#x27;,
  &#x27;\uFC82&#x27;: &#x27;\u0643\u0645&#x27;,
  &#x27;\uFC83&#x27;: &#x27;\u0643\u0649&#x27;,
  &#x27;\uFC84&#x27;: &#x27;\u0643\u064A&#x27;,
  &#x27;\uFC85&#x27;: &#x27;\u0644\u0645&#x27;,
  &#x27;\uFC86&#x27;: &#x27;\u0644\u0649&#x27;,
  &#x27;\uFC87&#x27;: &#x27;\u0644\u064A&#x27;,
  &#x27;\uFC88&#x27;: &#x27;\u0645\u0627&#x27;,
  &#x27;\uFC89&#x27;: &#x27;\u0645\u0645&#x27;,
  &#x27;\uFC8A&#x27;: &#x27;\u0646\u0631&#x27;,
  &#x27;\uFC8B&#x27;: &#x27;\u0646\u0632&#x27;,
  &#x27;\uFC8C&#x27;: &#x27;\u0646\u0645&#x27;,
  &#x27;\uFC8D&#x27;: &#x27;\u0646\u0646&#x27;,
  &#x27;\uFC8E&#x27;: &#x27;\u0646\u0649&#x27;,
  &#x27;\uFC8F&#x27;: &#x27;\u0646\u064A&#x27;,
  &#x27;\uFC90&#x27;: &#x27;\u0649\u0670&#x27;,
  &#x27;\uFC91&#x27;: &#x27;\u064A\u0631&#x27;,
  &#x27;\uFC92&#x27;: &#x27;\u064A\u0632&#x27;,
  &#x27;\uFC93&#x27;: &#x27;\u064A\u0645&#x27;,
  &#x27;\uFC94&#x27;: &#x27;\u064A\u0646&#x27;,
  &#x27;\uFC95&#x27;: &#x27;\u064A\u0649&#x27;,
  &#x27;\uFC96&#x27;: &#x27;\u064A\u064A&#x27;,
  &#x27;\uFC97&#x27;: &#x27;\u0626\u062C&#x27;,
  &#x27;\uFC98&#x27;: &#x27;\u0626\u062D&#x27;,
  &#x27;\uFC99&#x27;: &#x27;\u0626\u062E&#x27;,
  &#x27;\uFC9A&#x27;: &#x27;\u0626\u0645&#x27;,
  &#x27;\uFC9B&#x27;: &#x27;\u0626\u0647&#x27;,
  &#x27;\uFC9C&#x27;: &#x27;\u0628\u062C&#x27;,
  &#x27;\uFC9D&#x27;: &#x27;\u0628\u062D&#x27;,
  &#x27;\uFC9E&#x27;: &#x27;\u0628\u062E&#x27;,
  &#x27;\uFC9F&#x27;: &#x27;\u0628\u0645&#x27;,
  &#x27;\uFCA0&#x27;: &#x27;\u0628\u0647&#x27;,
  &#x27;\uFCA1&#x27;: &#x27;\u062A\u062C&#x27;,
  &#x27;\uFCA2&#x27;: &#x27;\u062A\u062D&#x27;,
  &#x27;\uFCA3&#x27;: &#x27;\u062A\u062E&#x27;,
  &#x27;\uFCA4&#x27;: &#x27;\u062A\u0645&#x27;,
  &#x27;\uFCA5&#x27;: &#x27;\u062A\u0647&#x27;,
  &#x27;\uFCA6&#x27;: &#x27;\u062B\u0645&#x27;,
  &#x27;\uFCA7&#x27;: &#x27;\u062C\u062D&#x27;,
  &#x27;\uFCA8&#x27;: &#x27;\u062C\u0645&#x27;,
  &#x27;\uFCA9&#x27;: &#x27;\u062D\u062C&#x27;,
  &#x27;\uFCAA&#x27;: &#x27;\u062D\u0645&#x27;,
  &#x27;\uFCAB&#x27;: &#x27;\u062E\u062C&#x27;,
  &#x27;\uFCAC&#x27;: &#x27;\u062E\u0645&#x27;,
  &#x27;\uFCAD&#x27;: &#x27;\u0633\u062C&#x27;,
  &#x27;\uFCAE&#x27;: &#x27;\u0633\u062D&#x27;,
  &#x27;\uFCAF&#x27;: &#x27;\u0633\u062E&#x27;,
  &#x27;\uFCB0&#x27;: &#x27;\u0633\u0645&#x27;,
  &#x27;\uFCB1&#x27;: &#x27;\u0635\u062D&#x27;,
  &#x27;\uFCB2&#x27;: &#x27;\u0635\u062E&#x27;,
  &#x27;\uFCB3&#x27;: &#x27;\u0635\u0645&#x27;,
  &#x27;\uFCB4&#x27;: &#x27;\u0636\u062C&#x27;,
  &#x27;\uFCB5&#x27;: &#x27;\u0636\u062D&#x27;,
  &#x27;\uFCB6&#x27;: &#x27;\u0636\u062E&#x27;,
  &#x27;\uFCB7&#x27;: &#x27;\u0636\u0645&#x27;,
  &#x27;\uFCB8&#x27;: &#x27;\u0637\u062D&#x27;,
  &#x27;\uFCB9&#x27;: &#x27;\u0638\u0645&#x27;,
  &#x27;\uFCBA&#x27;: &#x27;\u0639\u062C&#x27;,
  &#x27;\uFCBB&#x27;: &#x27;\u0639\u0645&#x27;,
  &#x27;\uFCBC&#x27;: &#x27;\u063A\u062C&#x27;,
  &#x27;\uFCBD&#x27;: &#x27;\u063A\u0645&#x27;,
  &#x27;\uFCBE&#x27;: &#x27;\u0641\u062C&#x27;,
  &#x27;\uFCBF&#x27;: &#x27;\u0641\u062D&#x27;,
  &#x27;\uFCC0&#x27;: &#x27;\u0641\u062E&#x27;,
  &#x27;\uFCC1&#x27;: &#x27;\u0641\u0645&#x27;,
  &#x27;\uFCC2&#x27;: &#x27;\u0642\u062D&#x27;,
  &#x27;\uFCC3&#x27;: &#x27;\u0642\u0645&#x27;,
  &#x27;\uFCC4&#x27;: &#x27;\u0643\u062C&#x27;,
  &#x27;\uFCC5&#x27;: &#x27;\u0643\u062D&#x27;,
  &#x27;\uFCC6&#x27;: &#x27;\u0643\u062E&#x27;,
  &#x27;\uFCC7&#x27;: &#x27;\u0643\u0644&#x27;,
  &#x27;\uFCC8&#x27;: &#x27;\u0643\u0645&#x27;,
  &#x27;\uFCC9&#x27;: &#x27;\u0644\u062C&#x27;,
  &#x27;\uFCCA&#x27;: &#x27;\u0644\u062D&#x27;,
  &#x27;\uFCCB&#x27;: &#x27;\u0644\u062E&#x27;,
  &#x27;\uFCCC&#x27;: &#x27;\u0644\u0645&#x27;,
  &#x27;\uFCCD&#x27;: &#x27;\u0644\u0647&#x27;,
  &#x27;\uFCCE&#x27;: &#x27;\u0645\u062C&#x27;,
  &#x27;\uFCCF&#x27;: &#x27;\u0645\u062D&#x27;,
  &#x27;\uFCD0&#x27;: &#x27;\u0645\u062E&#x27;,
  &#x27;\uFCD1&#x27;: &#x27;\u0645\u0645&#x27;,
  &#x27;\uFCD2&#x27;: &#x27;\u0646\u062C&#x27;,
  &#x27;\uFCD3&#x27;: &#x27;\u0646\u062D&#x27;,
  &#x27;\uFCD4&#x27;: &#x27;\u0646\u062E&#x27;,
  &#x27;\uFCD5&#x27;: &#x27;\u0646\u0645&#x27;,
  &#x27;\uFCD6&#x27;: &#x27;\u0646\u0647&#x27;,
  &#x27;\uFCD7&#x27;: &#x27;\u0647\u062C&#x27;,
  &#x27;\uFCD8&#x27;: &#x27;\u0647\u0645&#x27;,
  &#x27;\uFCD9&#x27;: &#x27;\u0647\u0670&#x27;,
  &#x27;\uFCDA&#x27;: &#x27;\u064A\u062C&#x27;,
  &#x27;\uFCDB&#x27;: &#x27;\u064A\u062D&#x27;,
  &#x27;\uFCDC&#x27;: &#x27;\u064A\u062E&#x27;,
  &#x27;\uFCDD&#x27;: &#x27;\u064A\u0645&#x27;,
  &#x27;\uFCDE&#x27;: &#x27;\u064A\u0647&#x27;,
  &#x27;\uFCDF&#x27;: &#x27;\u0626\u0645&#x27;,
  &#x27;\uFCE0&#x27;: &#x27;\u0626\u0647&#x27;,
  &#x27;\uFCE1&#x27;: &#x27;\u0628\u0645&#x27;,
  &#x27;\uFCE2&#x27;: &#x27;\u0628\u0647&#x27;,
  &#x27;\uFCE3&#x27;: &#x27;\u062A\u0645&#x27;,
  &#x27;\uFCE4&#x27;: &#x27;\u062A\u0647&#x27;,
  &#x27;\uFCE5&#x27;: &#x27;\u062B\u0645&#x27;,
  &#x27;\uFCE6&#x27;: &#x27;\u062B\u0647&#x27;,
  &#x27;\uFCE7&#x27;: &#x27;\u0633\u0645&#x27;,
  &#x27;\uFCE8&#x27;: &#x27;\u0633\u0647&#x27;,
  &#x27;\uFCE9&#x27;: &#x27;\u0634\u0645&#x27;,
  &#x27;\uFCEA&#x27;: &#x27;\u0634\u0647&#x27;,
  &#x27;\uFCEB&#x27;: &#x27;\u0643\u0644&#x27;,
  &#x27;\uFCEC&#x27;: &#x27;\u0643\u0645&#x27;,
  &#x27;\uFCED&#x27;: &#x27;\u0644\u0645&#x27;,
  &#x27;\uFCEE&#x27;: &#x27;\u0646\u0645&#x27;,
  &#x27;\uFCEF&#x27;: &#x27;\u0646\u0647&#x27;,
  &#x27;\uFCF0&#x27;: &#x27;\u064A\u0645&#x27;,
  &#x27;\uFCF1&#x27;: &#x27;\u064A\u0647&#x27;,
  &#x27;\uFCF2&#x27;: &#x27;\u0640\u064E\u0651&#x27;,
  &#x27;\uFCF3&#x27;: &#x27;\u0640\u064F\u0651&#x27;,
  &#x27;\uFCF4&#x27;: &#x27;\u0640\u0650\u0651&#x27;,
  &#x27;\uFCF5&#x27;: &#x27;\u0637\u0649&#x27;,
  &#x27;\uFCF6&#x27;: &#x27;\u0637\u064A&#x27;,
  &#x27;\uFCF7&#x27;: &#x27;\u0639\u0649&#x27;,
  &#x27;\uFCF8&#x27;: &#x27;\u0639\u064A&#x27;,
  &#x27;\uFCF9&#x27;: &#x27;\u063A\u0649&#x27;,
  &#x27;\uFCFA&#x27;: &#x27;\u063A\u064A&#x27;,
  &#x27;\uFCFB&#x27;: &#x27;\u0633\u0649&#x27;,
  &#x27;\uFCFC&#x27;: &#x27;\u0633\u064A&#x27;,
  &#x27;\uFCFD&#x27;: &#x27;\u0634\u0649&#x27;,
  &#x27;\uFCFE&#x27;: &#x27;\u0634\u064A&#x27;,
  &#x27;\uFCFF&#x27;: &#x27;\u062D\u0649&#x27;,
  &#x27;\uFD00&#x27;: &#x27;\u062D\u064A&#x27;,
  &#x27;\uFD01&#x27;: &#x27;\u062C\u0649&#x27;,
  &#x27;\uFD02&#x27;: &#x27;\u062C\u064A&#x27;,
  &#x27;\uFD03&#x27;: &#x27;\u062E\u0649&#x27;,
  &#x27;\uFD04&#x27;: &#x27;\u062E\u064A&#x27;,
  &#x27;\uFD05&#x27;: &#x27;\u0635\u0649&#x27;,
  &#x27;\uFD06&#x27;: &#x27;\u0635\u064A&#x27;,
  &#x27;\uFD07&#x27;: &#x27;\u0636\u0649&#x27;,
  &#x27;\uFD08&#x27;: &#x27;\u0636\u064A&#x27;,
  &#x27;\uFD09&#x27;: &#x27;\u0634\u062C&#x27;,
  &#x27;\uFD0A&#x27;: &#x27;\u0634\u062D&#x27;,
  &#x27;\uFD0B&#x27;: &#x27;\u0634\u062E&#x27;,
  &#x27;\uFD0C&#x27;: &#x27;\u0634\u0645&#x27;,
  &#x27;\uFD0D&#x27;: &#x27;\u0634\u0631&#x27;,
  &#x27;\uFD0E&#x27;: &#x27;\u0633\u0631&#x27;,
  &#x27;\uFD0F&#x27;: &#x27;\u0635\u0631&#x27;,
  &#x27;\uFD10&#x27;: &#x27;\u0636\u0631&#x27;,
  &#x27;\uFD11&#x27;: &#x27;\u0637\u0649&#x27;,
  &#x27;\uFD12&#x27;: &#x27;\u0637\u064A&#x27;,
  &#x27;\uFD13&#x27;: &#x27;\u0639\u0649&#x27;,
  &#x27;\uFD14&#x27;: &#x27;\u0639\u064A&#x27;,
  &#x27;\uFD15&#x27;: &#x27;\u063A\u0649&#x27;,
  &#x27;\uFD16&#x27;: &#x27;\u063A\u064A&#x27;,
  &#x27;\uFD17&#x27;: &#x27;\u0633\u0649&#x27;,
  &#x27;\uFD18&#x27;: &#x27;\u0633\u064A&#x27;,
  &#x27;\uFD19&#x27;: &#x27;\u0634\u0649&#x27;,
  &#x27;\uFD1A&#x27;: &#x27;\u0634\u064A&#x27;,
  &#x27;\uFD1B&#x27;: &#x27;\u062D\u0649&#x27;,
  &#x27;\uFD1C&#x27;: &#x27;\u062D\u064A&#x27;,
  &#x27;\uFD1D&#x27;: &#x27;\u062C\u0649&#x27;,
  &#x27;\uFD1E&#x27;: &#x27;\u062C\u064A&#x27;,
  &#x27;\uFD1F&#x27;: &#x27;\u062E\u0649&#x27;,
  &#x27;\uFD20&#x27;: &#x27;\u062E\u064A&#x27;,
  &#x27;\uFD21&#x27;: &#x27;\u0635\u0649&#x27;,
  &#x27;\uFD22&#x27;: &#x27;\u0635\u064A&#x27;,
  &#x27;\uFD23&#x27;: &#x27;\u0636\u0649&#x27;,
  &#x27;\uFD24&#x27;: &#x27;\u0636\u064A&#x27;,
  &#x27;\uFD25&#x27;: &#x27;\u0634\u062C&#x27;,
  &#x27;\uFD26&#x27;: &#x27;\u0634\u062D&#x27;,
  &#x27;\uFD27&#x27;: &#x27;\u0634\u062E&#x27;,
  &#x27;\uFD28&#x27;: &#x27;\u0634\u0645&#x27;,
  &#x27;\uFD29&#x27;: &#x27;\u0634\u0631&#x27;,
  &#x27;\uFD2A&#x27;: &#x27;\u0633\u0631&#x27;,
  &#x27;\uFD2B&#x27;: &#x27;\u0635\u0631&#x27;,
  &#x27;\uFD2C&#x27;: &#x27;\u0636\u0631&#x27;,
  &#x27;\uFD2D&#x27;: &#x27;\u0634\u062C&#x27;,
  &#x27;\uFD2E&#x27;: &#x27;\u0634\u062D&#x27;,
  &#x27;\uFD2F&#x27;: &#x27;\u0634\u062E&#x27;,
  &#x27;\uFD30&#x27;: &#x27;\u0634\u0645&#x27;,
  &#x27;\uFD31&#x27;: &#x27;\u0633\u0647&#x27;,
  &#x27;\uFD32&#x27;: &#x27;\u0634\u0647&#x27;,
  &#x27;\uFD33&#x27;: &#x27;\u0637\u0645&#x27;,
  &#x27;\uFD34&#x27;: &#x27;\u0633\u062C&#x27;,
  &#x27;\uFD35&#x27;: &#x27;\u0633\u062D&#x27;,
  &#x27;\uFD36&#x27;: &#x27;\u0633\u062E&#x27;,
  &#x27;\uFD37&#x27;: &#x27;\u0634\u062C&#x27;,
  &#x27;\uFD38&#x27;: &#x27;\u0634\u062D&#x27;,
  &#x27;\uFD39&#x27;: &#x27;\u0634\u062E&#x27;,
  &#x27;\uFD3A&#x27;: &#x27;\u0637\u0645&#x27;,
  &#x27;\uFD3B&#x27;: &#x27;\u0638\u0645&#x27;,
  &#x27;\uFD3C&#x27;: &#x27;\u0627\u064B&#x27;,
  &#x27;\uFD3D&#x27;: &#x27;\u0627\u064B&#x27;,
  &#x27;\uFD50&#x27;: &#x27;\u062A\u062C\u0645&#x27;,
  &#x27;\uFD51&#x27;: &#x27;\u062A\u062D\u062C&#x27;,
  &#x27;\uFD52&#x27;: &#x27;\u062A\u062D\u062C&#x27;,
  &#x27;\uFD53&#x27;: &#x27;\u062A\u062D\u0645&#x27;,
  &#x27;\uFD54&#x27;: &#x27;\u062A\u062E\u0645&#x27;,
  &#x27;\uFD55&#x27;: &#x27;\u062A\u0645\u062C&#x27;,
  &#x27;\uFD56&#x27;: &#x27;\u062A\u0645\u062D&#x27;,
  &#x27;\uFD57&#x27;: &#x27;\u062A\u0645\u062E&#x27;,
  &#x27;\uFD58&#x27;: &#x27;\u062C\u0645\u062D&#x27;,
  &#x27;\uFD59&#x27;: &#x27;\u062C\u0645\u062D&#x27;,
  &#x27;\uFD5A&#x27;: &#x27;\u062D\u0645\u064A&#x27;,
  &#x27;\uFD5B&#x27;: &#x27;\u062D\u0645\u0649&#x27;,
  &#x27;\uFD5C&#x27;: &#x27;\u0633\u062D\u062C&#x27;,
  &#x27;\uFD5D&#x27;: &#x27;\u0633\u062C\u062D&#x27;,
  &#x27;\uFD5E&#x27;: &#x27;\u0633\u062C\u0649&#x27;,
  &#x27;\uFD5F&#x27;: &#x27;\u0633\u0645\u062D&#x27;,
  &#x27;\uFD60&#x27;: &#x27;\u0633\u0645\u062D&#x27;,
  &#x27;\uFD61&#x27;: &#x27;\u0633\u0645\u062C&#x27;,
  &#x27;\uFD62&#x27;: &#x27;\u0633\u0645\u0645&#x27;,
  &#x27;\uFD63&#x27;: &#x27;\u0633\u0645\u0645&#x27;,
  &#x27;\uFD64&#x27;: &#x27;\u0635\u062D\u062D&#x27;,
  &#x27;\uFD65&#x27;: &#x27;\u0635\u062D\u062D&#x27;,
  &#x27;\uFD66&#x27;: &#x27;\u0635\u0645\u0645&#x27;,
  &#x27;\uFD67&#x27;: &#x27;\u0634\u062D\u0645&#x27;,
  &#x27;\uFD68&#x27;: &#x27;\u0634\u062D\u0645&#x27;,
  &#x27;\uFD69&#x27;: &#x27;\u0634\u062C\u064A&#x27;,
  &#x27;\uFD6A&#x27;: &#x27;\u0634\u0645\u062E&#x27;,
  &#x27;\uFD6B&#x27;: &#x27;\u0634\u0645\u062E&#x27;,
  &#x27;\uFD6C&#x27;: &#x27;\u0634\u0645\u0645&#x27;,
  &#x27;\uFD6D&#x27;: &#x27;\u0634\u0645\u0645&#x27;,
  &#x27;\uFD6E&#x27;: &#x27;\u0636\u062D\u0649&#x27;,
  &#x27;\uFD6F&#x27;: &#x27;\u0636\u062E\u0645&#x27;,
  &#x27;\uFD70&#x27;: &#x27;\u0636\u062E\u0645&#x27;,
  &#x27;\uFD71&#x27;: &#x27;\u0637\u0645\u062D&#x27;,
  &#x27;\uFD72&#x27;: &#x27;\u0637\u0645\u062D&#x27;,
  &#x27;\uFD73&#x27;: &#x27;\u0637\u0645\u0645&#x27;,
  &#x27;\uFD74&#x27;: &#x27;\u0637\u0645\u064A&#x27;,
  &#x27;\uFD75&#x27;: &#x27;\u0639\u062C\u0645&#x27;,
  &#x27;\uFD76&#x27;: &#x27;\u0639\u0645\u0645&#x27;,
  &#x27;\uFD77&#x27;: &#x27;\u0639\u0645\u0645&#x27;,
  &#x27;\uFD78&#x27;: &#x27;\u0639\u0645\u0649&#x27;,
  &#x27;\uFD79&#x27;: &#x27;\u063A\u0645\u0645&#x27;,
  &#x27;\uFD7A&#x27;: &#x27;\u063A\u0645\u064A&#x27;,
  &#x27;\uFD7B&#x27;: &#x27;\u063A\u0645\u0649&#x27;,
  &#x27;\uFD7C&#x27;: &#x27;\u0641\u062E\u0645&#x27;,
  &#x27;\uFD7D&#x27;: &#x27;\u0641\u062E\u0645&#x27;,
  &#x27;\uFD7E&#x27;: &#x27;\u0642\u0645\u062D&#x27;,
  &#x27;\uFD7F&#x27;: &#x27;\u0642\u0645\u0645&#x27;,
  &#x27;\uFD80&#x27;: &#x27;\u0644\u062D\u0645&#x27;,
  &#x27;\uFD81&#x27;: &#x27;\u0644\u062D\u064A&#x27;,
  &#x27;\uFD82&#x27;: &#x27;\u0644\u062D\u0649&#x27;,
  &#x27;\uFD83&#x27;: &#x27;\u0644\u062C\u062C&#x27;,
  &#x27;\uFD84&#x27;: &#x27;\u0644\u062C\u062C&#x27;,
  &#x27;\uFD85&#x27;: &#x27;\u0644\u062E\u0645&#x27;,
  &#x27;\uFD86&#x27;: &#x27;\u0644\u062E\u0645&#x27;,
  &#x27;\uFD87&#x27;: &#x27;\u0644\u0645\u062D&#x27;,
  &#x27;\uFD88&#x27;: &#x27;\u0644\u0645\u062D&#x27;,
  &#x27;\uFD89&#x27;: &#x27;\u0645\u062D\u062C&#x27;,
  &#x27;\uFD8A&#x27;: &#x27;\u0645\u062D\u0645&#x27;,
  &#x27;\uFD8B&#x27;: &#x27;\u0645\u062D\u064A&#x27;,
  &#x27;\uFD8C&#x27;: &#x27;\u0645\u062C\u062D&#x27;,
  &#x27;\uFD8D&#x27;: &#x27;\u0645\u062C\u0645&#x27;,
  &#x27;\uFD8E&#x27;: &#x27;\u0645\u062E\u062C&#x27;,
  &#x27;\uFD8F&#x27;: &#x27;\u0645\u062E\u0645&#x27;,
  &#x27;\uFD92&#x27;: &#x27;\u0645\u062C\u062E&#x27;,
  &#x27;\uFD93&#x27;: &#x27;\u0647\u0645\u062C&#x27;,
  &#x27;\uFD94&#x27;: &#x27;\u0647\u0645\u0645&#x27;,
  &#x27;\uFD95&#x27;: &#x27;\u0646\u062D\u0645&#x27;,
  &#x27;\uFD96&#x27;: &#x27;\u0646\u062D\u0649&#x27;,
  &#x27;\uFD97&#x27;: &#x27;\u0646\u062C\u0645&#x27;,
  &#x27;\uFD98&#x27;: &#x27;\u0646\u062C\u0645&#x27;,
  &#x27;\uFD99&#x27;: &#x27;\u0646\u062C\u0649&#x27;,
  &#x27;\uFD9A&#x27;: &#x27;\u0646\u0645\u064A&#x27;,
  &#x27;\uFD9B&#x27;: &#x27;\u0646\u0645\u0649&#x27;,
  &#x27;\uFD9C&#x27;: &#x27;\u064A\u0645\u0645&#x27;,
  &#x27;\uFD9D&#x27;: &#x27;\u064A\u0645\u0645&#x27;,
  &#x27;\uFD9E&#x27;: &#x27;\u0628\u062E\u064A&#x27;,
  &#x27;\uFD9F&#x27;: &#x27;\u062A\u062C\u064A&#x27;,
  &#x27;\uFDA0&#x27;: &#x27;\u062A\u062C\u0649&#x27;,
  &#x27;\uFDA1&#x27;: &#x27;\u062A\u062E\u064A&#x27;,
  &#x27;\uFDA2&#x27;: &#x27;\u062A\u062E\u0649&#x27;,
  &#x27;\uFDA3&#x27;: &#x27;\u062A\u0645\u064A&#x27;,
  &#x27;\uFDA4&#x27;: &#x27;\u062A\u0645\u0649&#x27;,
  &#x27;\uFDA5&#x27;: &#x27;\u062C\u0645\u064A&#x27;,
  &#x27;\uFDA6&#x27;: &#x27;\u062C\u062D\u0649&#x27;,
  &#x27;\uFDA7&#x27;: &#x27;\u062C\u0645\u0649&#x27;,
  &#x27;\uFDA8&#x27;: &#x27;\u0633\u062E\u0649&#x27;,
  &#x27;\uFDA9&#x27;: &#x27;\u0635\u062D\u064A&#x27;,
  &#x27;\uFDAA&#x27;: &#x27;\u0634\u062D\u064A&#x27;,
  &#x27;\uFDAB&#x27;: &#x27;\u0636\u062D\u064A&#x27;,
  &#x27;\uFDAC&#x27;: &#x27;\u0644\u062C\u064A&#x27;,
  &#x27;\uFDAD&#x27;: &#x27;\u0644\u0645\u064A&#x27;,
  &#x27;\uFDAE&#x27;: &#x27;\u064A\u062D\u064A&#x27;,
  &#x27;\uFDAF&#x27;: &#x27;\u064A\u062C\u064A&#x27;,
  &#x27;\uFDB0&#x27;: &#x27;\u064A\u0645\u064A&#x27;,
  &#x27;\uFDB1&#x27;: &#x27;\u0645\u0645\u064A&#x27;,
  &#x27;\uFDB2&#x27;: &#x27;\u0642\u0645\u064A&#x27;,
  &#x27;\uFDB3&#x27;: &#x27;\u0646\u062D\u064A&#x27;,
  &#x27;\uFDB4&#x27;: &#x27;\u0642\u0645\u062D&#x27;,
  &#x27;\uFDB5&#x27;: &#x27;\u0644\u062D\u0645&#x27;,
  &#x27;\uFDB6&#x27;: &#x27;\u0639\u0645\u064A&#x27;,
  &#x27;\uFDB7&#x27;: &#x27;\u0643\u0645\u064A&#x27;,
  &#x27;\uFDB8&#x27;: &#x27;\u0646\u062C\u062D&#x27;,
  &#x27;\uFDB9&#x27;: &#x27;\u0645\u062E\u064A&#x27;,
  &#x27;\uFDBA&#x27;: &#x27;\u0644\u062C\u0645&#x27;,
  &#x27;\uFDBB&#x27;: &#x27;\u0643\u0645\u0645&#x27;,
  &#x27;\uFDBC&#x27;: &#x27;\u0644\u062C\u0645&#x27;,
  &#x27;\uFDBD&#x27;: &#x27;\u0646\u062C\u062D&#x27;,
  &#x27;\uFDBE&#x27;: &#x27;\u062C\u062D\u064A&#x27;,
  &#x27;\uFDBF&#x27;: &#x27;\u062D\u062C\u064A&#x27;,
  &#x27;\uFDC0&#x27;: &#x27;\u0645\u062C\u064A&#x27;,
  &#x27;\uFDC1&#x27;: &#x27;\u0641\u0645\u064A&#x27;,
  &#x27;\uFDC2&#x27;: &#x27;\u0628\u062D\u064A&#x27;,
  &#x27;\uFDC3&#x27;: &#x27;\u0643\u0645\u0645&#x27;,
  &#x27;\uFDC4&#x27;: &#x27;\u0639\u062C\u0645&#x27;,
  &#x27;\uFDC5&#x27;: &#x27;\u0635\u0645\u0645&#x27;,
  &#x27;\uFDC6&#x27;: &#x27;\u0633\u062E\u064A&#x27;,
  &#x27;\uFDC7&#x27;: &#x27;\u0646\u062C\u064A&#x27;,
  &#x27;\uFE49&#x27;: &#x27;\u203E&#x27;,
  &#x27;\uFE4A&#x27;: &#x27;\u203E&#x27;,
  &#x27;\uFE4B&#x27;: &#x27;\u203E&#x27;,
  &#x27;\uFE4C&#x27;: &#x27;\u203E&#x27;,
  &#x27;\uFE4D&#x27;: &#x27;\u005F&#x27;,
  &#x27;\uFE4E&#x27;: &#x27;\u005F&#x27;,
  &#x27;\uFE4F&#x27;: &#x27;\u005F&#x27;,
  &#x27;\uFE80&#x27;: &#x27;\u0621&#x27;,
  &#x27;\uFE81&#x27;: &#x27;\u0622&#x27;,
  &#x27;\uFE82&#x27;: &#x27;\u0622&#x27;,
  &#x27;\uFE83&#x27;: &#x27;\u0623&#x27;,
  &#x27;\uFE84&#x27;: &#x27;\u0623&#x27;,
  &#x27;\uFE85&#x27;: &#x27;\u0624&#x27;,
  &#x27;\uFE86&#x27;: &#x27;\u0624&#x27;,
  &#x27;\uFE87&#x27;: &#x27;\u0625&#x27;,
  &#x27;\uFE88&#x27;: &#x27;\u0625&#x27;,
  &#x27;\uFE89&#x27;: &#x27;\u0626&#x27;,
  &#x27;\uFE8A&#x27;: &#x27;\u0626&#x27;,
  &#x27;\uFE8B&#x27;: &#x27;\u0626&#x27;,
  &#x27;\uFE8C&#x27;: &#x27;\u0626&#x27;,
  &#x27;\uFE8D&#x27;: &#x27;\u0627&#x27;,
  &#x27;\uFE8E&#x27;: &#x27;\u0627&#x27;,
  &#x27;\uFE8F&#x27;: &#x27;\u0628&#x27;,
  &#x27;\uFE90&#x27;: &#x27;\u0628&#x27;,
  &#x27;\uFE91&#x27;: &#x27;\u0628&#x27;,
  &#x27;\uFE92&#x27;: &#x27;\u0628&#x27;,
  &#x27;\uFE93&#x27;: &#x27;\u0629&#x27;,
  &#x27;\uFE94&#x27;: &#x27;\u0629&#x27;,
  &#x27;\uFE95&#x27;: &#x27;\u062A&#x27;,
  &#x27;\uFE96&#x27;: &#x27;\u062A&#x27;,
  &#x27;\uFE97&#x27;: &#x27;\u062A&#x27;,
  &#x27;\uFE98&#x27;: &#x27;\u062A&#x27;,
  &#x27;\uFE99&#x27;: &#x27;\u062B&#x27;,
  &#x27;\uFE9A&#x27;: &#x27;\u062B&#x27;,
  &#x27;\uFE9B&#x27;: &#x27;\u062B&#x27;,
  &#x27;\uFE9C&#x27;: &#x27;\u062B&#x27;,
  &#x27;\uFE9D&#x27;: &#x27;\u062C&#x27;,
  &#x27;\uFE9E&#x27;: &#x27;\u062C&#x27;,
  &#x27;\uFE9F&#x27;: &#x27;\u062C&#x27;,
  &#x27;\uFEA0&#x27;: &#x27;\u062C&#x27;,
  &#x27;\uFEA1&#x27;: &#x27;\u062D&#x27;,
  &#x27;\uFEA2&#x27;: &#x27;\u062D&#x27;,
  &#x27;\uFEA3&#x27;: &#x27;\u062D&#x27;,
  &#x27;\uFEA4&#x27;: &#x27;\u062D&#x27;,
  &#x27;\uFEA5&#x27;: &#x27;\u062E&#x27;,
  &#x27;\uFEA6&#x27;: &#x27;\u062E&#x27;,
  &#x27;\uFEA7&#x27;: &#x27;\u062E&#x27;,
  &#x27;\uFEA8&#x27;: &#x27;\u062E&#x27;,
  &#x27;\uFEA9&#x27;: &#x27;\u062F&#x27;,
  &#x27;\uFEAA&#x27;: &#x27;\u062F&#x27;,
  &#x27;\uFEAB&#x27;: &#x27;\u0630&#x27;,
  &#x27;\uFEAC&#x27;: &#x27;\u0630&#x27;,
  &#x27;\uFEAD&#x27;: &#x27;\u0631&#x27;,
  &#x27;\uFEAE&#x27;: &#x27;\u0631&#x27;,
  &#x27;\uFEAF&#x27;: &#x27;\u0632&#x27;,
  &#x27;\uFEB0&#x27;: &#x27;\u0632&#x27;,
  &#x27;\uFEB1&#x27;: &#x27;\u0633&#x27;,
  &#x27;\uFEB2&#x27;: &#x27;\u0633&#x27;,
  &#x27;\uFEB3&#x27;: &#x27;\u0633&#x27;,
  &#x27;\uFEB4&#x27;: &#x27;\u0633&#x27;,
  &#x27;\uFEB5&#x27;: &#x27;\u0634&#x27;,
  &#x27;\uFEB6&#x27;: &#x27;\u0634&#x27;,
  &#x27;\uFEB7&#x27;: &#x27;\u0634&#x27;,
  &#x27;\uFEB8&#x27;: &#x27;\u0634&#x27;,
  &#x27;\uFEB9&#x27;: &#x27;\u0635&#x27;,
  &#x27;\uFEBA&#x27;: &#x27;\u0635&#x27;,
  &#x27;\uFEBB&#x27;: &#x27;\u0635&#x27;,
  &#x27;\uFEBC&#x27;: &#x27;\u0635&#x27;,
  &#x27;\uFEBD&#x27;: &#x27;\u0636&#x27;,
  &#x27;\uFEBE&#x27;: &#x27;\u0636&#x27;,
  &#x27;\uFEBF&#x27;: &#x27;\u0636&#x27;,
  &#x27;\uFEC0&#x27;: &#x27;\u0636&#x27;,
  &#x27;\uFEC1&#x27;: &#x27;\u0637&#x27;,
  &#x27;\uFEC2&#x27;: &#x27;\u0637&#x27;,
  &#x27;\uFEC3&#x27;: &#x27;\u0637&#x27;,
  &#x27;\uFEC4&#x27;: &#x27;\u0637&#x27;,
  &#x27;\uFEC5&#x27;: &#x27;\u0638&#x27;,
  &#x27;\uFEC6&#x27;: &#x27;\u0638&#x27;,
  &#x27;\uFEC7&#x27;: &#x27;\u0638&#x27;,
  &#x27;\uFEC8&#x27;: &#x27;\u0638&#x27;,
  &#x27;\uFEC9&#x27;: &#x27;\u0639&#x27;,
  &#x27;\uFECA&#x27;: &#x27;\u0639&#x27;,
  &#x27;\uFECB&#x27;: &#x27;\u0639&#x27;,
  &#x27;\uFECC&#x27;: &#x27;\u0639&#x27;,
  &#x27;\uFECD&#x27;: &#x27;\u063A&#x27;,
  &#x27;\uFECE&#x27;: &#x27;\u063A&#x27;,
  &#x27;\uFECF&#x27;: &#x27;\u063A&#x27;,
  &#x27;\uFED0&#x27;: &#x27;\u063A&#x27;,
  &#x27;\uFED1&#x27;: &#x27;\u0641&#x27;,
  &#x27;\uFED2&#x27;: &#x27;\u0641&#x27;,
  &#x27;\uFED3&#x27;: &#x27;\u0641&#x27;,
  &#x27;\uFED4&#x27;: &#x27;\u0641&#x27;,
  &#x27;\uFED5&#x27;: &#x27;\u0642&#x27;,
  &#x27;\uFED6&#x27;: &#x27;\u0642&#x27;,
  &#x27;\uFED7&#x27;: &#x27;\u0642&#x27;,
  &#x27;\uFED8&#x27;: &#x27;\u0642&#x27;,
  &#x27;\uFED9&#x27;: &#x27;\u0643&#x27;,
  &#x27;\uFEDA&#x27;: &#x27;\u0643&#x27;,
  &#x27;\uFEDB&#x27;: &#x27;\u0643&#x27;,
  &#x27;\uFEDC&#x27;: &#x27;\u0643&#x27;,
  &#x27;\uFEDD&#x27;: &#x27;\u0644&#x27;,
  &#x27;\uFEDE&#x27;: &#x27;\u0644&#x27;,
  &#x27;\uFEDF&#x27;: &#x27;\u0644&#x27;,
  &#x27;\uFEE0&#x27;: &#x27;\u0644&#x27;,
  &#x27;\uFEE1&#x27;: &#x27;\u0645&#x27;,
  &#x27;\uFEE2&#x27;: &#x27;\u0645&#x27;,
  &#x27;\uFEE3&#x27;: &#x27;\u0645&#x27;,
  &#x27;\uFEE4&#x27;: &#x27;\u0645&#x27;,
  &#x27;\uFEE5&#x27;: &#x27;\u0646&#x27;,
  &#x27;\uFEE6&#x27;: &#x27;\u0646&#x27;,
  &#x27;\uFEE7&#x27;: &#x27;\u0646&#x27;,
  &#x27;\uFEE8&#x27;: &#x27;\u0646&#x27;,
  &#x27;\uFEE9&#x27;: &#x27;\u0647&#x27;,
  &#x27;\uFEEA&#x27;: &#x27;\u0647&#x27;,
  &#x27;\uFEEB&#x27;: &#x27;\u0647&#x27;,
  &#x27;\uFEEC&#x27;: &#x27;\u0647&#x27;,
  &#x27;\uFEED&#x27;: &#x27;\u0648&#x27;,
  &#x27;\uFEEE&#x27;: &#x27;\u0648&#x27;,
  &#x27;\uFEEF&#x27;: &#x27;\u0649&#x27;,
  &#x27;\uFEF0&#x27;: &#x27;\u0649&#x27;,
  &#x27;\uFEF1&#x27;: &#x27;\u064A&#x27;,
  &#x27;\uFEF2&#x27;: &#x27;\u064A&#x27;,
  &#x27;\uFEF3&#x27;: &#x27;\u064A&#x27;,
  &#x27;\uFEF4&#x27;: &#x27;\u064A&#x27;,
  &#x27;\uFEF5&#x27;: &#x27;\u0644\u0622&#x27;,
  &#x27;\uFEF6&#x27;: &#x27;\u0644\u0622&#x27;,
  &#x27;\uFEF7&#x27;: &#x27;\u0644\u0623&#x27;,
  &#x27;\uFEF8&#x27;: &#x27;\u0644\u0623&#x27;,
  &#x27;\uFEF9&#x27;: &#x27;\u0644\u0625&#x27;,
  &#x27;\uFEFA&#x27;: &#x27;\u0644\u0625&#x27;,
  &#x27;\uFEFB&#x27;: &#x27;\u0644\u0627&#x27;,
  &#x27;\uFEFC&#x27;: &#x27;\u0644\u0627&#x27;
};

function reverseIfRtl(chars) {
  var charsLength = chars.length;
  //reverse an arabic ligature
  if (charsLength &lt;= 1 || !isRTLRangeFor(chars.charCodeAt(0)))
    return chars;

  var s = &#x27;&#x27;;
  for (var ii = charsLength - 1; ii &gt;= 0; ii--)
    s += chars[ii];
  return s;
}

function fontCharsToUnicode(charCodes, font) {
  var glyphs = font.charsToGlyphs(charCodes);
  var result = &#x27;&#x27;;
  for (var i = 0, ii = glyphs.length; i &lt; ii; i++) {
    var glyph = glyphs[i];
    if (!glyph)
      continue;

    var glyphUnicode = glyph.unicode;
    if (glyphUnicode in NormalizedUnicodes)
      glyphUnicode = NormalizedUnicodes[glyphUnicode];
    result += reverseIfRtl(glyphUnicode);
  }
  return result;
}

function adjustWidths(properties) {
  if (properties.fontMatrix[0] === FONT_IDENTITY_MATRIX[0]) {
    return;
  }
  // adjusting width to fontMatrix scale
  var scale = 0.001 / properties.fontMatrix[0];
  var glyphsWidths = properties.widths;
  for (var glyph in glyphsWidths) {
    glyphsWidths[glyph] *= scale;
  }
  properties.defaultWidth *= scale;
}

/**
 * &#x27;Font&#x27; is the class the outside world should use, it encapsulate all the font
 * decoding logics whatever type it is (assuming the font type is supported).
 *
 * For example to read a Type1 font and to attach it to the document:
 *   var type1Font = new Font(&quot;MyFontName&quot;, binaryFile, propertiesObject);
 *   type1Font.bind();
 */
var Font = (function FontClosure() {
  function Font(name, file, properties) {

    this.name = name;
    this.loadedName = properties.loadedName;
    this.coded = properties.coded;
    this.loadCharProcs = properties.coded;
    this.sizes = [];

    var names = name.split(&#x27;+&#x27;);
    names = names.length &gt; 1 ? names[1] : names[0];
    names = names.split(/[-,_]/g)[0];
    this.isSerifFont = !!(properties.flags &amp; FontFlags.Serif);
    this.isSymbolicFont = !!(properties.flags &amp; FontFlags.Symbolic);
    this.isMonospace = !!(properties.flags &amp; FontFlags.FixedPitch);

    var type = properties.type;
    this.type = type;

    this.fallbackName = this.isMonospace ? &#x27;monospace&#x27; :
                        this.isSerifFont ? &#x27;serif&#x27; : &#x27;sans-serif&#x27;;

    this.differences = properties.differences;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.composite = properties.composite;
    this.wideChars = properties.wideChars;
    this.hasEncoding = properties.hasEncoding;

    this.fontMatrix = properties.fontMatrix;
    if (properties.type == &#x27;Type3&#x27;) {
      this.encoding = properties.baseEncoding;
      return;
    }

    // Trying to fix encoding using glyph CIDSystemInfo.
    this.loadCidToUnicode(properties);
    this.cidEncoding = properties.cidEncoding;
    this.vertical = properties.vertical;
    if (this.vertical) {
      this.vmetrics = properties.vmetrics;
      this.defaultVMetrics = properties.defaultVMetrics;
    }

    if (properties.toUnicode &amp;&amp; properties.toUnicode.length &gt; 0)
      this.toUnicode = properties.toUnicode;
    else
      this.rebuildToUnicode(properties);

    this.toFontChar = this.buildToFontChar(this.toUnicode);

    if (!file) {
      // The file data is not specified. Trying to fix the font name
      // to be used with the canvas.font.
      var fontName = name.replace(/[,_]/g, &#x27;-&#x27;);
      fontName = stdFontMap[fontName] || nonStdFontMap[fontName] || fontName;

      this.bold = (fontName.search(/bold/gi) != -1);
      this.italic = (fontName.search(/oblique/gi) != -1) ||
                    (fontName.search(/italic/gi) != -1);

      // Use &#x27;name&#x27; instead of &#x27;fontName&#x27; here because the original
      // name ArialBlack for example will be replaced by Helvetica.
      this.black = (name.search(/Black/g) != -1);

      // if at least one width is present, remeasure all chars when exists
      this.remeasure = Object.keys(this.widths).length &gt; 0;

      this.encoding = properties.baseEncoding;
      this.noUnicodeAdaptation = true;
      this.loadedName = fontName.split(&#x27;-&#x27;)[0];
      this.loading = false;
      return;
    }

    // Some fonts might use wrong font types for Type1C or CIDFontType0C
    var subtype = properties.subtype;
    if (subtype == &#x27;Type1C&#x27; &amp;&amp; (type != &#x27;Type1&#x27; &amp;&amp; type != &#x27;MMType1&#x27;))
      type = &#x27;Type1&#x27;;
    if (subtype == &#x27;CIDFontType0C&#x27; &amp;&amp; type != &#x27;CIDFontType0&#x27;)
      type = &#x27;CIDFontType0&#x27;;
    // XXX: Temporarily change the type for open type so we trigger a warning.
    // This should be removed when we add support for open type.
    if (subtype === &#x27;OpenType&#x27;) {
      type = &#x27;OpenType&#x27;;
    }

    var data;
    switch (type) {
      case &#x27;Type1&#x27;:
      case &#x27;CIDFontType0&#x27;:
        this.mimetype = &#x27;font/opentype&#x27;;

        var cff = (subtype == &#x27;Type1C&#x27; || subtype == &#x27;CIDFontType0C&#x27;) ?
          new CFFFont(file, properties) : new Type1Font(name, file, properties);

        adjustWidths(properties);

        // Wrap the CFF data inside an OTF font file
        data = this.convert(name, cff, properties);
        break;

      case &#x27;OpenType&#x27;:
      case &#x27;TrueType&#x27;:
      case &#x27;CIDFontType2&#x27;:
        this.mimetype = &#x27;font/opentype&#x27;;

        // Repair the TrueType file. It is can be damaged in the point of
        // view of the sanitizer
        data = this.checkAndRepair(name, file, properties);
        break;

      default:
        error(&#x27;Font &#x27; + type + &#x27; is not supported&#x27;);
        break;
    }

    this.data = data;

    // Transfer some properties again that could change during font conversion
    this.fontMatrix = properties.fontMatrix;
    this.widths = properties.widths;
    this.defaultWidth = properties.defaultWidth;
    this.encoding = properties.baseEncoding;
    this.seacMap = properties.seacMap;

    this.loading = true;
  }

  var numFonts = 0;
  function getUniqueName() {
    return &#x27;pdfFont&#x27; + numFonts++;
  }

  function stringToArray(str) {
    var array = [];
    for (var i = 0, ii = str.length; i &lt; ii; ++i)
      array[i] = str.charCodeAt(i);

    return array;
  }

  function arrayToString(arr) {
    var str = &#x27;&#x27;;
    for (var i = 0, ii = arr.length; i &lt; ii; ++i)
      str += String.fromCharCode(arr[i]);

    return str;
  }

  function int16(bytes) {
    return (bytes[0] &lt;&lt; 8) + (bytes[1] &amp; 0xff);
  }

  function int32(bytes) {
    return (bytes[0] &lt;&lt; 24) + (bytes[1] &lt;&lt; 16) +
           (bytes[2] &lt;&lt; 8) + (bytes[3] &amp; 0xff);
  }

  function getMaxPower2(number) {
    var maxPower = 0;
    var value = number;
    while (value &gt;= 2) {
      value /= 2;
      maxPower++;
    }

    value = 2;
    for (var i = 1; i &lt; maxPower; i++)
      value *= 2;
    return value;
  }

  function string16(value) {
    return String.fromCharCode((value &gt;&gt; 8) &amp; 0xff) +
           String.fromCharCode(value &amp; 0xff);
  }

  function safeString16(value) {
    // clamp value to the 16-bit int range
    value = value &gt; 0x7FFF ? 0x7FFF : value &lt; -0x8000 ? -0x8000 : value;
    return String.fromCharCode((value &gt;&gt; 8) &amp; 0xff) +
           String.fromCharCode(value &amp; 0xff);
  }

  function string32(value) {
    return String.fromCharCode((value &gt;&gt; 24) &amp; 0xff) +
           String.fromCharCode((value &gt;&gt; 16) &amp; 0xff) +
           String.fromCharCode((value &gt;&gt; 8) &amp; 0xff) +
           String.fromCharCode(value &amp; 0xff);
  }

  function createOpenTypeHeader(sfnt, file, numTables) {
    // Windows hates the Mac TrueType sfnt version number
    if (sfnt == &#x27;true&#x27;)
      sfnt = string32(0x00010000);

    // sfnt version (4 bytes)
    var header = sfnt;

    // numTables (2 bytes)
    header += string16(numTables);

    // searchRange (2 bytes)
    var tablesMaxPower2 = getMaxPower2(numTables);
    var searchRange = tablesMaxPower2 * 16;
    header += string16(searchRange);

    // entrySelector (2 bytes)
    header += string16(Math.log(tablesMaxPower2) / Math.log(2));

    // rangeShift (2 bytes)
    header += string16(numTables * 16 - searchRange);

    file.file += header;
    file.virtualOffset += header.length;
  }

  function createTableEntry(file, tag, data) {
    // offset
    var offset = file.virtualOffset;

    // length
    var length = data.length;

    // Per spec tables must be 4-bytes align so add padding as needed
    while (data.length &amp; 3)
      data.push(0x00);

    while (file.virtualOffset &amp; 3)
      file.virtualOffset++;

    // checksum
    var checksum = 0, n = data.length;
    for (var i = 0; i &lt; n; i += 4)
      checksum = (checksum + int32([data[i], data[i + 1], data[i + 2],
                                    data[i + 3]])) | 0;

    var tableEntry = (tag + string32(checksum) +
                      string32(offset) + string32(length));
    file.file += tableEntry;
    file.virtualOffset += data.length;
  }

  function getRanges(glyphs, deltas) {
    // Array.sort() sorts by characters, not numerically, so convert to an
    // array of characters.
    var codes = [];
    var length = glyphs.length;
    for (var n = 0; n &lt; length; ++n)
      codes.push({ unicode: glyphs[n].unicode, code: n });
    codes.sort(function fontGetRangesSort(a, b) {
      return a.unicode - b.unicode;
    });

    // Split the sorted codes into ranges.
    var ranges = [];
    for (var n = 0; n &lt; length; ) {
      var start = codes[n].unicode;
      var codeIndices = [deltas ? deltas[codes[n].code] : codes[n].code + 1];
      ++n;
      var end = start;
      while (n &lt; length &amp;&amp; end + 1 == codes[n].unicode) {
        codeIndices.push(deltas ? deltas[codes[n].code] : codes[n].code + 1);
        ++end;
        ++n;
        if (end === 0xFFFF) { break; }
      }
      ranges.push([start, end, codeIndices]);
    }

    return ranges;
  }

  function createCmapTable(glyphs, deltas) {
    var ranges = getRanges(glyphs, deltas);

    var numTables = ranges[ranges.length - 1][1] &gt; 0xFFFF ? 2 : 1;
    var cmap = &#x27;\x00\x00&#x27; + // version
               string16(numTables) +  // numTables
               &#x27;\x00\x03&#x27; + // platformID
               &#x27;\x00\x01&#x27; + // encodingID
               string32(4 + numTables * 8); // start of the table record

    for (var i = ranges.length - 1; i &gt;= 0; --i) {
      if (ranges[i][0] &lt;= 0xFFFF) { break; }
    }
    var bmpLength = i + 1;

    if (ranges[i][0] &lt; 0xFFFF &amp;&amp; ranges[i][1] === 0xFFFF) {
      ranges[i][1] = 0xFFFE;
    }
    var trailingRangesCount = ranges[i][1] &lt; 0xFFFF ? 1 : 0;
    var segCount = bmpLength + trailingRangesCount;
    var segCount2 = segCount * 2;
    var searchRange = getMaxPower2(segCount) * 2;
    var searchEntry = Math.log(segCount) / Math.log(2);
    var rangeShift = 2 * segCount - searchRange;

    // Fill up the 4 parallel arrays describing the segments.
    var startCount = &#x27;&#x27;;
    var endCount = &#x27;&#x27;;
    var idDeltas = &#x27;&#x27;;
    var idRangeOffsets = &#x27;&#x27;;
    var glyphsIds = &#x27;&#x27;;
    var bias = 0;

    for (var i = 0, ii = bmpLength; i &lt; ii; i++) {
      var range = ranges[i];
      var start = range[0];
      var end = range[1];
      startCount += string16(start);
      endCount += string16(end);
      var codes = range[2];
      var contiguous = true;
      for (var j = 1, jj = codes.length; j &lt; jj; ++j) {
        if (codes[j] !== codes[j - 1] + 1) {
          contiguous = false;
          break;
        }
      }
      if (!contiguous) {
        var offset = (segCount - i) * 2 + bias * 2;
        bias += (end - start + 1);

        idDeltas += string16(0);
        idRangeOffsets += string16(offset);

        for (var j = 0, jj = codes.length; j &lt; jj; ++j) {
          glyphsIds += string16(codes[j]);
        }
      } else {
        var startCode = codes[0];

        idDeltas += string16((startCode - start) &amp; 0xFFFF);
        idRangeOffsets += string16(0);
      }
    }

    if (trailingRangesCount &gt; 0) {
      endCount += &#x27;\xFF\xFF&#x27;;
      startCount += &#x27;\xFF\xFF&#x27;;
      idDeltas += &#x27;\x00\x01&#x27;;
      idRangeOffsets += &#x27;\x00\x00&#x27;;
    }

    var format314 = &#x27;\x00\x00&#x27; + // language
                    string16(segCount2) +
                    string16(searchRange) +
                    string16(searchEntry) +
                    string16(rangeShift) +
                    endCount + &#x27;\x00\x00&#x27; + startCount +
                    idDeltas + idRangeOffsets + glyphsIds;

    var format31012 = &#x27;&#x27;;
    var header31012 = &#x27;&#x27;;
    if (numTables &gt; 1) {
      cmap += &#x27;\x00\x03&#x27; + // platformID
              &#x27;\x00\x0A&#x27; + // encodingID
              string32(4 + numTables * 8 +
                       4 + format314.length); // start of the table record
      format31012 = &#x27;&#x27;;
      for (var i = 0, ii = ranges.length; i &lt; ii; i++) {
        var range = ranges[i];
        var start = range[0];
        var codes = range[2];
        var code = codes[0];
        for (var j = 1, jj = codes.length; j &lt; jj; ++j) {
          if (codes[j] !== codes[j - 1] + 1) {
            var end = range[0] + j - 1;
            format31012 += string32(start) + // startCharCode
                           string32(end) + // endCharCode
                           string32(code); // startGlyphID
            start = end + 1;
            code = codes[j];
          }
        }
        format31012 += string32(start) + // startCharCode
                       string32(range[1]) + // endCharCode
                       string32(code); // startGlyphID
      }
      header31012 = &#x27;\x00\x0C&#x27; + // format
                    &#x27;\x00\x00&#x27; + // reserved
                    string32(format31012.length + 16) + // length
                    &#x27;\x00\x00\x00\x00&#x27; + // language
                    string32(format31012.length / 12); // nGroups
    }

    return stringToArray(cmap +
                         &#x27;\x00\x04&#x27; + // format
                         string16(format314.length + 4) + // length
                         format314 + header31012 + format31012);
  }

  function validateOS2Table(os2) {
    var stream = new Stream(os2.data);
    var version = int16(stream.getBytes(2));
    // TODO verify all OS/2 tables fields, but currently we validate only those
    // that give us issues
    stream.getBytes(60); // skipping type, misc sizes, panose, unicode ranges
    var selection = int16(stream.getBytes(2));
    if (version &lt; 4 &amp;&amp; (selection &amp; 0x0300)) {
      return false;
    }
    var firstChar = int16(stream.getBytes(2));
    var lastChar = int16(stream.getBytes(2));
    if (firstChar &gt; lastChar) {
      return false;
    }
    stream.getBytes(6); // skipping sTypoAscender/Descender/LineGap
    var usWinAscent = int16(stream.getBytes(2));
    if (usWinAscent === 0) { // makes font unreadable by windows
      return false;
    }

    // OS/2 appears to be valid, resetting some fields
    os2.data[8] = os2.data[9] = 0; // IE rejects fonts if fsType != 0
    return true;
  }

  function createOS2Table(properties, charstrings, override) {
    override = override || {
      unitsPerEm: 0,
      yMax: 0,
      yMin: 0,
      ascent: 0,
      descent: 0
    };

    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    var firstCharIndex = null;
    var lastCharIndex = 0;

    if (charstrings) {
      for (var i = 0; i &lt; charstrings.length; ++i) {
        var code = charstrings[i].unicode;
        if (firstCharIndex &gt; code || !firstCharIndex)
          firstCharIndex = code;
        if (lastCharIndex &lt; code)
          lastCharIndex = code;

        var position = getUnicodeRangeFor(code);
        if (position &lt; 32) {
          ulUnicodeRange1 |= 1 &lt;&lt; position;
        } else if (position &lt; 64) {
          ulUnicodeRange2 |= 1 &lt;&lt; position - 32;
        } else if (position &lt; 96) {
          ulUnicodeRange3 |= 1 &lt;&lt; position - 64;
        } else if (position &lt; 123) {
          ulUnicodeRange4 |= 1 &lt;&lt; position - 96;
        } else {
          error(&#x27;Unicode ranges Bits &gt; 123 are reserved for internal usage&#x27;);
        }
      }
    } else {
      // TODO
      firstCharIndex = 0;
      lastCharIndex = 255;
    }

    var bbox = properties.bbox || [0, 0, 0, 0];
    var unitsPerEm = override.unitsPerEm ||
      1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];

    // if the font units differ to the PDF glyph space units
    // then scale up the values
    var scale = properties.ascentScaled ? 1.0 :
      unitsPerEm / PDF_GLYPH_SPACE_UNITS;

    var typoAscent = override.ascent || Math.round(scale *
      (properties.ascent || bbox[3]));
    var typoDescent = override.descent || Math.round(scale *
      (properties.descent || bbox[1]));
    if (typoDescent &gt; 0 &amp;&amp; properties.descent &gt; 0 &amp;&amp; bbox[1] &lt; 0) {
      typoDescent = -typoDescent; // fixing incorrect descent
    }
    var winAscent = override.yMax || typoAscent;
    var winDescent = -override.yMin || -typoDescent;

    return &#x27;\x00\x03&#x27; + // version
           &#x27;\x02\x24&#x27; + // xAvgCharWidth
           &#x27;\x01\xF4&#x27; + // usWeightClass
           &#x27;\x00\x05&#x27; + // usWidthClass
           &#x27;\x00\x00&#x27; + // fstype (0 to let the font loads via font-face on IE)
           &#x27;\x02\x8A&#x27; + // ySubscriptXSize
           &#x27;\x02\xBB&#x27; + // ySubscriptYSize
           &#x27;\x00\x00&#x27; + // ySubscriptXOffset
           &#x27;\x00\x8C&#x27; + // ySubscriptYOffset
           &#x27;\x02\x8A&#x27; + // ySuperScriptXSize
           &#x27;\x02\xBB&#x27; + // ySuperScriptYSize
           &#x27;\x00\x00&#x27; + // ySuperScriptXOffset
           &#x27;\x01\xDF&#x27; + // ySuperScriptYOffset
           &#x27;\x00\x31&#x27; + // yStrikeOutSize
           &#x27;\x01\x02&#x27; + // yStrikeOutPosition
           &#x27;\x00\x00&#x27; + // sFamilyClass
           &#x27;\x00\x00\x06&#x27; +
           String.fromCharCode(properties.fixedPitch ? 0x09 : 0x00) +
           &#x27;\x00\x00\x00\x00\x00\x00&#x27; + // Panose
           string32(ulUnicodeRange1) + // ulUnicodeRange1 (Bits 0-31)
           string32(ulUnicodeRange2) + // ulUnicodeRange2 (Bits 32-63)
           string32(ulUnicodeRange3) + // ulUnicodeRange3 (Bits 64-95)
           string32(ulUnicodeRange4) + // ulUnicodeRange4 (Bits 96-127)
           &#x27;\x2A\x32\x31\x2A&#x27; + // achVendID
           string16(properties.italicAngle ? 1 : 0) + // fsSelection
           string16(firstCharIndex ||
                    properties.firstChar) + // usFirstCharIndex
           string16(lastCharIndex || properties.lastChar) +  // usLastCharIndex
           string16(typoAscent) + // sTypoAscender
           string16(typoDescent) + // sTypoDescender
           &#x27;\x00\x64&#x27; + // sTypoLineGap (7%-10% of the unitsPerEM value)
           string16(winAscent) + // usWinAscent
           string16(winDescent) + // usWinDescent
           &#x27;\x00\x00\x00\x00&#x27; + // ulCodePageRange1 (Bits 0-31)
           &#x27;\x00\x00\x00\x00&#x27; + // ulCodePageRange2 (Bits 32-63)
           string16(properties.xHeight) + // sxHeight
           string16(properties.capHeight) + // sCapHeight
           string16(0) + // usDefaultChar
           string16(firstCharIndex || properties.firstChar) + // usBreakChar
           &#x27;\x00\x03&#x27;;  // usMaxContext
  }

  function createPostTable(properties) {
    var angle = Math.floor(properties.italicAngle * (Math.pow(2, 16)));
    return &#x27;\x00\x03\x00\x00&#x27; + // Version number
           string32(angle) + // italicAngle
           &#x27;\x00\x00&#x27; + // underlinePosition
           &#x27;\x00\x00&#x27; + // underlineThickness
           string32(properties.fixedPitch) + // isFixedPitch
           &#x27;\x00\x00\x00\x00&#x27; + // minMemType42
           &#x27;\x00\x00\x00\x00&#x27; + // maxMemType42
           &#x27;\x00\x00\x00\x00&#x27; + // minMemType1
           &#x27;\x00\x00\x00\x00&#x27;;  // maxMemType1
  }

  function createNameTable(name, proto) {
    if (!proto) {
      proto = [[], []]; // no strings and unicode strings
    }

    var strings = [
      proto[0][0] || &#x27;Original licence&#x27;,  // 0.Copyright
      proto[0][1] || name,                // 1.Font family
      proto[0][2] || &#x27;Unknown&#x27;,           // 2.Font subfamily (font weight)
      proto[0][3] || &#x27;uniqueID&#x27;,          // 3.Unique ID
      proto[0][4] || name,                // 4.Full font name
      proto[0][5] || &#x27;Version 0.11&#x27;,      // 5.Version
      proto[0][6] || &#x27;&#x27;,                  // 6.Postscript name
      proto[0][7] || &#x27;Unknown&#x27;,           // 7.Trademark
      proto[0][8] || &#x27;Unknown&#x27;,           // 8.Manufacturer
      proto[0][9] || &#x27;Unknown&#x27;            // 9.Designer
    ];

    // Mac want 1-byte per character strings while Windows want
    // 2-bytes per character, so duplicate the names table
    var stringsUnicode = [];
    for (var i = 0, ii = strings.length; i &lt; ii; i++) {
      var str = proto[1][i] || strings[i];

      var strUnicode = &#x27;&#x27;;
      for (var j = 0, jj = str.length; j &lt; jj; j++)
        strUnicode += string16(str.charCodeAt(j));
      stringsUnicode.push(strUnicode);
    }

    var names = [strings, stringsUnicode];
    var platforms = [&#x27;\x00\x01&#x27;, &#x27;\x00\x03&#x27;];
    var encodings = [&#x27;\x00\x00&#x27;, &#x27;\x00\x01&#x27;];
    var languages = [&#x27;\x00\x00&#x27;, &#x27;\x04\x09&#x27;];

    var namesRecordCount = strings.length * platforms.length;
    var nameTable =
      &#x27;\x00\x00&#x27; +                           // format
      string16(namesRecordCount) +           // Number of names Record
      string16(namesRecordCount * 12 + 6);   // Storage

    // Build the name records field
    var strOffset = 0;
    for (var i = 0, ii = platforms.length; i &lt; ii; i++) {
      var strs = names[i];
      for (var j = 0, jj = strs.length; j &lt; jj; j++) {
        var str = strs[j];
        var nameRecord =
          platforms[i] + // platform ID
          encodings[i] + // encoding ID
          languages[i] + // language ID
          string16(j) + // name ID
          string16(str.length) +
          string16(strOffset);
        nameTable += nameRecord;
        strOffset += str.length;
      }
    }

    nameTable += strings.join(&#x27;&#x27;) + stringsUnicode.join(&#x27;&#x27;);
    return nameTable;
  }

  // Normalize the charcodes in the cmap table into unicode values
  // that will work with the (3, 1) cmap table we will write out.
  function cmapCharcodeToUnicode(charcode, symbolic, platformId, encodingId) {
    var unicode;
    if (symbolic) {
      // These codes will be shifted into the range
      // SYMBOLIC_FONT_GLYPH_OFFSET to (SYMBOLIC_FONT_GLYPH_OFFSET + 0xFF)
      // so that they are not in the control character range that could
      // be displayed as spaces by browsers.
      if (platformId === 3 &amp;&amp; encodingId === 0 ||
          platformId === 1 &amp;&amp; encodingId === 0) {
        unicode = SYMBOLIC_FONT_GLYPH_OFFSET | (charcode &amp; 0xFF);
      }
    } else {
      if (platformId === 3 &amp;&amp; encodingId === 1) {
        // A (3, 1) table is alredy unicode (Microsoft Unicode format)
        unicode = charcode;
      } else if (platformId === 1 &amp;&amp; encodingId === 0) {
        // TODO(mack): Should apply the changes to convert the
        // MacRomanEncoding to Mac OS Roman encoding in 9.6.6.4
        // table 115 of the pdf spec
        var glyphName = Encodings.MacRomanEncoding[charcode];
        if (glyphName) {
          unicode = GlyphsUnicode[glyphName];
        }
      }
    }
    return unicode;
  }


  Font.prototype = {
    name: null,
    font: null,
    mimetype: null,
    encoding: null,

    exportData: function Font_exportData() {
      var data = {};
      for (var i in this) {
        if (this.hasOwnProperty(i))
          data[i] = this[i];
      }
      return data;
    },

    checkAndRepair: function Font_checkAndRepair(name, font, properties) {
      function readTableEntry(file) {
        var tag = file.getBytes(4);
        tag = String.fromCharCode(tag[0]) +
              String.fromCharCode(tag[1]) +
              String.fromCharCode(tag[2]) +
              String.fromCharCode(tag[3]);

        var checksum = int32(file.getBytes(4));
        var offset = int32(file.getBytes(4));
        var length = int32(file.getBytes(4));

        // Read the table associated data
        var previousPosition = file.pos;
        file.pos = file.start ? file.start : 0;
        file.skip(offset);
        var data = file.getBytes(length);
        file.pos = previousPosition;

        if (tag == &#x27;head&#x27;) {
          // clearing checksum adjustment
          data[8] = data[9] = data[10] = data[11] = 0;
          data[17] |= 0x20; //Set font optimized for cleartype flag
        }

        return {
          tag: tag,
          checksum: checksum,
          length: length,
          offset: offset,
          data: data
        };
      }

      function readOpenTypeHeader(ttf) {
        return {
          version: arrayToString(ttf.getBytes(4)),
          numTables: int16(ttf.getBytes(2)),
          searchRange: int16(ttf.getBytes(2)),
          entrySelector: int16(ttf.getBytes(2)),
          rangeShift: int16(ttf.getBytes(2))
        };
      }

      function createGlyphNameMap(glyphs, ids, properties) {
        var glyphNames = properties.glyphNames;
        if (!glyphNames) {
          properties.glyphNameMap = {};
          return;
        }
        var glyphsLength = glyphs.length;
        var glyphNameMap = {};
        var encoding = [];
        for (var i = 0; i &lt; glyphsLength; ++i) {
          var glyphName = glyphNames[ids[i]];
          if (!glyphName)
            continue;
          var unicode = glyphs[i].unicode;
          glyphNameMap[glyphName] = unicode;
          var code = glyphs[i].code;
          encoding[code] = glyphName;
        }
        properties.glyphNameMap = glyphNameMap;
        if (properties.overridableEncoding)
          properties.baseEncoding = encoding;
      }

      /**
       * Read the appropriate subtable from the cmap according to 9.6.6.4 from
       * PDF spec
       */
      function readCmapTable(cmap, font, hasEncoding, isSymbolicFont) {
        var start = (font.start ? font.start : 0) + cmap.offset;
        font.pos = start;

        var version = int16(font.getBytes(2));
        var numTables = int16(font.getBytes(2));

        var potentialTable;
        var foundPreferredTable;
        // There&#x27;s an order of preference in terms of which cmap subtable we
        // want to use. So scan through them to find our preferred table.
        for (var i = 0; i &lt; numTables; i++) {
          var platformId = int16(font.getBytes(2));
          var encodingId = int16(font.getBytes(2));
          var offset = int32(font.getBytes(4));
          var useTable = false;
          var canBreak = false;

          // The following block implements the following from the spec:
          //
          //   When the font has no Encoding entry, or the font descriptor’s
          //   Symbolic flag is set (in which case the Encoding entry
          //   is ignored), this shall occur:
          //      - If the font contains a (3, 0) subtable, the range of
          //      - Otherwise, the (1, 0) subtable will be used.
          //   Otherwise, if the font does have an encoding:
          //      - Use the (3, 1) cmap subtable
          //      - Otherwise, use the (1, 0) subtable if present
          //
          // The following diverges slightly from the above spec in order
          // to handle the case that hasEncoding and isSymbolicFont are both
          // true. In this, based on the ordering of the rules in the spec,
          // my interpretation is that we should be acting as if the font is
          // symbolic.
          //
          // However, in this case, the test pdf &#x27;preistabelle.pdf&#x27;
          // is interpreting this case as a non-symbolic font. In this case
          // though, &#x27;presitabelle.pdf&#x27; does contain a (3, 1) table and does
          // not contain a (3, 0) table which indicates it is non-symbolic.
          //
          // Thus, I am using this heurisitic of looking at which table is
          // found to truly determine whether or not the font is symbolic.
          // That is, if the specific symbolic/non-symbolic font specific
          // tables (3, 0) or (3, 1) is found, that information is used for
          // deciding if the font is symbolic or not.
          //
          // TODO(mack): This section needs some more thought on whether the
          // heuristic is good enough. For now, it passes all the regression
          // tests.
          if (isSymbolicFont &amp;&amp; platformId === 3 &amp;&amp; encodingId === 0) {
            useTable = true;
            canBreak = true;
            foundPreferredTable = true;
          } else if (hasEncoding &amp;&amp; platformId === 3 &amp;&amp; encodingId === 1) {
            useTable = true;
            canBreak = true;
            foundPreferredTable = true;
            // Update the isSymbolicFont based on this heuristic
            isSymbolicFont = false;
          } else if (platformId === 1 &amp;&amp; encodingId === 0 &amp;&amp;
              !foundPreferredTable) {
            useTable = true;
            foundPreferredTable = true;
          } else if (!potentialTable) {
            // We will use an arbitrary table if we cannot find a preferred
            // table
            useTable = true;
          }

          if (useTable) {
            potentialTable = {
              platformId: platformId,
              encodingId: encodingId,
              offset: offset,
              isSymbolicFont: isSymbolicFont
            };
          }
          if (canBreak) {
            break;
          }
        }

        if (!potentialTable) {
          error(&#x27;Could not find a cmap table&#x27;);
          return;
        }

        if (!foundPreferredTable) {
          warn(&#x27;Did not find a cmap of suitable format. Interpreting (&#x27; +
               potentialTable.platformId + &#x27;, &#x27; + potentialTable.encodingId +
               &#x27;) as (3, 1) table&#x27;);
          potentialTable.platformId = 3;
          potentialTable.encodingId = 1;
        }

        font.pos = start + potentialTable.offset;
        var format = int16(font.getBytes(2));
        var length = int16(font.getBytes(2));
        var language = int16(font.getBytes(2));

        var hasShortCmap = false;
        var mappings = [];

        // TODO(mack): refactor this cmap subtable reading logic out
        if (format === 0) {
          for (var j = 0; j &lt; 256; j++) {
            var index = font.getByte();
            if (!index) {
              continue;
            }
            mappings.push({
              charcode: j,
              glyphId: index
            });
          }
          hasShortCmap = true;
        } else if (format === 4) {
          // re-creating the table in format 4 since the encoding
          // might be changed
          var segCount = (int16(font.getBytes(2)) &gt;&gt; 1);
          font.getBytes(6); // skipping range fields
          var segIndex, segments = [];
          for (segIndex = 0; segIndex &lt; segCount; segIndex++) {
            segments.push({ end: int16(font.getBytes(2)) });
          }
          font.getBytes(2);
          for (segIndex = 0; segIndex &lt; segCount; segIndex++) {
            segments[segIndex].start = int16(font.getBytes(2));
          }

          for (segIndex = 0; segIndex &lt; segCount; segIndex++) {
            segments[segIndex].delta = int16(font.getBytes(2));
          }

          var offsetsCount = 0;
          for (segIndex = 0; segIndex &lt; segCount; segIndex++) {
            var segment = segments[segIndex];
            var rangeOffset = int16(font.getBytes(2));
            if (!rangeOffset) {
              segment.offsetIndex = -1;
              continue;
            }

            var offsetIndex = (rangeOffset &gt;&gt; 1) - (segCount - segIndex);
            segment.offsetIndex = offsetIndex;
            offsetsCount = Math.max(offsetsCount, offsetIndex +
              segment.end - segment.start + 1);
          }

          var offsets = [];
          for (var j = 0; j &lt; offsetsCount; j++) {
            offsets.push(int16(font.getBytes(2)));
          }

          for (segIndex = 0; segIndex &lt; segCount; segIndex++) {
            var segment = segments[segIndex];
            var start = segment.start, end = segment.end;
            var delta = segment.delta, offsetIndex = segment.offsetIndex;

            for (var j = start; j &lt;= end; j++) {
              if (j == 0xFFFF) {
                continue;
              }

              var glyphId = offsetIndex &lt; 0 ? j :
                offsets[offsetIndex + j - start];
              glyphId = (glyphId + delta) &amp; 0xFFFF;
              if (glyphId === 0) {
                continue;
              }
              mappings.push({
                charcode: j,
                glyphId: glyphId
              });
            }
          }
        } else if (format == 6) {
          // Format 6 is a 2-bytes dense mapping, which means the font data
          // lives glue together even if they are pretty far in the unicode
          // table. (This looks weird, so I can have missed something), this
          // works on Linux but seems to fails on Mac so let&#x27;s rewrite the
          // cmap table to a 3-1-4 style
          var firstCode = int16(font.getBytes(2));
          var entryCount = int16(font.getBytes(2));

          var glyphs = [];
          var ids = [];
          for (var j = 0; j &lt; entryCount; j++) {
            var glyphId = int16(font.getBytes(2));
            var charcode = firstCode + j;

            mappings.push({
              charcode: charcode,
              glyphId: glyphId
            });
          }
        } else {
          error(&#x27;cmap table has unsupported format: &#x27; + format);
        }

        return {
          platformId: potentialTable.platformId,
          encodingId: potentialTable.encodingId,
          isSymbolicFont: potentialTable.isSymbolicFont,
          mappings: mappings,
          hasShortCmap: hasShortCmap
        };
      }

      function sanitizeMetrics(font, header, metrics, numGlyphs) {
        if (!header) {
          if (metrics) {
            metrics.data = null;
          }
          return;
        }

        font.pos = (font.start ? font.start : 0) + header.offset;
        font.pos += header.length - 2;
        var numOfMetrics = int16(font.getBytes(2));

        if (numOfMetrics &gt; numGlyphs) {
          info(&#x27;The numOfMetrics (&#x27; + numOfMetrics + &#x27;) should not be &#x27; +
               &#x27;greater than the numGlyphs (&#x27; + numGlyphs + &#x27;)&#x27;);
          // Reduce numOfMetrics if it is greater than numGlyphs
          numOfMetrics = numGlyphs;
          header.data[34] = (numOfMetrics &amp; 0xff00) &gt;&gt; 8;
          header.data[35] = numOfMetrics &amp; 0x00ff;
        }

        var numOfSidebearings = numGlyphs - numOfMetrics;
        var numMissing = numOfSidebearings -
          ((metrics.length - numOfMetrics * 4) &gt;&gt; 1);

        if (numMissing &gt; 0) {
          font.pos = (font.start ? font.start : 0) + metrics.offset;
          var entries = &#x27;&#x27;;
          for (var i = 0, ii = metrics.length; i &lt; ii; i++)
            entries += String.fromCharCode(font.getByte());
          for (var i = 0; i &lt; numMissing; i++)
            entries += &#x27;\x00\x00&#x27;;
          metrics.data = stringToArray(entries);
        }
      }

      function sanitizeGlyph(source, sourceStart, sourceEnd, dest, destStart,
                             hintsValid) {
        if (sourceEnd - sourceStart &lt;= 12) {
          // glyph with data less than 12 is invalid one
          return 0;
        }
        var glyf = source.subarray(sourceStart, sourceEnd);
        var contoursCount = (glyf[0] &lt;&lt; 8) | glyf[1];
        if (contoursCount &amp; 0x8000) {
          // complex glyph, writing as is
          dest.set(glyf, destStart);
          return glyf.length;
        }

        var j = 10, flagsCount = 0;
        for (var i = 0; i &lt; contoursCount; i++) {
          var endPoint = (glyf[j] &lt;&lt; 8) | glyf[j + 1];
          flagsCount = endPoint + 1;
          j += 2;
        }
        // skipping instructions
        var instructionsStart = j;
        var instructionsLength = (glyf[j] &lt;&lt; 8) | glyf[j + 1];
        j += 2 + instructionsLength;
        var instructionsEnd = j;
        // validating flags
        var coordinatesLength = 0;
        for (var i = 0; i &lt; flagsCount; i++) {
          var flag = glyf[j++];
          if (flag &amp; 0xC0) {
            // reserved flags must be zero, rejecting
            return 0;
          }
          var xyLength = ((flag &amp; 2) ? 1 : (flag &amp; 16) ? 0 : 2) +
                         ((flag &amp; 4) ? 1 : (flag &amp; 32) ? 0 : 2);
          coordinatesLength += xyLength;
          if (flag &amp; 8) {
            var repeat = glyf[j++];
            i += repeat;
            coordinatesLength += repeat * xyLength;
          }
        }
        var glyphDataLength = j + coordinatesLength;
        if (glyphDataLength &gt; glyf.length) {
          // not enough data for coordinates
          return 0;
        }
        if (!hintsValid &amp;&amp; instructionsLength &gt; 0) {
          dest.set(glyf.subarray(0, instructionsStart), destStart);
          dest.set([0, 0], destStart + instructionsStart);
          dest.set(glyf.subarray(instructionsEnd, glyphDataLength),
                   destStart + instructionsStart + 2);
          glyphDataLength -= instructionsLength;
          if (glyf.length - glyphDataLength &gt; 3) {
            glyphDataLength = (glyphDataLength + 3) &amp; ~3;
          }
          return glyphDataLength;
        }
        if (glyf.length - glyphDataLength &gt; 3) {
          // truncating and aligning to 4 bytes the long glyph data
          glyphDataLength = (glyphDataLength + 3) &amp; ~3;
          dest.set(glyf.subarray(0, glyphDataLength), destStart);
          return glyphDataLength;
        }
        // glyph data is fine
        dest.set(glyf, destStart);
        return glyf.length;
      }

      function sanitizeHead(head, numGlyphs, locaLength) {
        var data = head.data;

        // Validate version:
        // Should always be 0x00010000
        var version = int32([data[0], data[1], data[2], data[3]]);
        if (version &gt;&gt; 16 !== 1) {
          info(&#x27;Attempting to fix invalid version in head table: &#x27; + version);
          data[0] = 0;
          data[1] = 1;
          data[2] = 0;
          data[3] = 0;
        }

        var indexToLocFormat = int16([data[50], data[51]]);
        if (indexToLocFormat &lt; 0 || indexToLocFormat &gt; 1) {
          info(&#x27;Attempting to fix invalid indexToLocFormat in head table: &#x27; +
               indexToLocFormat);

          // The value of indexToLocFormat should be 0 if the loca table
          // consists of short offsets, and should be 1 if the loca table
          // consists of long offsets.
          //
          // The number of entries in the loca table should be numGlyphs + 1.
          //
          // Using this information, we can work backwards to deduce if the
          // size of each offset in the loca table, and thus figure out the
          // appropriate value for indexToLocFormat.

          var numGlyphsPlusOne = numGlyphs + 1;
          if (locaLength === numGlyphsPlusOne &lt;&lt; 1) {
            // 0x0000 indicates the loca table consists of short offsets
            data[50] = 0;
            data[51] = 0;
          } else if (locaLength === numGlyphsPlusOne &lt;&lt; 2) {
            // 0x0001 indicates the loca table consists of long offsets
            data[50] = 0;
            data[51] = 1;
          } else {
            warn(&#x27;Could not fix indexToLocFormat: &#x27; + indexToLocFormat);
          }
        }
      }

      function sanitizeGlyphLocations(loca, glyf, numGlyphs,
                                      isGlyphLocationsLong, hintsValid,
                                      dupFirstEntry) {
        var itemSize, itemDecode, itemEncode;
        if (isGlyphLocationsLong) {
          itemSize = 4;
          itemDecode = function fontItemDecodeLong(data, offset) {
            return (data[offset] &lt;&lt; 24) | (data[offset + 1] &lt;&lt; 16) |
                   (data[offset + 2] &lt;&lt; 8) | data[offset + 3];
          };
          itemEncode = function fontItemEncodeLong(data, offset, value) {
            data[offset] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
            data[offset + 1] = (value &gt;&gt; 16) &amp; 0xFF;
            data[offset + 2] = (value &gt;&gt; 8) &amp; 0xFF;
            data[offset + 3] = value &amp; 0xFF;
          };
        } else {
          itemSize = 2;
          itemDecode = function fontItemDecode(data, offset) {
            return (data[offset] &lt;&lt; 9) | (data[offset + 1] &lt;&lt; 1);
          };
          itemEncode = function fontItemEncode(data, offset, value) {
            data[offset] = (value &gt;&gt; 9) &amp; 0xFF;
            data[offset + 1] = (value &gt;&gt; 1) &amp; 0xFF;
          };
        }
        var locaData = loca.data;
        // removing the invalid glyphs
        var oldGlyfData = glyf.data;
        var oldGlyfDataLength = oldGlyfData.length;
        var newGlyfData = new Uint8Array(oldGlyfDataLength);
        var startOffset = itemDecode(locaData, 0);
        var writeOffset = 0;
        itemEncode(locaData, 0, writeOffset);
        for (var i = 0, j = itemSize; i &lt; numGlyphs; i++, j += itemSize) {
          var endOffset = itemDecode(locaData, j);
          if (endOffset &gt; oldGlyfDataLength) {
            // glyph end offset points outside glyf data, rejecting the glyph
            itemEncode(locaData, j, writeOffset);
            startOffset = endOffset;
            continue;
          }

          var newLength = sanitizeGlyph(oldGlyfData, startOffset, endOffset,
                                        newGlyfData, writeOffset, hintsValid);
          writeOffset += newLength;
          itemEncode(locaData, j, writeOffset);
          startOffset = endOffset;
        }

        if (writeOffset === 0) {
          // glyf table cannot be empty -- redoing the glyf and loca tables
          // to have single glyph with one point
          var simpleGlyph = new Uint8Array(
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (var i = 0, j = itemSize; i &lt; numGlyphs; i++, j += itemSize)
            itemEncode(locaData, j, simpleGlyph.length);
          glyf.data = simpleGlyph;
          return;
        }

        if (dupFirstEntry) {
          var firstEntryLength = itemDecode(locaData, itemSize);
          if (newGlyfData.length &gt; firstEntryLength + writeOffset) {
            glyf.data = newGlyfData.subarray(0, firstEntryLength + writeOffset);
          } else {
            glyf.data = new Uint8Array(firstEntryLength + writeOffset);
            glyf.data.set(newGlyfData.subarray(0, writeOffset));
          }
          glyf.data.set(newGlyfData.subarray(0, firstEntryLength), writeOffset);
          loca.data = new Uint8Array(locaData.length + itemSize);
          loca.data.set(locaData);
          itemEncode(loca.data, locaData.length,
                     writeOffset + firstEntryLength);
        } else {
          glyf.data = newGlyfData.subarray(0, writeOffset);
        }
      }

      function readPostScriptTable(post, properties, maxpNumGlyphs) {
        var start = (font.start ? font.start : 0) + post.offset;
        font.pos = start;

        var length = post.length, end = start + length;
        var version = int32(font.getBytes(4));
        // skip rest to the tables
        font.getBytes(28);

        var glyphNames;
        var valid = true;
        switch (version) {
          case 0x00010000:
            glyphNames = MacStandardGlyphOrdering;
            break;
          case 0x00020000:
            var numGlyphs = int16(font.getBytes(2));
            if (numGlyphs != maxpNumGlyphs) {
              valid = false;
              break;
            }
            var glyphNameIndexes = [];
            for (var i = 0; i &lt; numGlyphs; ++i) {
              var index = int16(font.getBytes(2));
              if (index &gt;= 32768) {
                valid = false;
                break;
              }
              glyphNameIndexes.push(index);
            }
            if (!valid) {
              break;
            }
            var customNames = [];
            while (font.pos &lt; end) {
              var stringLength = font.getByte();
              var string = &#x27;&#x27;;
              for (var i = 0; i &lt; stringLength; ++i) {
                string += String.fromCharCode(font.getByte());
              }
              customNames.push(string);
            }
            glyphNames = [];
            for (var i = 0; i &lt; numGlyphs; ++i) {
              var j = glyphNameIndexes[i];
              if (j &lt; 258) {
                glyphNames.push(MacStandardGlyphOrdering[j]);
                continue;
              }
              glyphNames.push(customNames[j - 258]);
            }
            break;
          case 0x00030000:
            break;
          default:
            warn(&#x27;Unknown/unsupported post table version &#x27; + version);
            valid = false;
            break;
        }
        properties.glyphNames = glyphNames;
        return valid;
      }

      function readNameTable(nameTable) {
        var start = (font.start ? font.start : 0) + nameTable.offset;
        font.pos = start;

        var names = [[], []];
        var length = nameTable.length, end = start + length;
        var format = int16(font.getBytes(2));
        var FORMAT_0_HEADER_LENGTH = 6;
        if (format !== 0 || length &lt; FORMAT_0_HEADER_LENGTH) {
          // unsupported name table format or table &quot;too&quot; small
          return names;
        }
        var numRecords = int16(font.getBytes(2));
        var stringsStart = int16(font.getBytes(2));
        var records = [];
        var NAME_RECORD_LENGTH = 12;
        for (var i = 0; i &lt; numRecords &amp;&amp;
                        font.pos + NAME_RECORD_LENGTH &lt;= end; i++) {
          var r = {
            platform: int16(font.getBytes(2)),
            encoding: int16(font.getBytes(2)),
            language: int16(font.getBytes(2)),
            name: int16(font.getBytes(2)),
            length: int16(font.getBytes(2)),
            offset: int16(font.getBytes(2))
          };
          // using only Macintosh and Windows platform/encoding names
          if ((r.platform == 1 &amp;&amp; r.encoding === 0 &amp;&amp; r.language === 0) ||
              (r.platform == 3 &amp;&amp; r.encoding == 1 &amp;&amp; r.language == 0x409)) {
            records.push(r);
          }
        }
        for (var i = 0, ii = records.length; i &lt; ii; i++) {
          var record = records[i];
          var pos = start + stringsStart + record.offset;
          if (pos + record.length &gt; end) {
            continue; // outside of name table, ignoring
          }
          font.pos = pos;
          var nameIndex = record.name;
          var encoding = record.encoding ? 1 : 0;
          if (record.encoding) {
            // unicode
            var str = &#x27;&#x27;;
            for (var j = 0, jj = record.length; j &lt; jj; j += 2) {
              str += String.fromCharCode(int16(font.getBytes(2)));
            }
            names[1][nameIndex] = str;
          } else {
            names[0][nameIndex] = bytesToString(font.getBytes(record.length));
          }
        }
        return names;
      }

      var TTOpsStackDeltas = [
        0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5,
        -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1,
        1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1,
        0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2,
        0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1,
        -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1,
        -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1,
        -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
        // 0xC0-DF == -1 and 0xE0-FF == -2

      function sanitizeTTProgram(table, ttContext) {
        var data = table.data;
        var i = 0, n, lastEndf = 0, lastDeff = 0;
        var stack = [];
        var callstack = [];
        var functionsCalled = [];
        var tooComplexToFollowFunctions =
          ttContext.tooComplexToFollowFunctions;
        var inFDEF = false, ifLevel = 0, inELSE = 0;
        for (var ii = data.length; i &lt; ii;) {
          var op = data[i++];
          // The TrueType instruction set docs can be found at
          // https://developer.apple.com/fonts/TTRefMan/RM05/Chap5.html
          if (op === 0x40) { // NPUSHB - pushes n bytes
            n = data[i++];
            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (var j = 0; j &lt; n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if (op === 0x41) { // NPUSHW - pushes n words
            n = data[i++];
            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (var j = 0; j &lt; n; j++) {
                var b = data[i++];
                stack.push((b &lt;&lt; 8) | data[i++]);
              }
            }
          } else if ((op &amp; 0xF8) === 0xB0) { // PUSHB - pushes bytes
            n = op - 0xB0 + 1;
            if (inFDEF || inELSE) {
              i += n;
            } else {
              for (var j = 0; j &lt; n; j++) {
                stack.push(data[i++]);
              }
            }
          } else if ((op &amp; 0xF8) === 0xB8) { // PUSHW - pushes words
            n = op - 0xB8 + 1;
            if (inFDEF || inELSE) {
              i += n * 2;
            } else {
              for (var j = 0; j &lt; n; j++) {
                var b = data[i++];
                stack.push((b &lt;&lt; 8) | data[i++]);
              }
            }
          } else if (op === 0x2B &amp;&amp; !tooComplexToFollowFunctions) { // CALL
            if (!inFDEF &amp;&amp; !inELSE) {
              // collecting inforamtion about which functions are used
              var funcId = stack[stack.length - 1];
              ttContext.functionsUsed[funcId] = true;
              if (funcId in ttContext.functionsStackDeltas) {
                stack.length += ttContext.functionsStackDeltas[funcId];
              } else if (funcId in ttContext.functionsDefined &amp;&amp;
                         functionsCalled.indexOf(funcId) &lt; 0) {
                callstack.push({data: data, i: i, stackTop: stack.length - 1});
                functionsCalled.push(funcId);
                var pc = ttContext.functionsDefined[funcId];
                data = pc.data;
                i = pc.i;
              }
            }
          } else if (op === 0x2C &amp;&amp; !tooComplexToFollowFunctions) { // FDEF
            if (inFDEF || inELSE) {
              warn(&#x27;TT: nested FDEFs not allowed&#x27;);
              tooComplexToFollowFunctions = true;
            }
            inFDEF = true;
            // collecting inforamtion about which functions are defined
            lastDeff = i;
            var funcId = stack.pop();
            ttContext.functionsDefined[funcId] = {data: data, i: i};
          } else if (op === 0x2D) { // ENDF - end of function
            if (inFDEF) {
              inFDEF = false;
              lastEndf = i;
            } else {
              var pc = callstack.pop();
              var funcId = functionsCalled.pop();
              data = pc.data;
              i = pc.i;
              ttContext.functionsStackDeltas[funcId] =
                stack.length - pc.stackTop;
            }
          } else if (op === 0x89) { // IDEF - instruction definition
            if (inFDEF || inELSE) {
              warn(&#x27;TT: nested IDEFs not allowed&#x27;);
              tooComplexToFollowFunctions = true;
            }
            inFDEF = true;
            // recording it as a function to track ENDF
            lastDeff = i;
          } else if (op === 0x58) { // IF
            ++ifLevel;
          } else if (op === 0x1B) { // ELSE
            inELSE = ifLevel;
          } else if (op === 0x59) { // EIF
            if (inELSE === ifLevel) {
              inELSE = 0;
            }
            --ifLevel;
          } else if (op === 0x1C) { // JMPR
            var offset = stack[stack.length - 1];
            // only jumping forward to prevent infinite loop
            if (offset &gt; 0) { i += offset - 1; }
          }
          // Adjusting stack not extactly, but just enough to get function id
          if (!inFDEF &amp;&amp; !inELSE) {
            var stackDelta = op &lt;= 0x8E ? TTOpsStackDeltas[op] :
              op &gt;= 0xC0 &amp;&amp; op &lt;= 0xDF ? -1 : op &gt;= 0xE0 ? -2 : 0;
            if (op &gt;= 0x71 &amp;&amp; op &lt;= 0x75) {
              n = stack.pop();
              if (n === n) {
                stackDelta = -n * 2;
              }
            }
            while (stackDelta &lt; 0 &amp;&amp; stack.length &gt; 0) {
              stack.pop();
              stackDelta++;
            }
            while (stackDelta &gt; 0) {
              stack.push(NaN); // pushing any number into stack
              stackDelta--;
            }
          }
        }
        ttContext.tooComplexToFollowFunctions = tooComplexToFollowFunctions;
        var content = [data];
        if (i &gt; data.length) {
          content.push(new Uint8Array(i - data.length));
        }
        if (lastDeff &gt; lastEndf) {
          warn(&#x27;TT: complementing a missing function tail&#x27;);
          // new function definition started, but not finished
          // complete function by [CLEAR, ENDF]
          content.push(new Uint8Array([0x22, 0x2D]));
        }
        foldTTTable(table, content);
      }

      function checkInvalidFunctions(ttContext, maxFunctionDefs) {
        if (ttContext.tooComplexToFollowFunctions) {
          return;
        }
        for (var j = 0, jj = ttContext.functionsUsed.length; j &lt; jj; j++) {
          if (j &gt; maxFunctionDefs) {
            warn(&#x27;TT: invalid function id: &#x27; + j);
            ttContext.hintsValid = false;
            return;
          }
          if (ttContext.functionsUsed[j] &amp;&amp; !ttContext.functionsDefined[j]) {
            warn(&#x27;TT: undefined function: &#x27; + j);
            ttContext.hintsValid = false;
            return;
          }
        }
      }

      function foldTTTable(table, content) {
        if (content.length &gt; 1) {
          // concatenating the content items
          var newLength = 0;
          for (var j = 0, jj = content.length; j &lt; jj; j++) {
            newLength += content[j].length;
          }
          newLength = (newLength + 3) &amp; ~3;
          var result = new Uint8Array(newLength);
          var pos = 0;
          for (var j = 0, jj = content.length; j &lt; jj; j++) {
            result.set(content[j], pos);
            pos += content[j].length;
          }
          table.data = result;
          table.length = newLength;
        }
      }

      function sanitizeTTPrograms(fpgm, prep) {
        var ttContext = {
          functionsDefined: [],
          functionsUsed: [],
          functionsStackDeltas: [],
          tooComplexToFollowFunctions: false,
          hintsValid: true
        };
        if (fpgm) {
          sanitizeTTProgram(fpgm, ttContext);
        }
        if (prep) {
          sanitizeTTProgram(prep, ttContext);
        }
        if (fpgm) {
          checkInvalidFunctions(ttContext, maxFunctionDefs);
        }
        return ttContext.hintsValid;
      }

      // The following steps modify the original font data, making copy
      font = new Stream(new Uint8Array(font.getBytes()));

      var VALID_TABLES = [&#x27;OS/2&#x27;, &#x27;cmap&#x27;, &#x27;head&#x27;, &#x27;hhea&#x27;, &#x27;hmtx&#x27;, &#x27;maxp&#x27;,
        &#x27;name&#x27;, &#x27;post&#x27;, &#x27;loca&#x27;, &#x27;glyf&#x27;, &#x27;fpgm&#x27;, &#x27;prep&#x27;, &#x27;cvt &#x27;, &#x27;CFF &#x27;];

      var header = readOpenTypeHeader(font);
      var numTables = header.numTables;

      var tables = { &#x27;OS/2&#x27;: null, cmap: null, head: null, hhea: null,
                     hmtx: null, maxp: null, name: null, post: null};
      for (var i = 0; i &lt; numTables; i++) {
        var table = readTableEntry(font);
        if (VALID_TABLES.indexOf(table.tag) &lt; 0) {
          continue; // skipping table if it&#x27;s not a required or optional table
        }
        tables[table.tag] = table;
      }

      var isTrueType = !tables[&#x27;CFF &#x27;];
      if (!isTrueType) {
        // OpenType font
        if (!tables.head || !tables.hhea || !tables.maxp || !tables.post) {
          // no major tables: throwing everything at CFFFont
          var cffFile = new Stream(tables[&#x27;CFF &#x27;].data);
          var cff = new CFFFont(cffFile, properties);

          return this.convert(name, cff, properties);
        }

        delete tables.glyf;
        delete tables.loca;
        delete tables.fpgm;
        delete tables.prep;
        delete tables[&#x27;cvt &#x27;];
      } else {
        if (!tables.glyf || !tables.loca) {
          error(&#x27;Required &quot;glyf&quot; or &quot;loca&quot; tables are not found&#x27;);
        }
      }

      if (!tables.maxp) {
        error(&#x27;Required &quot;maxp&quot; table is not found&#x27;);
      }

      font.pos = (font.start || 0) + tables.maxp.offset;
      var version = int32(font.getBytes(4));
      var numGlyphs = int16(font.getBytes(2));
      var maxFunctionDefs = 0;
      if (version &gt;= 0x00010000 &amp;&amp; tables.maxp.length &gt;= 22) {
        font.pos += 14;
        maxFunctionDefs = int16(font.getBytes(2));
      }

      var dupFirstEntry = false;
      if (properties.type == &#x27;CIDFontType2&#x27; &amp;&amp; properties.toUnicode &amp;&amp;
          properties.toUnicode[0] &gt; 0) {
        // oracle&#x27;s defect (see 3427), duplicating first entry
        dupFirstEntry = true;
        numGlyphs++;
        tables.maxp.data[4] = numGlyphs &gt;&gt; 8;
        tables.maxp.data[5] = numGlyphs &amp; 255;
      }

      var hintsValid = sanitizeTTPrograms(tables.fpgm, tables.prep,
                                          maxFunctionDefs);
      if (!hintsValid) {
        delete tables.fpgm;
        delete tables.prep;
      }

      // Tables needs to be written by ascendant alphabetic order
      var tablesNames = Object.keys(tables);
      tablesNames.sort();

      numTables = tablesNames.length;

      // header and new offsets. Table entry information is appended to the
      // end of file. The virtualOffset represents where to put the actual
      // data of a particular table;
      var ttf = {
        file: &#x27;&#x27;,
        virtualOffset: numTables * (4 * 4)
      };

      // The new numbers of tables will be the last one plus the num
      // of missing tables
      createOpenTypeHeader(header.version, ttf, numTables);

      // Ensure the hmtx table contains the advance width and
      // sidebearings information for numGlyphs in the maxp table
      sanitizeMetrics(font, tables.hhea, tables.hmtx, numGlyphs);

      if (!tables.head) {
        error(&#x27;Required &quot;head&quot; table is not found&#x27;);
      }

      sanitizeHead(tables.head, numGlyphs, isTrueType ? tables.loca.length : 0);

      if (isTrueType) {
        var isGlyphLocationsLong = int16([tables.head.data[50],
                                          tables.head.data[51]]);

        sanitizeGlyphLocations(tables.loca, tables.glyf, numGlyphs,
                               isGlyphLocationsLong, hintsValid, dupFirstEntry);
      }

      if (!tables.hhea) {
        error(&#x27;Required &quot;hhea&quot; table is not found&#x27;);
      }

      // Sanitizer reduces the glyph advanceWidth to the maxAdvanceWidth
      // Sometimes it&#x27;s 0. That needs to be fixed
      if (tables.hhea.data[10] === 0 &amp;&amp; tables.hhea.data[11] === 0) {
        tables.hhea.data[10] = 0xFF;
        tables.hhea.data[11] = 0xFF;
      }

      // The &#x27;post&#x27; table has glyphs names.
      if (tables.post) {
        var valid = readPostScriptTable(tables.post, properties, numGlyphs);
        if (!valid) {
          tables.post = null;
        }
      }

      var glyphs, ids;
      if (properties.type == &#x27;CIDFontType2&#x27;) {
        // Replace the old CMAP table with a shiny new one
        // Type2 composite fonts map characters directly to glyphs so the cmap
        // table must be replaced.
        // canvas fillText will reencode some characters even if the font has a
        // glyph at that position - e.g. newline is converted to a space and
        // U+00AD (soft hyphen) is not drawn.
        // So, offset all the glyphs by 0xFF to avoid these cases and use
        // the encoding to map incoming characters to the new glyph positions
        if (!tables.cmap) {
          tables.cmap = {
            tag: &#x27;cmap&#x27;,
            data: null
          };
        }

        var cidToGidMap = properties.cidToGidMap || [];
        var gidToCidMap = [0];
        if (cidToGidMap.length &gt; 0) {
          for (var j = cidToGidMap.length - 1; j &gt;= 0; j--) {
            var gid = cidToGidMap[j];
            if (gid)
              gidToCidMap[gid] = j;
          }
          // filling the gaps using CID above the CIDs currently used in font
          var nextCid = cidToGidMap.length;
          for (var i = 1; i &lt; numGlyphs; i++) {
            if (!gidToCidMap[i])
              gidToCidMap[i] = nextCid++;
          }
        } else {
          for (var i = 1; i &lt; numGlyphs; i++) {
            gidToCidMap[i] = i;
          }
          if (dupFirstEntry) {
            gidToCidMap[numGlyphs - 1] = 0;
          }
        }

        glyphs = [];
        ids = [];

        var usedUnicodes = [];
        var unassignedUnicodeItems = [];
        var toFontChar = this.cidToFontChar || this.toFontChar;
        for (var i = 1; i &lt; numGlyphs; i++) {
          var cid = gidToCidMap[i];
          var unicode = toFontChar[cid];
          if (!unicode || typeof unicode !== &#x27;number&#x27; ||
              isSpecialUnicode(unicode) || unicode in usedUnicodes) {
            unassignedUnicodeItems.push(i);
            continue;
          }
          usedUnicodes[unicode] = true;
          glyphs.push({ unicode: unicode, code: cid });
          ids.push(i);
        }

        // unassigned codepoints will never be used for non-Identity CMap
        // because the input will be Unicode
        if (!this.cidToFontChar) {
          // trying to fit as many unassigned symbols as we can
          // in the range allocated for the user defined symbols
          var unusedUnicode = CMAP_GLYPH_OFFSET;
          for (var j = 0, jj = unassignedUnicodeItems.length; j &lt; jj; j++) {
            var i = unassignedUnicodeItems[j];
            var cid = gidToCidMap[i];
            while (unusedUnicode in usedUnicodes)
              unusedUnicode++;
            if (unusedUnicode &gt;= CMAP_GLYPH_OFFSET + GLYPH_AREA_SIZE)
              break;
            var unicode = unusedUnicode++;
            this.toFontChar[cid] = unicode;
            usedUnicodes[unicode] = true;
            glyphs.push({ unicode: unicode, code: cid });
            ids.push(i);
          }
        }
      } else {
        this.useToFontChar = true;
        // Most of the following logic in this code branch is based on the
        // 9.6.6.4 of the PDF spec.

        // TODO(mack):
        // We are using this.hasEncoding to mean that the encoding is either
        // MacRomanEncoding or WinAnsiEncoding (following spec in 9.6.6.4),
        // but this.hasEncoding is currently true for any encodings on the
        // Encodings object (e.g. MacExpertEncoding). So should consider using
        // better check for this.
        var cmapTable = readCmapTable(tables.cmap, font, this.hasEncoding,
            this.isSymbolicFont);

        // TODO(mack): If the (3, 0) cmap table used, then the font is
        // symbolic. The range of charcodes in the cmap table should be
        // one of the following:
        //   -&gt; 0x0000 - 0x00FF
        //   -&gt; 0xF000 - 0xF0FF
        //   -&gt; 0xF100 - 0xF1FF
        //   -&gt; 0xF200 - 0xF2FF
        // If it is not, we should change not consider this a symbolic font
        this.isSymbolicFont = cmapTable.isSymbolicFont;

        var cmapPlatformId = cmapTable.platformId;
        var cmapEncodingId = cmapTable.encodingId;
        var cmapMappings = cmapTable.mappings;
        var cmapMappingsLength = cmapMappings.length;
        var glyphs = [];
        var ids = [];
        for (var i = 0; i &lt; cmapMappingsLength; ++i) {
          var cmapMapping = cmapMappings[i];
          var charcode = cmapMapping.charcode;
          var unicode = cmapCharcodeToUnicode(charcode, this.isSymbolicFont,
              cmapPlatformId, cmapEncodingId);

          if (!unicode) {
            // TODO(mack): gotta check if skipping mappings where we cannot find
            // a unicode is the correct behaviour
            continue;
          }
          glyphs.push({
            code: charcode,
            unicode: unicode
          });
          ids.push(cmapMapping.glyphId);
        }

        var hasShortCmap = cmapTable.hasShortCmap;
        var toFontChar = this.toFontChar;

        if (hasShortCmap &amp;&amp; ids.length == numGlyphs) {
          // Fixes the short cmap tables -- some generators use incorrect
          // glyph id.
          for (var i = 0, ii = ids.length; i &lt; ii; i++) {
            ids[i] = i;
          }
        }

        // Rewrite the whole toFontChar dictionary with a new one using the
        // information from the mappings in the cmap table.
        var newToFontChar = [];
        if (this.isSymbolicFont) {
          for (var i = 0, ii = glyphs.length; i &lt; ii; i++) {
            var glyph = glyphs[i];
            // For (3, 0) cmap tables:
            // The charcode key being stored in toFontChar is the lower byte
            // of the two-byte charcodes of the cmap table since according to
            // the spec: &#x27;each byte from the string shall be prepended with the
            // high byte of the range [of charcodes in the cmap table], to form
            // a two-byte character, which shall be used to select the
            // associated glyph description from the subtable&#x27;.
            //
            // For (1, 0) cmap tables:
            // &#x27;single bytes from the string shall be used to look up the
            // associated glyph descriptions from the subtable&#x27;. This means
            // charcodes in the cmap will be single bytes, so no-op since
            // glyph.code &amp; 0xFF === glyph.code
            newToFontChar[glyph.code &amp; 0xFF] = glyph.unicode;
          }
        } else {

          var encoding = properties.baseEncoding;
          var differences = properties.differences;

          // TODO(mack): check if it is necessary to shift control characters
          // for non-symbolic fonts so that browsers dont&#x27;t render them using
          // space characters

          var glyphCodeMapping = cmapTable.glyphCodeMapping;
          for (var charcode = 0; charcode &lt; encoding.length; ++charcode) {
            if (!encoding.hasOwnProperty(charcode)) {
              continue;
            }

            // Since the cmap table that we will be writing out is a (3, 1)
            // unicode table, in this section we will rewrites the charcodes
            // in the pdf into unicodes

            var glyphName = encoding[charcode];
            // A nonsymbolic font should not have a Differences array, but
            // if it does have one, we should still use it
            if (charcode in differences) {
              glyphName = differences[charcode];
            }

            // Finally, any undefined entries in the table shall be filled
            // using StandardEncoding
            if (!glyphName) {
              glyphName = Encodings.StandardEncoding[charcode];
            }

            // TODO(mack): Handle the case that the glyph name cannot be
            // mapped as specified, in which case the glyph name shall be
            // looked up in the font program&#x27;s &#x27;post&#x27; table (if one is
            // present) and the associated glyph id shall be used.
            //
            // For now, we&#x27;re just using the &#x27;.notdef&#x27; glyph name in this
            // case.
            glyphName = glyphName || &#x27;.notdef&#x27;;

            var unicode = GlyphsUnicode[glyphName];
            newToFontChar[charcode] = unicode;
          }
        }
        this.toFontChar = toFontChar = newToFontChar;

        createGlyphNameMap(glyphs, ids, properties);
        this.glyphNameMap = properties.glyphNameMap;
      }

      if (glyphs.length === 0) {
        // defines at least one glyph
        glyphs.push({ unicode: 0xF000, code: 0xF000, glyph: &#x27;.notdef&#x27; });
        ids.push(0);
      }

      // Converting glyphs and ids into font&#x27;s cmap table
      tables.cmap.data = createCmapTable(glyphs, ids);
      var unicodeIsEnabled = [];
      for (var i = 0, ii = glyphs.length; i &lt; ii; i++) {
        unicodeIsEnabled[glyphs[i].unicode] = true;
      }
      this.unicodeIsEnabled = unicodeIsEnabled;

      if (!tables[&#x27;OS/2&#x27;] || !validateOS2Table(tables[&#x27;OS/2&#x27;])) {
        // extract some more font properties from the OpenType head and
        // hhea tables; yMin and descent value are always negative
        var override = {
          unitsPerEm: int16([tables.head.data[18], tables.head.data[19]]),
          yMax: int16([tables.head.data[42], tables.head.data[43]]),
          yMin: int16([tables.head.data[38], tables.head.data[39]]) - 0x10000,
          ascent: int16([tables.hhea.data[4], tables.hhea.data[5]]),
          descent: int16([tables.hhea.data[6], tables.hhea.data[7]]) - 0x10000
        };

        tables[&#x27;OS/2&#x27;] = {
          tag: &#x27;OS/2&#x27;,
          data: stringToArray(createOS2Table(properties, glyphs, override))
        };
      }

      // Rewrite the &#x27;post&#x27; table if needed
      if (!tables.post) {
        tables.post = {
          tag: &#x27;post&#x27;,
          data: stringToArray(createPostTable(properties))
        };
      }

      if (!isTrueType) {
        try {
          // Trying to repair CFF file
          var cffFile = new Stream(tables[&#x27;CFF &#x27;].data);
          var parser = new CFFParser(cffFile, properties);
          var cff = parser.parse();
          var compiler = new CFFCompiler(cff);
          tables[&#x27;CFF &#x27;].data = compiler.compile();
        } catch (e) {
          warn(&#x27;Failed to compile font &#x27; + properties.loadedName);
        }
      }

      // Re-creating &#x27;name&#x27; table
      if (!tables.name) {
        tables.name = {
          tag: &#x27;name&#x27;,
          data: stringToArray(createNameTable(this.name))
        };
      } else {
        // ... using existing &#x27;name&#x27; table as prototype
        var namePrototype = readNameTable(tables.name);
        tables.name.data = stringToArray(createNameTable(name, namePrototype));
      }

      // rewrite the tables but tweak offsets
      for (var i = 0; i &lt; numTables; i++) {
        var table = tables[tablesNames[i]];
        var data = [];

        var tableData = table.data;
        for (var j = 0, jj = tableData.length; j &lt; jj; j++)
          data.push(tableData[j]);
        createTableEntry(ttf, table.tag, data);
      }

      // Add the table datas
      for (var i = 0; i &lt; numTables; i++) {
        var table = tables[tablesNames[i]];
        var tableData = table.data;
        ttf.file += arrayToString(tableData);

        // 4-byte aligned data
        while (ttf.file.length &amp; 3)
          ttf.file += String.fromCharCode(0);
      }

      return stringToArray(ttf.file);
    },

    convert: function Font_convert(fontName, font, properties) {
      function isFixedPitch(glyphs) {
        for (var i = 0, ii = glyphs.length - 1; i &lt; ii; i++) {
          if (glyphs[i] != glyphs[i + 1])
            return false;
        }
        return true;
      }

      // The offsets object holds at the same time a representation of where
      // to write the table entry information about a table and another offset
      // representing the offset where to draw the actual data of a particular
      // table
      var REQ_TABLES_CNT = 9;

      var otf = {
        file: &#x27;&#x27;,
        virtualOffset: 9 * (4 * 4)
      };

      createOpenTypeHeader(&#x27;\x4F\x54\x54\x4F&#x27;, otf, 9);

      var charstrings = font.charstrings;
      properties.fixedPitch = isFixedPitch(charstrings);

      var glyphNameMap = {};
      for (var i = 0; i &lt; charstrings.length; ++i) {
        var charstring = charstrings[i];
        glyphNameMap[charstring.glyph] = charstring.unicode;
      }
      this.glyphNameMap = glyphNameMap;

      var seacs = font.seacs;
      if (SEAC_ANALYSIS_ENABLED &amp;&amp; seacs) {
        var seacMap = [];
        var matrix = properties.fontMatrix || FONT_IDENTITY_MATRIX;
        for (var i = 0; i &lt; charstrings.length; ++i) {
          var charstring = charstrings[i];
          var seac = seacs[charstring.gid];
          if (!seac) {
            continue;
          }
          var baseGlyphName = Encodings.StandardEncoding[seac[2]];
          var baseUnicode = glyphNameMap[baseGlyphName];
          var accentGlyphName = Encodings.StandardEncoding[seac[3]];
          var accentUnicode = glyphNameMap[accentGlyphName];
          if (!baseUnicode || !accentUnicode) {
            continue;
          }
          var accentOffset = {
            x: seac[0] * matrix[0] + seac[1] * matrix[2] + matrix[4],
            y: seac[0] * matrix[1] + seac[1] * matrix[3] + matrix[5]
          };
          seacMap[charstring.unicode] = {
            baseUnicode: baseUnicode,
            accentUnicode: accentUnicode,
            accentOffset: accentOffset
          };
        }
        properties.seacMap = seacMap;
      }

      if (!properties.hasEncoding &amp;&amp; (properties.subtype == &#x27;Type1C&#x27; ||
          properties.subtype == &#x27;CIDFontType0C&#x27;)) {
        var encoding = [];
        for (var i = 0; i &lt; charstrings.length; ++i) {
          var charstring = charstrings[i];
          encoding[charstring.code] = charstring.glyph;
        }
        properties.baseEncoding = encoding;
      }
      if (properties.subtype == &#x27;CIDFontType0C&#x27;) {
        var toFontChar = [];
        for (var i = 0; i &lt; charstrings.length; ++i) {
          var charstring = charstrings[i];
          toFontChar[charstring.code] = charstring.unicode;
        }
        this.toFontChar = toFontChar;
      }
      var unitsPerEm = 1 / (properties.fontMatrix || FONT_IDENTITY_MATRIX)[0];

      var fields = {
        // PostScript Font Program
        &#x27;CFF &#x27;: font.data,

        // OS/2 and Windows Specific metrics
        &#x27;OS/2&#x27;: stringToArray(createOS2Table(properties, charstrings)),

        // Character to glyphs mapping
        &#x27;cmap&#x27;: createCmapTable(charstrings.slice(),
                                (&#x27;glyphIds&#x27; in font) ? font.glyphIds : null),

        // Font header
        &#x27;head&#x27;: (function fontFieldsHead() {
          return stringToArray(
              &#x27;\x00\x01\x00\x00&#x27; + // Version number
              &#x27;\x00\x00\x10\x00&#x27; + // fontRevision
              &#x27;\x00\x00\x00\x00&#x27; + // checksumAdjustement
              &#x27;\x5F\x0F\x3C\xF5&#x27; + // magicNumber
              &#x27;\x00\x00&#x27; + // Flags
              safeString16(unitsPerEm) + // unitsPerEM
              &#x27;\x00\x00\x00\x00\x9e\x0b\x7e\x27&#x27; + // creation date
              &#x27;\x00\x00\x00\x00\x9e\x0b\x7e\x27&#x27; + // modifification date
              &#x27;\x00\x00&#x27; + // xMin
              safeString16(properties.descent) + // yMin
              &#x27;\x0F\xFF&#x27; + // xMax
              safeString16(properties.ascent) + // yMax
              string16(properties.italicAngle ? 2 : 0) + // macStyle
              &#x27;\x00\x11&#x27; + // lowestRecPPEM
              &#x27;\x00\x00&#x27; + // fontDirectionHint
              &#x27;\x00\x00&#x27; + // indexToLocFormat
              &#x27;\x00\x00&#x27;);  // glyphDataFormat
        })(),

        // Horizontal header
        &#x27;hhea&#x27;: (function fontFieldsHhea() {
          return stringToArray(
              &#x27;\x00\x01\x00\x00&#x27; + // Version number
              safeString16(properties.ascent) + // Typographic Ascent
              safeString16(properties.descent) + // Typographic Descent
              &#x27;\x00\x00&#x27; + // Line Gap
              &#x27;\xFF\xFF&#x27; + // advanceWidthMax
              &#x27;\x00\x00&#x27; + // minLeftSidebearing
              &#x27;\x00\x00&#x27; + // minRightSidebearing
              &#x27;\x00\x00&#x27; + // xMaxExtent
              safeString16(properties.capHeight) + // caretSlopeRise
              safeString16(Math.tan(properties.italicAngle) *
                       properties.xHeight) + // caretSlopeRun
              &#x27;\x00\x00&#x27; + // caretOffset
              &#x27;\x00\x00&#x27; + // -reserved-
              &#x27;\x00\x00&#x27; + // -reserved-
              &#x27;\x00\x00&#x27; + // -reserved-
              &#x27;\x00\x00&#x27; + // -reserved-
              &#x27;\x00\x00&#x27; + // metricDataFormat
              string16(charstrings.length + 1)); // Number of HMetrics
        })(),

        // Horizontal metrics
        &#x27;hmtx&#x27;: (function fontFieldsHmtx() {
          var hmtx = &#x27;\x00\x00\x00\x00&#x27;; // Fake .notdef
          for (var i = 0, ii = charstrings.length; i &lt; ii; i++) {
            var charstring = charstrings[i];
            var width = &#x27;width&#x27; in charstring ? charstring.width : 0;
            hmtx += string16(width) + string16(0);
          }
          return stringToArray(hmtx);
        })(),

        // Maximum profile
        &#x27;maxp&#x27;: (function fontFieldsMaxp() {
          return stringToArray(
              &#x27;\x00\x00\x50\x00&#x27; + // Version number
             string16(charstrings.length + 1)); // Num of glyphs
        })(),

        // Naming tables
        &#x27;name&#x27;: stringToArray(createNameTable(fontName)),

        // PostScript informations
        &#x27;post&#x27;: stringToArray(createPostTable(properties))
      };

      for (var field in fields)
        createTableEntry(otf, field, fields[field]);

      for (var field in fields) {
        var table = fields[field];
        otf.file += arrayToString(table);
      }

      return stringToArray(otf.file);
    },

    buildToFontChar: function Font_buildToFontChar(toUnicode) {
      var result = [];
      var unusedUnicode = CMAP_GLYPH_OFFSET;
      for (var i = 0, ii = toUnicode.length; i &lt; ii; i++) {
        var unicode = toUnicode[i];
        var fontCharCode = typeof unicode === &#x27;object&#x27; ? unusedUnicode++ :
          unicode;
        if (typeof unicode !== &#x27;undefined&#x27;)
          result[i] = fontCharCode;
      }
      return result;
    },

    rebuildToUnicode: function Font_rebuildToUnicode(properties) {
      var firstChar = properties.firstChar, lastChar = properties.lastChar;
      var map = [];
      var toUnicode = this.toUnicode || this.cidToUnicode;
      if (toUnicode) {
        var isIdentityMap = toUnicode.length === 0;
        for (var i = firstChar, ii = lastChar; i &lt;= ii; i++) {
          // TODO missing map the character according font&#x27;s CMap
          map[i] = isIdentityMap ? i : toUnicode[i];
        }
      } else {
        for (var i = firstChar, ii = lastChar; i &lt;= ii; i++) {
          var glyph = properties.differences[i];
          if (!glyph)
            glyph = properties.baseEncoding[i];
          if (!!glyph &amp;&amp; (glyph in GlyphsUnicode))
            map[i] = GlyphsUnicode[glyph];
        }
      }
      this.toUnicode = map;
    },

    loadCidToUnicode: function Font_loadCidToUnicode(properties) {
      if (!properties.cidSystemInfo)
        return;

      var cidToUnicodeMap = [], unicodeToCIDMap = [];
      this.cidToUnicode = cidToUnicodeMap;
      this.unicodeToCID = unicodeToCIDMap;

      var cidEncoding = properties.cidEncoding;
      if (properties.toUnicode) {
        if (cidEncoding &amp;&amp; cidEncoding.indexOf(&#x27;Identity-&#x27;) !== 0) {
          TODO(&#x27;Need to create a reverse mapping from \&#x27;ToUnicode\&#x27; CMap&#x27;);
        }
        return; // &#x27;ToUnicode&#x27; CMap will be used
      }

      var cidSystemInfo = properties.cidSystemInfo;
      var cidToUnicode;
      if (cidSystemInfo) {
        cidToUnicode = CIDToUnicodeMaps[
          cidSystemInfo.registry + &#x27;-&#x27; + cidSystemInfo.ordering];
      }

      if (!cidToUnicode)
        return; // identity encoding

      var overwrite = HalfwidthCMaps[cidEncoding];
      var cid = 1, i, j, k, ii;
      for (i = 0, ii = cidToUnicode.length; i &lt; ii; ++i) {
        var unicode = cidToUnicode[i];
        if (isArray(unicode)) {
          var length = unicode.length;
          for (j = 0; j &lt; length; j++) {
            cidToUnicodeMap[cid] = k = unicode[j];
            if (!unicodeToCIDMap[k] || overwrite) {
              unicodeToCIDMap[k] = cid;
            }
          }
          cid++;
        } else if (typeof unicode === &#x27;object&#x27;) {
          var fillLength = unicode.f;
          if (fillLength) {
            k = unicode.c;
            for (j = 0; j &lt; fillLength; ++j) {
              cidToUnicodeMap[cid] = k;
              if (!unicodeToCIDMap[k] || overwrite) {
                unicodeToCIDMap[k] = cid;
              }
              cid++;
              k++;
            }
          } else
            cid += unicode.s;
        } else if (unicode) {
          cidToUnicodeMap[cid] = unicode;
          if (!unicodeToCIDMap[unicode] || overwrite) {
            unicodeToCIDMap[unicode] = cid;
          }
          cid++;
        } else
          cid++;
      }

      if (!cidEncoding) {
        return;
      }
      if (cidEncoding.indexOf(&#x27;Identity-&#x27;) !== 0) {
        // input is already Unicode for non-Identity CMap encodings.
        this.cidToUnicode = [];
        // For CIDFontType2, however, we need cid-to-Unicode conversion
        // to rebuild cmap.
        if (properties.type == &#x27;CIDFontType2&#x27;) {
          this.cidToFontChar = cidToUnicodeMap;
        }
      } else {
        // We don&#x27;t have to do reverse conversions if the string is
        // already CID.
        this.unicodeToCID = [];
      }
    },

    get spaceWidth() {
      if (&#x27;_shadowWidth&#x27; in this) {
        return this._shadowWidth;
      }

      // trying to estimate space character width
      var possibleSpaceReplacements = [&#x27;space&#x27;, &#x27;minus&#x27;, &#x27;one&#x27;, &#x27;i&#x27;];
      var width;
      for (var i = 0, ii = possibleSpaceReplacements.length; i &lt; ii; i++) {
        var glyphName = possibleSpaceReplacements[i];
        // if possible, getting width by glyph name
        if (glyphName in this.widths) {
          width = this.widths[glyphName];
          break;
        }
        var glyphUnicode = GlyphsUnicode[glyphName];
        // finding the charcode via unicodeToCID map
        var charcode = 0;
        if (this.composite)
          charcode = this.unicodeToCID[glyphUnicode];
        // ... via toUnicode map
        if (!charcode &amp;&amp; &#x27;toUnicode&#x27; in this)
          charcode = this.toUnicode.indexOf(glyphUnicode);
        // setting it to unicode if negative or undefined
        if (charcode &lt;= 0)
          charcode = glyphUnicode;
        // trying to get width via charcode
        width = this.widths[charcode];
        if (width)
          break; // the non-zero width found
      }
      width = width || this.defaultWidth;
      // Do not shadow the property here. See discussion:
      // https://github.com/mozilla/pdf.js/pull/2127#discussion_r1662280
      this._shadowWidth = width;
      return width;
    },

    charToGlyph: function Font_charToGlyph(charcode) {
      var fontCharCode, width, operatorList, disabled;

      var width = this.widths[charcode];
      var vmetric = this.vmetrics &amp;&amp; this.vmetrics[charcode];

      switch (this.type) {
        case &#x27;CIDFontType0&#x27;:
          var cid = this.unicodeToCID[charcode] || charcode;
          if (this.unicodeToCID.length &gt; 0) {
            width = this.widths[cid];
            vmetric = this.vmetrics &amp;&amp; this.vmetrics[cid];
          }
          if (this.noUnicodeAdaptation) {
            fontCharCode = this.toFontChar[charcode] || charcode;
            break;
          }
          // CIDFontType0 is not encoded in Unicode.
          fontCharCode = this.toFontChar[cid] || cid;
          break;
        case &#x27;CIDFontType2&#x27;:
          if (this.unicodeToCID.length &gt; 0) {
            var cid = this.unicodeToCID[charcode] || charcode;
            width = this.widths[cid];
            vmetric = this.vmetrics &amp;&amp; this.vmetrics[cid];
            fontCharCode = charcode;
            break;
          }
          fontCharCode = this.toFontChar[charcode] || charcode;
          break;
        case &#x27;MMType1&#x27;: // XXX at the moment only &quot;standard&quot; fonts are supported
        case &#x27;Type1&#x27;:
          var glyphName = this.differences[charcode] || this.encoding[charcode];
          if (!isNum(width))
            width = this.widths[glyphName];
          if (this.noUnicodeAdaptation) {
            fontCharCode = mapPrivateUseChars(GlyphsUnicode[glyphName] ||
              charcode);
            break;
          }
          fontCharCode = this.glyphNameMap[glyphName] ||
            GlyphsUnicode[glyphName] || charcode;
          break;
        case &#x27;Type3&#x27;:
          var glyphName = this.differences[charcode] || this.encoding[charcode];
          operatorList = this.charProcOperatorList[glyphName];
          fontCharCode = charcode;
          break;
        case &#x27;TrueType&#x27;:
          if (this.useToFontChar) {
            fontCharCode = this.toFontChar[charcode] || charcode;
            break;
          }
          var glyphName = this.differences[charcode] || this.encoding[charcode];
          if (!glyphName)
            glyphName = Encodings.StandardEncoding[charcode];
          if (!isNum(width))
            width = this.widths[glyphName];
          if (this.noUnicodeAdaptation) {
            fontCharCode = GlyphsUnicode[glyphName] || charcode;
            break;
          }
          if (!this.hasEncoding || this.isSymbolicFont) {
            fontCharCode = this.useToFontChar ? this.toFontChar[charcode] :
              charcode;
            break;
          }

          // MacRoman encoding address by re-encoding the cmap table

          fontCharCode = glyphName in this.glyphNameMap ?
            this.glyphNameMap[glyphName] : GlyphsUnicode[glyphName];
          break;
        default:
          warn(&#x27;Unsupported font type: &#x27; + this.type);
          break;
      }

      var unicodeChars = !(&#x27;toUnicode&#x27; in this) ? charcode :
        this.toUnicode[charcode] || charcode;
      if (typeof unicodeChars === &#x27;number&#x27;) {
        unicodeChars = String.fromCharCode(unicodeChars);
      }

      width = isNum(width) ? width : this.defaultWidth;
      disabled = this.unicodeIsEnabled ?
        !this.unicodeIsEnabled[fontCharCode] : false;

      var accent = null;
      if (this.seacMap &amp;&amp; this.seacMap[fontCharCode]) {
        var seac = this.seacMap[fontCharCode];
        fontCharCode = seac.baseUnicode;
        accent = {
          fontChar: String.fromCharCode(seac.accentUnicode),
          offset: seac.accentOffset
        };
      }

      return {
        fontChar: String.fromCharCode(fontCharCode),
        unicode: unicodeChars,
        accent: accent,
        width: width,
        vmetric: vmetric,
        disabled: disabled,
        operatorList: operatorList
      };
    },

    charsToGlyphs: function Font_charsToGlyphs(chars) {
      var charsCache = this.charsCache;
      var glyphs;

      // if we translated this string before, just grab it from the cache
      if (charsCache) {
        glyphs = charsCache[chars];
        if (glyphs)
          return glyphs;
      }

      // lazily create the translation cache
      if (!charsCache)
        charsCache = this.charsCache = Object.create(null);

      glyphs = [];
      var charsCacheKey = chars;

      var converter;
      var cidEncoding = this.cidEncoding;
      if (cidEncoding) {
        converter = CMapConverterList[cidEncoding];
        if (converter) {
          chars = converter(chars);
        } else if (cidEncoding.indexOf(&#x27;Uni&#x27;) !== 0 &amp;&amp;
                   cidEncoding.indexOf(&#x27;Identity-&#x27;) !== 0) {
          warn(&#x27;Unsupported CMap: &#x27; + cidEncoding);
        }
      }
      if (!converter &amp;&amp; this.wideChars) {
        // composite fonts have multi-byte strings convert the string from
        // single-byte to multi-byte
        // XXX assuming CIDFonts are two-byte - later need to extract the
        // correct byte encoding according to the PDF spec
        var length = chars.length - 1; // looping over two bytes at a time so
                                       // loop should never end on the last byte
        for (var i = 0; i &lt; length; i++) {
          var charcode = int16([chars.charCodeAt(i++), chars.charCodeAt(i)]);
          var glyph = this.charToGlyph(charcode);
          glyphs.push(glyph);
          // placing null after each word break charcode (ASCII SPACE)
          if (charcode == 0x20)
            glyphs.push(null);
        }
      }
      else {
        for (var i = 0, ii = chars.length; i &lt; ii; ++i) {
          var charcode = chars.charCodeAt(i);
          var glyph = this.charToGlyph(charcode);
          glyphs.push(glyph);
          if (charcode == 0x20)
            glyphs.push(null);
        }
      }

      // Enter the translated string into the cache
      return (charsCache[charsCacheKey] = glyphs);
    }
  };

  return Font;
})();

var ErrorFont = (function ErrorFontClosure() {
  function ErrorFont(error) {
    this.error = error;
  }

  ErrorFont.prototype = {
    charsToGlyphs: function ErrorFont_charsToGlyphs() {
      return [];
    },
    exportData: function ErrorFont_exportData() {
      return {error: this.error};
    }
  };

  return ErrorFont;
})();

/*
 * CharStrings are encoded following the the CharString Encoding sequence
 * describe in Chapter 6 of the &quot;Adobe Type1 Font Format&quot; specification.
 * The value in a byte indicates a command, a number, or subsequent bytes
 * that are to be interpreted in a special way.
 *
 * CharString Number Encoding:
 *  A CharString byte containing the values from 32 through 255 inclusive
 *  indicate an integer. These values are decoded in four ranges.
 *
 * 1. A CharString byte containing a value, v, between 32 and 246 inclusive,
 * indicate the integer v - 139. Thus, the integer values from -107 through
 * 107 inclusive may be encoded in single byte.
 *
 * 2. A CharString byte containing a value, v, between 247 and 250 inclusive,
 * indicates an integer involving the next byte, w, according to the formula:
 * [(v - 247) x 256] + w + 108
 *
 * 3. A CharString byte containing a value, v, between 251 and 254 inclusive,
 * indicates an integer involving the next byte, w, according to the formula:
 * -[(v - 251) * 256] - w - 108
 *
 * 4. A CharString containing the value 255 indicates that the next 4 bytes
 * are a two complement signed integer. The first of these bytes contains the
 * highest order bits, the second byte contains the next higher order bits
 * and the fourth byte contain the lowest order bits.
 *
 *
 * CharString Command Encoding:
 *  CharStrings commands are encoded in 1 or 2 bytes.
 *
 *  Single byte commands are encoded in 1 byte that contains a value between
 *  0 and 31 inclusive.
 *  If a command byte contains the value 12, then the value in the next byte
 *  indicates a command. This &quot;escape&quot; mechanism allows many extra commands
 * to be encoded and this encoding technique helps to minimize the length of
 * the charStrings.
 */
var Type1CharString = (function Type1CharStringClosure() {
  var COMMAND_MAP = {
    &#x27;hstem&#x27;: [1],
    &#x27;vstem&#x27;: [3],
    &#x27;vmoveto&#x27;: [4],
    &#x27;rlineto&#x27;: [5],
    &#x27;hlineto&#x27;: [6],
    &#x27;vlineto&#x27;: [7],
    &#x27;rrcurveto&#x27;: [8],
    &#x27;callsubr&#x27;: [10],
    &#x27;flex&#x27;: [12, 35],
    &#x27;drop&#x27; : [12, 18],
    &#x27;endchar&#x27;: [14],
    &#x27;rmoveto&#x27;: [21],
    &#x27;hmoveto&#x27;: [22],
    &#x27;vhcurveto&#x27;: [30],
    &#x27;hvcurveto&#x27;: [31]
  };

  function Type1CharString() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }

  Type1CharString.prototype = {
    convert: function Type1CharString_convert(encoded, subrs) {
      var count = encoded.length;
      var error = false;
      for (var i = 0; i &lt; count; i++) {
        var value = encoded[i];
        if (value &lt; 32) {
          if (value === 12) {
            value = (value &lt;&lt; 8) + encoded[++i];
          }
          switch (value) {
            case 1: // hstem
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;
            case 3: // vstem
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;
            case 4: // vmoveto
              if (this.flexing) {
                if (this.stack.length &lt; 1) {
                  error = true;
                  break;
                }
                // Add the dx for flex and but also swap the values so they are
                // the right order.
                var dy = this.stack.pop();
                this.stack.push(0, dy);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.vmoveto);
              break;
            case 5: // rlineto
              error = this.executeCommand(2, COMMAND_MAP.rlineto);
              break;
            case 6: // hlineto
              error = this.executeCommand(1, COMMAND_MAP.hlineto);
              break;
            case 7: // vlineto
              error = this.executeCommand(1, COMMAND_MAP.vlineto);
              break;
            case 8: // rrcurveto
              error = this.executeCommand(6, COMMAND_MAP.rrcurveto);
              break;
            case 9: // closepath
              // closepath is a Type1 command that does not take argument and is
              // useless in Type2 and it can simply be ignored.
              this.stack = [];
              break;
            case 10: // callsubr
              if (this.stack.length &lt; 1) {
                error = true;
                break;
              }
              var subrNumber = this.stack.pop();
              error = this.convert(subrs[subrNumber], subrs);
              break;
            case 11: // return
              return error;
            case 13: // hsbw
              if (this.stack.length &lt; 2) {
                error = true;
                break;
              }
              // To convert to type2 we have to move the width value to the
              // first part of the charstring and then use hmoveto with lsb.
              var wx = this.stack.pop();
              var sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(sbx);
              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;
            case 14: // endchar
              this.output.push(COMMAND_MAP.endchar[0]);
              break;
            case 21: // rmoveto
              if (this.flexing) {
                break;
              }
              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;
            case 22: // hmoveto
              if (this.flexing) {
                // Add the dy for flex.
                this.stack.push(0);
                break;
              }
              error = this.executeCommand(1, COMMAND_MAP.hmoveto);
              break;
            case 30: // vhcurveto
              error = this.executeCommand(4, COMMAND_MAP.vhcurveto);
              break;
            case 31: // hvcurveto
              error = this.executeCommand(4, COMMAND_MAP.hvcurveto);
              break;
            case (12 &lt;&lt; 8) + 0: // dotsection
              // dotsection is a Type1 command to specify some hinting feature
              // for dots that do not take a parameter and it can safely be
              // ignored for Type2.
              this.stack = [];
              break;
            case (12 &lt;&lt; 8) + 1: // vstem3
              if (!HINTING_ENABLED) {
                this.stack = [];
                break;
              }
              // [vh]stem3 are Type1 only and Type2 supports [vh]stem with
              // multiple parameters, so instead of returning [vh]stem3 take a
              // shortcut and return [vhstem] instead.
              error = this.executeCommand(2, COMMAND_MAP.vstem);
              break;
            case (12 &lt;&lt; 8) + 2: // hstem3
              if (!HINTING_ENABLED) {
                 this.stack = [];
                break;
              }
              // See vstem3.
              error = this.executeCommand(2, COMMAND_MAP.hstem);
              break;
            case (12 &lt;&lt; 8) + 6: // seac
              // seac is like type 2&#x27;s special endchar but it doesn&#x27;t use the
              // first argument asb, so remove it.
              if (SEAC_ANALYSIS_ENABLED) {
                this.seac = this.stack.splice(-4, 4);
                error = this.executeCommand(0, COMMAND_MAP.endchar);
              } else {
                error = this.executeCommand(4, COMMAND_MAP.endchar);
              }
              break;
            case (12 &lt;&lt; 8) + 7: // sbw
              if (this.stack.length &lt; 4) {
                error = true;
                break;
              }
              // To convert to type2 we have to move the width value to the
              // first part of the charstring and then use rmoveto with
              // (dx, dy). The height argument will not be used for vmtx and
              // vhea tables reconstruction -- ignoring it.
              var wy = this.stack.pop();
              var wx = this.stack.pop();
              var sby = this.stack.pop();
              var sbx = this.stack.pop();
              this.lsb = sbx;
              this.width = wx;
              this.stack.push(sbx, sby);
              error = this.executeCommand(2, COMMAND_MAP.rmoveto);
              break;
            case (12 &lt;&lt; 8) + 12: // div
              if (this.stack.length &lt; 2) {
                error = true;
                break;
              }
              var num2 = this.stack.pop();
              var num1 = this.stack.pop();
              this.stack.push(num1 / num2);
              break;
            case (12 &lt;&lt; 8) + 16: // callothersubr
              if (this.stack.length &lt; 2) {
                error = true;
                break;
              }
              var subrNumber = this.stack.pop();
              var numArgs = this.stack.pop();
              if (subrNumber === 0 &amp;&amp; numArgs === 3) {
                var flexArgs = this.stack.splice(this.stack.length - 17, 17);
                this.stack.push(
                  flexArgs[2] + flexArgs[0], // bcp1x + rpx
                  flexArgs[3] + flexArgs[1], // bcp1y + rpy
                  flexArgs[4], // bcp2x
                  flexArgs[5], // bcp2y
                  flexArgs[6], // p2x
                  flexArgs[7], // p2y
                  flexArgs[8], // bcp3x
                  flexArgs[9], // bcp3y
                  flexArgs[10], // bcp4x
                  flexArgs[11], // bcp4y
                  flexArgs[12], // p3x
                  flexArgs[13], // p3y
                  flexArgs[14] // flexDepth
                  // 15 = finalx unused by flex
                  // 16 = finaly unused by flex
                );
                error = this.executeCommand(13, COMMAND_MAP.flex, true);
                this.flexing = false;
                this.stack.push(flexArgs[15], flexArgs[16]);
              } else if (subrNumber === 1 &amp;&amp; numArgs === 0) {
                this.flexing = true;
              }
              break;
            case (12 &lt;&lt; 8) + 17: // pop
              // Ignore this since it is only used with othersubr.
              break;
            case (12 &lt;&lt; 8) + 33: // setcurrentpoint
              // Ignore for now.
              this.stack = [];
              break;
            default:
              warn(&#x27;Unknown type 1 charstring command of &quot;&#x27; + value + &#x27;&quot;&#x27;);
              break;
          }
          if (error) {
            break;
          }
          continue;
        } else if (value &lt;= 246) {
          value = value - 139;
        } else if (value &lt;= 250) {
          value = ((value - 247) * 256) + encoded[++i] + 108;
        } else if (value &lt;= 254) {
          value = -((value - 251) * 256) - encoded[++i] - 108;
        } else {
          value = (encoded[++i] &amp; 0xff) &lt;&lt; 24 | (encoded[++i] &amp; 0xff) &lt;&lt; 16 |
                  (encoded[++i] &amp; 0xff) &lt;&lt; 8 | (encoded[++i] &amp; 0xff) &lt;&lt; 0;
        }
        this.stack.push(value);
      }
      return error;
    },

    executeCommand: function(howManyArgs, command, keepStack) {
      var stackLength = this.stack.length;
      if (howManyArgs &gt; stackLength) {
        return true;
      }
      var start = stackLength - howManyArgs;
      for (var i = start; i &lt; stackLength; i++) {
        var value = this.stack[i];
        if (value === (value | 0)) { // int
          this.output.push(28, (value &gt;&gt; 8) &amp; 0xff, value &amp; 0xff);
        } else { // fixed point
          value = (65536 * value) | 0;
          this.output.push(255,
                           (value &gt;&gt; 24) &amp; 0xFF,
                           (value &gt;&gt; 16) &amp; 0xFF,
                           (value &gt;&gt; 8) &amp; 0xFF,
                           value &amp; 0xFF);
        }
      }
      this.output.push.apply(this.output, command);
      if (keepStack) {
        this.stack.splice(start, howManyArgs);
      } else {
        this.stack = [];
      }
      return false;
    }
  };

  return Type1CharString;
})();

/*
 * Type1Parser encapsulate the needed code for parsing a Type1 font
 * program. Some of its logic depends on the Type2 charstrings
 * structure.
 * Note: this doesn&#x27;t really parse the font since that would require evaluation
 * of PostScript, but it is possible in most cases to extract what we need
 * without a full parse.
 */
var Type1Parser = (function Type1ParserClosure() {
  /*
   * Decrypt a Sequence of Ciphertext Bytes to Produce the Original Sequence
   * of Plaintext Bytes. The function took a key as a parameter which can be
   * for decrypting the eexec block of for decoding charStrings.
   */
  var EEXEC_ENCRYPT_KEY = 55665;
  var CHAR_STRS_ENCRYPT_KEY = 4330;

  function decrypt(stream, key, discardNumber) {
    var r = key, c1 = 52845, c2 = 22719;
    var decryptedString = [];

    var value = &#x27;&#x27;;
    var count = stream.length;
    for (var i = 0; i &lt; count; i++) {
      value = stream[i];
      decryptedString[i] = value ^ (r &gt;&gt; 8);
      r = ((value + r) * c1 + c2) &amp; ((1 &lt;&lt; 16) - 1);
    }
    return decryptedString.slice(discardNumber);
  }

  function isSpecial(c) {
    return c === 0x2F || // &#x27;/&#x27;
           c === 0x5B || c === 0x5D || // &#x27;[&#x27;, &#x27;]&#x27;
           c === 0x7B || c === 0x7D || // &#x27;{&#x27;, &#x27;}&#x27;
           c === 0x28 || c === 0x29; // &#x27;(&#x27;, &#x27;)&#x27;
  }

  function Type1Parser(stream, encrypted) {
    if (encrypted) {
      stream = new Stream(decrypt(stream.getBytes(), EEXEC_ENCRYPT_KEY, 4));
    }
    this.stream = stream;
    this.nextChar();
  }

  Type1Parser.prototype = {
    readNumberArray: function Type1Parser_readNumberArray() {
      this.getToken(); // read &#x27;[&#x27; or &#x27;{&#x27; (arrays can start with either)
      var array = [];
      while (true) {
        var token = this.getToken();
        if (token === null || token === &#x27;]&#x27; || token === &#x27;}&#x27;) {
          break;
        }
        array.push(parseFloat(token || 0));
      }
      return array;
    },

    readNumber: function Type1Parser_readNumber() {
      var token = this.getToken();
      return parseFloat(token || 0);
    },

    readInt: function Type1Parser_readInt() {
      // Use &#x27;| 0&#x27; to prevent setting a double into length such as the double
      // does not flow into the loop variable.
      var token = this.getToken();
      return parseInt(token || 0, 10) | 0;
    },

    readBoolean: function Type1Parser_readBoolean() {
      var token = this.getToken();

      // Use 1 and 0 since that&#x27;s what type2 charstrings use.
      return token === &#x27;true&#x27; ? 1 : 0;
    },

    nextChar : function Type1_nextChar() {
      return (this.currentChar = this.stream.getByte());
    },

    getToken: function Type1Parser_getToken() {
      // Eat whitespace and comments.
      var comment = false;
      var ch = this.currentChar;
      while (true) {
        if (ch === -1) {
          return null;
        }

        if (comment) {
          if (ch === 0x0A || ch === 0x0D) {
            comment = false;
          }
        } else if (ch === 0x25) { // &#x27;%&#x27;
          comment = true;
        } else if (!Lexer.isSpace(ch)) {
          break;
        }
        ch = this.nextChar();
      }
      if (isSpecial(ch)) {
        this.nextChar();
        return String.fromCharCode(ch);
      }
      var token = &#x27;&#x27;;
      do {
        token += String.fromCharCode(ch);
        ch = this.nextChar();
      } while (ch &gt;= 0 &amp;&amp; !Lexer.isSpace(ch) &amp;&amp; !isSpecial(ch));
      return token;
    },

    /*
     * Returns an object containing a Subrs array and a CharStrings
     * array extracted from and eexec encrypted block of data
     */
    extractFontProgram: function Type1Parser_extractFontProgram() {
      var stream = this.stream;

      var subrs = [], charstrings = [];
      var program = {
        subrs: [],
        charstrings: [],
        properties: {
          &#x27;privateData&#x27;: {
            &#x27;lenIV&#x27;: 4
          }
        }
      };
      var token;
      while ((token = this.getToken()) !== null) {
        if (token !== &#x27;/&#x27;) {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case &#x27;CharStrings&#x27;:
            // The number immediately following CharStrings must be greater or
            // equal to the number of CharStrings.
            this.getToken();
            this.getToken(); // read in &#x27;dict&#x27;
            this.getToken(); // read in &#x27;dup&#x27;
            this.getToken(); // read in &#x27;begin&#x27;
            while(true) {
              token = this.getToken();
              if (token === null || token === &#x27;end&#x27;) {
                break;
              }

              if (token !== &#x27;/&#x27;) {
                continue;
              }
              var glyph = this.getToken();
              var length = this.readInt();
              this.getToken(); // read in &#x27;RD&#x27; or &#x27;-|&#x27;
              var data = stream.makeSubStream(stream.pos, length);
              var lenIV = program.properties.privateData[&#x27;lenIV&#x27;];
              var encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY,
                                    lenIV);
              // Skip past the required space and binary data.
              stream.skip(length);
              this.nextChar();
              token = this.getToken(); // read in &#x27;ND&#x27; or &#x27;|-&#x27;
              if (token === &#x27;noaccess&#x27;) {
                this.getToken(); // read in &#x27;def&#x27;
              }
              charstrings.push({
                glyph: glyph,
                encoded: encoded
              });
            }
            break;
          case &#x27;Subrs&#x27;:
            var num = this.readInt();
            this.getToken(); // read in &#x27;array&#x27;
            while ((token = this.getToken()) === &#x27;dup&#x27;) {
              var index = this.readInt();
              var length = this.readInt();
              this.getToken(); // read in &#x27;RD&#x27; or &#x27;-|&#x27;
              var data = stream.makeSubStream(stream.pos, length);
              var lenIV = program.properties.privateData[&#x27;lenIV&#x27;];
              var encoded = decrypt(data.getBytes(), CHAR_STRS_ENCRYPT_KEY,
                                    lenIV);
              // Skip past the required space and binary data.
              stream.skip(length);
              this.nextChar();
              token = this.getToken(); // read in &#x27;NP&#x27; or &#x27;|&#x27;
              if (token === &#x27;noaccess&#x27;) {
                this.getToken(); // read in &#x27;put&#x27;
              }
              subrs[index] = encoded;
            }
            break;
          case &#x27;BlueValues&#x27;:
          case &#x27;OtherBlues&#x27;:
          case &#x27;FamilyBlues&#x27;:
          case &#x27;FamilyOtherBlues&#x27;:
            var blueArray = this.readNumberArray();
            // *Blue* values may contain invalid data: disables reading of
            // those values when hinting is disabled.
            if (blueArray.length &gt; 0 &amp;&amp; (blueArray.length % 2) === 0 &amp;&amp;
                HINTING_ENABLED) {
              program.properties.privateData[token] = blueArray;
            }
            break;
          case &#x27;StemSnapH&#x27;:
          case &#x27;StemSnapV&#x27;:
            program.properties.privateData[token] = this.readNumberArray();
            break;
          case &#x27;StdHW&#x27;:
          case &#x27;StdVW&#x27;:
            program.properties.privateData[token] =
              this.readNumberArray()[0];
            break;
          case &#x27;BlueShift&#x27;:
          case &#x27;lenIV&#x27;:
          case &#x27;BlueFuzz&#x27;:
          case &#x27;BlueScale&#x27;:
          case &#x27;LanguageGroup&#x27;:
          case &#x27;ExpansionFactor&#x27;:
            program.properties.privateData[token] = this.readNumber();
            break;
          case &#x27;ForceBold&#x27;:
            program.properties.privateData[token] = this.readBoolean();
            break;
        }
      }

      for (var i = 0; i &lt; charstrings.length; i++) {
        var glyph = charstrings[i].glyph;
        var encoded = charstrings[i].encoded;
        var charString = new Type1CharString();
        var error = charString.convert(encoded, subrs);
        var output = charString.output;
        if (error) {
          // It seems when FreeType encounters an error while evaluating a glyph
          // that it completely ignores the glyph so we&#x27;ll mimic that behaviour
          // here and put an endchar to make the validator happy.
          output = [14];
        }
        program.charstrings.push({
          glyph: glyph,
          data: output,
          seac: charString.seac,
          lsb: charString.lsb,
          width: charString.width
        });
      }

      return program;
    },

    extractFontHeader: function Type1Parser_extractFontHeader(properties) {
      var token;
      while ((token = this.getToken()) !== null) {
        if (token !== &#x27;/&#x27;) {
          continue;
        }
        token = this.getToken();
        switch (token) {
          case &#x27;FontMatrix&#x27;:
            var matrix = this.readNumberArray();
            properties.fontMatrix = matrix;
            break;
          case &#x27;Encoding&#x27;:
            var encodingArg = this.getToken();
            var encoding;
            if (!/^\d+$/.test(encodingArg)) {
              // encoding name is specified
              encoding = Encodings[encodingArg];
            } else {
              encoding = [];
              var size = parseInt(encodingArg, 10) | 0;
              this.getToken(); // read in &#x27;array&#x27;

              for (var j = 0; j &lt; size; j++) {
                var token = this.getToken();
                if (token === &#x27;dup&#x27;) {
                  var index = this.readInt();
                  this.getToken(); // read in &#x27;/&#x27;
                  var glyph = this.getToken();
                  encoding[index] = glyph;
                  this.getToken(); // read the in &#x27;put&#x27;
                }
              }
            }
            if (properties.overridableEncoding &amp;&amp; encoding) {
              properties.baseEncoding = encoding;
              break;
            }
            break;
        }
      }
    }
  };

  return Type1Parser;
})();

/**
 * The CFF class takes a Type1 file and wrap it into a
 * &#x27;Compact Font Format&#x27; which itself embed Type2 charstrings.
 */
var CFFStandardStrings = [
  &#x27;.notdef&#x27;, &#x27;space&#x27;, &#x27;exclam&#x27;, &#x27;quotedbl&#x27;, &#x27;numbersign&#x27;, &#x27;dollar&#x27;, &#x27;percent&#x27;,
  &#x27;ampersand&#x27;, &#x27;quoteright&#x27;, &#x27;parenleft&#x27;, &#x27;parenright&#x27;, &#x27;asterisk&#x27;, &#x27;plus&#x27;,
  &#x27;comma&#x27;, &#x27;hyphen&#x27;, &#x27;period&#x27;, &#x27;slash&#x27;, &#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;,
  &#x27;five&#x27;, &#x27;six&#x27;, &#x27;seven&#x27;, &#x27;eight&#x27;, &#x27;nine&#x27;, &#x27;colon&#x27;, &#x27;semicolon&#x27;, &#x27;less&#x27;,
  &#x27;equal&#x27;, &#x27;greater&#x27;, &#x27;question&#x27;, &#x27;at&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;,
  &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;,
  &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;bracketleft&#x27;, &#x27;backslash&#x27;, &#x27;bracketright&#x27;, &#x27;asciicircum&#x27;,
  &#x27;underscore&#x27;, &#x27;quoteleft&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;,
  &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;,
  &#x27;z&#x27;, &#x27;braceleft&#x27;, &#x27;bar&#x27;, &#x27;braceright&#x27;, &#x27;asciitilde&#x27;, &#x27;exclamdown&#x27;, &#x27;cent&#x27;,
  &#x27;sterling&#x27;, &#x27;fraction&#x27;, &#x27;yen&#x27;, &#x27;florin&#x27;, &#x27;section&#x27;, &#x27;currency&#x27;,
  &#x27;quotesingle&#x27;, &#x27;quotedblleft&#x27;, &#x27;guillemotleft&#x27;, &#x27;guilsinglleft&#x27;,
  &#x27;guilsinglright&#x27;, &#x27;fi&#x27;, &#x27;fl&#x27;, &#x27;endash&#x27;, &#x27;dagger&#x27;, &#x27;daggerdbl&#x27;,
  &#x27;periodcentered&#x27;, &#x27;paragraph&#x27;, &#x27;bullet&#x27;, &#x27;quotesinglbase&#x27;, &#x27;quotedblbase&#x27;,
  &#x27;quotedblright&#x27;, &#x27;guillemotright&#x27;, &#x27;ellipsis&#x27;, &#x27;perthousand&#x27;, &#x27;questiondown&#x27;,
  &#x27;grave&#x27;, &#x27;acute&#x27;, &#x27;circumflex&#x27;, &#x27;tilde&#x27;, &#x27;macron&#x27;, &#x27;breve&#x27;, &#x27;dotaccent&#x27;,
  &#x27;dieresis&#x27;, &#x27;ring&#x27;, &#x27;cedilla&#x27;, &#x27;hungarumlaut&#x27;, &#x27;ogonek&#x27;, &#x27;caron&#x27;, &#x27;emdash&#x27;,
  &#x27;AE&#x27;, &#x27;ordfeminine&#x27;, &#x27;Lslash&#x27;, &#x27;Oslash&#x27;, &#x27;OE&#x27;, &#x27;ordmasculine&#x27;, &#x27;ae&#x27;,
  &#x27;dotlessi&#x27;, &#x27;lslash&#x27;, &#x27;oslash&#x27;, &#x27;oe&#x27;, &#x27;germandbls&#x27;, &#x27;onesuperior&#x27;,
  &#x27;logicalnot&#x27;, &#x27;mu&#x27;, &#x27;trademark&#x27;, &#x27;Eth&#x27;, &#x27;onehalf&#x27;, &#x27;plusminus&#x27;, &#x27;Thorn&#x27;,
  &#x27;onequarter&#x27;, &#x27;divide&#x27;, &#x27;brokenbar&#x27;, &#x27;degree&#x27;, &#x27;thorn&#x27;, &#x27;threequarters&#x27;,
  &#x27;twosuperior&#x27;, &#x27;registered&#x27;, &#x27;minus&#x27;, &#x27;eth&#x27;, &#x27;multiply&#x27;, &#x27;threesuperior&#x27;,
  &#x27;copyright&#x27;, &#x27;Aacute&#x27;, &#x27;Acircumflex&#x27;, &#x27;Adieresis&#x27;, &#x27;Agrave&#x27;, &#x27;Aring&#x27;,
  &#x27;Atilde&#x27;, &#x27;Ccedilla&#x27;, &#x27;Eacute&#x27;, &#x27;Ecircumflex&#x27;, &#x27;Edieresis&#x27;, &#x27;Egrave&#x27;,
  &#x27;Iacute&#x27;, &#x27;Icircumflex&#x27;, &#x27;Idieresis&#x27;, &#x27;Igrave&#x27;, &#x27;Ntilde&#x27;, &#x27;Oacute&#x27;,
  &#x27;Ocircumflex&#x27;, &#x27;Odieresis&#x27;, &#x27;Ograve&#x27;, &#x27;Otilde&#x27;, &#x27;Scaron&#x27;, &#x27;Uacute&#x27;,
  &#x27;Ucircumflex&#x27;, &#x27;Udieresis&#x27;, &#x27;Ugrave&#x27;, &#x27;Yacute&#x27;, &#x27;Ydieresis&#x27;, &#x27;Zcaron&#x27;,
  &#x27;aacute&#x27;, &#x27;acircumflex&#x27;, &#x27;adieresis&#x27;, &#x27;agrave&#x27;, &#x27;aring&#x27;, &#x27;atilde&#x27;,
  &#x27;ccedilla&#x27;, &#x27;eacute&#x27;, &#x27;ecircumflex&#x27;, &#x27;edieresis&#x27;, &#x27;egrave&#x27;, &#x27;iacute&#x27;,
  &#x27;icircumflex&#x27;, &#x27;idieresis&#x27;, &#x27;igrave&#x27;, &#x27;ntilde&#x27;, &#x27;oacute&#x27;, &#x27;ocircumflex&#x27;,
  &#x27;odieresis&#x27;, &#x27;ograve&#x27;, &#x27;otilde&#x27;, &#x27;scaron&#x27;, &#x27;uacute&#x27;, &#x27;ucircumflex&#x27;,
  &#x27;udieresis&#x27;, &#x27;ugrave&#x27;, &#x27;yacute&#x27;, &#x27;ydieresis&#x27;, &#x27;zcaron&#x27;, &#x27;exclamsmall&#x27;,
  &#x27;Hungarumlautsmall&#x27;, &#x27;dollaroldstyle&#x27;, &#x27;dollarsuperior&#x27;, &#x27;ampersandsmall&#x27;,
  &#x27;Acutesmall&#x27;, &#x27;parenleftsuperior&#x27;, &#x27;parenrightsuperior&#x27;, &#x27;266 ff&#x27;,
  &#x27;onedotenleader&#x27;, &#x27;zerooldstyle&#x27;, &#x27;oneoldstyle&#x27;, &#x27;twooldstyle&#x27;,
  &#x27;threeoldstyle&#x27;, &#x27;fouroldstyle&#x27;, &#x27;fiveoldstyle&#x27;, &#x27;sixoldstyle&#x27;,
  &#x27;sevenoldstyle&#x27;, &#x27;eightoldstyle&#x27;, &#x27;nineoldstyle&#x27;, &#x27;commasuperior&#x27;,
  &#x27;threequartersemdash&#x27;, &#x27;periodsuperior&#x27;, &#x27;questionsmall&#x27;, &#x27;asuperior&#x27;,
  &#x27;bsuperior&#x27;, &#x27;centsuperior&#x27;, &#x27;dsuperior&#x27;, &#x27;esuperior&#x27;, &#x27;isuperior&#x27;,
  &#x27;lsuperior&#x27;, &#x27;msuperior&#x27;, &#x27;nsuperior&#x27;, &#x27;osuperior&#x27;, &#x27;rsuperior&#x27;, &#x27;ssuperior&#x27;,
  &#x27;tsuperior&#x27;, &#x27;ff&#x27;, &#x27;ffi&#x27;, &#x27;ffl&#x27;, &#x27;parenleftinferior&#x27;, &#x27;parenrightinferior&#x27;,
  &#x27;Circumflexsmall&#x27;, &#x27;hyphensuperior&#x27;, &#x27;Gravesmall&#x27;, &#x27;Asmall&#x27;, &#x27;Bsmall&#x27;,
  &#x27;Csmall&#x27;, &#x27;Dsmall&#x27;, &#x27;Esmall&#x27;, &#x27;Fsmall&#x27;, &#x27;Gsmall&#x27;, &#x27;Hsmall&#x27;, &#x27;Ismall&#x27;,
  &#x27;Jsmall&#x27;, &#x27;Ksmall&#x27;, &#x27;Lsmall&#x27;, &#x27;Msmall&#x27;, &#x27;Nsmall&#x27;, &#x27;Osmall&#x27;, &#x27;Psmall&#x27;,
  &#x27;Qsmall&#x27;, &#x27;Rsmall&#x27;, &#x27;Ssmall&#x27;, &#x27;Tsmall&#x27;, &#x27;Usmall&#x27;, &#x27;Vsmall&#x27;, &#x27;Wsmall&#x27;,
  &#x27;Xsmall&#x27;, &#x27;Ysmall&#x27;, &#x27;Zsmall&#x27;, &#x27;colonmonetary&#x27;, &#x27;onefitted&#x27;, &#x27;rupiah&#x27;,
  &#x27;Tildesmall&#x27;, &#x27;exclamdownsmall&#x27;, &#x27;centoldstyle&#x27;, &#x27;Lslashsmall&#x27;,
  &#x27;Scaronsmall&#x27;, &#x27;Zcaronsmall&#x27;, &#x27;Dieresissmall&#x27;, &#x27;Brevesmall&#x27;, &#x27;Caronsmall&#x27;,
  &#x27;Dotaccentsmall&#x27;, &#x27;Macronsmall&#x27;, &#x27;figuredash&#x27;, &#x27;hypheninferior&#x27;,
  &#x27;Ogoneksmall&#x27;, &#x27;Ringsmall&#x27;, &#x27;Cedillasmall&#x27;, &#x27;questiondownsmall&#x27;, &#x27;oneeighth&#x27;,
  &#x27;threeeighths&#x27;, &#x27;fiveeighths&#x27;, &#x27;seveneighths&#x27;, &#x27;onethird&#x27;, &#x27;twothirds&#x27;,
  &#x27;zerosuperior&#x27;, &#x27;foursuperior&#x27;, &#x27;fivesuperior&#x27;, &#x27;sixsuperior&#x27;,
  &#x27;sevensuperior&#x27;, &#x27;eightsuperior&#x27;, &#x27;ninesuperior&#x27;, &#x27;zeroinferior&#x27;,
  &#x27;oneinferior&#x27;, &#x27;twoinferior&#x27;, &#x27;threeinferior&#x27;, &#x27;fourinferior&#x27;,
  &#x27;fiveinferior&#x27;, &#x27;sixinferior&#x27;, &#x27;seveninferior&#x27;, &#x27;eightinferior&#x27;,
  &#x27;nineinferior&#x27;, &#x27;centinferior&#x27;, &#x27;dollarinferior&#x27;, &#x27;periodinferior&#x27;,
  &#x27;commainferior&#x27;, &#x27;Agravesmall&#x27;, &#x27;Aacutesmall&#x27;, &#x27;Acircumflexsmall&#x27;,
  &#x27;Atildesmall&#x27;, &#x27;Adieresissmall&#x27;, &#x27;Aringsmall&#x27;, &#x27;AEsmall&#x27;, &#x27;Ccedillasmall&#x27;,
  &#x27;Egravesmall&#x27;, &#x27;Eacutesmall&#x27;, &#x27;Ecircumflexsmall&#x27;, &#x27;Edieresissmall&#x27;,
  &#x27;Igravesmall&#x27;, &#x27;Iacutesmall&#x27;, &#x27;Icircumflexsmall&#x27;, &#x27;Idieresissmall&#x27;,
  &#x27;Ethsmall&#x27;, &#x27;Ntildesmall&#x27;, &#x27;Ogravesmall&#x27;, &#x27;Oacutesmall&#x27;, &#x27;Ocircumflexsmall&#x27;,
  &#x27;Otildesmall&#x27;, &#x27;Odieresissmall&#x27;, &#x27;OEsmall&#x27;, &#x27;Oslashsmall&#x27;, &#x27;Ugravesmall&#x27;,
  &#x27;Uacutesmall&#x27;, &#x27;Ucircumflexsmall&#x27;, &#x27;Udieresissmall&#x27;, &#x27;Yacutesmall&#x27;,
  &#x27;Thornsmall&#x27;, &#x27;Ydieresissmall&#x27;, &#x27;001.000&#x27;, &#x27;001.001&#x27;, &#x27;001.002&#x27;, &#x27;001.003&#x27;,
  &#x27;Black&#x27;, &#x27;Bold&#x27;, &#x27;Book&#x27;, &#x27;Light&#x27;, &#x27;Medium&#x27;, &#x27;Regular&#x27;, &#x27;Roman&#x27;, &#x27;Semibold&#x27;
];

// Type1Font is also a CIDFontType0.
var Type1Font = function Type1Font(name, file, properties) {
  // Get the data block containing glyphs and subrs informations
  var headerBlock = new Stream(file.getBytes(properties.length1));
  var headerBlockParser = new Type1Parser(headerBlock);
  headerBlockParser.extractFontHeader(properties);

  // Decrypt the data blocks and retrieve it&#x27;s content
  var eexecBlock = new Stream(file.getBytes(properties.length2));
  var eexecBlockParser = new Type1Parser(eexecBlock, true);
  var data = eexecBlockParser.extractFontProgram();
  for (var info in data.properties)
    properties[info] = data.properties[info];

  var charstrings = this.getOrderedCharStrings(data.charstrings, properties);
  var type2Charstrings = this.getType2Charstrings(charstrings);
  var subrs = this.getType2Subrs(data.subrs);

  this.charstrings = charstrings;
  this.data = this.wrap(name, type2Charstrings, this.charstrings,
                        subrs, properties);
  this.seacs = this.getSeacs(data.charstrings);
};

Type1Font.prototype = {
  getOrderedCharStrings: function Type1Font_getOrderedCharStrings(glyphs,
                                                            properties) {
    var charstrings = [];
    var usedUnicodes = [];
    var i, length, glyphName;
    var unusedUnicode = CMAP_GLYPH_OFFSET;
    for (i = 0, length = glyphs.length; i &lt; length; i++) {
      var item = glyphs[i];
      var glyphName = item.glyph;
      var unicode = glyphName in GlyphsUnicode ?
        GlyphsUnicode[glyphName] : unusedUnicode++;
      while (usedUnicodes[unicode]) {
        unicode = unusedUnicode++;
      }
      usedUnicodes[unicode] = true;
      charstrings.push({
        glyph: glyphName,
        unicode: unicode,
        gid: i,
        charstring: item.data,
        width: item.width,
        lsb: item.lsb
      });
    }

    charstrings.sort(function charstrings_sort(a, b) {
      return a.unicode - b.unicode;
    });
    return charstrings;
  },

  getSeacs: function Type1Font_getSeacs(charstrings) {
    var i, ii;
    var seacMap = [];
    for (i = 0, ii = charstrings.length; i &lt; ii; i++) {
      var charstring = charstrings[i];
      if (charstring.seac) {
        seacMap[i] = charstring.seac;
      }
    }
    return seacMap;
  },

  getType2Charstrings: function Type1Font_getType2Charstrings(
                                  type1Charstrings) {
    var type2Charstrings = [];
    for (var i = 0, ii = type1Charstrings.length; i &lt; ii; i++) {
      type2Charstrings.push(type1Charstrings[i].charstring);
    }
    return type2Charstrings;
  },

  getType2Subrs: function Type1Font_getType2Subrs(type1Subrs) {
    var bias = 0;
    var count = type1Subrs.length;
    if (count &lt; 1133)
      bias = 107;
    else if (count &lt; 33769)
      bias = 1131;
    else
      bias = 32768;

    // Add a bunch of empty subrs to deal with the Type2 bias
    var type2Subrs = [];
    for (var i = 0; i &lt; bias; i++)
      type2Subrs.push([0x0B]);

    for (var i = 0; i &lt; count; i++) {
      type2Subrs.push(type1Subrs[i]);
    }

    return type2Subrs;
  },

  wrap: function Type1Font_wrap(name, glyphs, charstrings, subrs, properties) {
    var cff = new CFF();
    cff.header = new CFFHeader(1, 0, 4, 4);

    cff.names = [name];

    var topDict = new CFFTopDict();
    // CFF strings IDs 0...390 are predefined names, so refering
    // to entries in our own String INDEX starts at SID 391.
    topDict.setByName(&#x27;version&#x27;, 391);
    topDict.setByName(&#x27;Notice&#x27;, 392);
    topDict.setByName(&#x27;FullName&#x27;, 393);
    topDict.setByName(&#x27;FamilyName&#x27;, 394);
    topDict.setByName(&#x27;Weight&#x27;, 395);
    topDict.setByName(&#x27;Encoding&#x27;, null); // placeholder
    topDict.setByName(&#x27;FontMatrix&#x27;, properties.fontMatrix);
    topDict.setByName(&#x27;FontBBox&#x27;, properties.bbox);
    topDict.setByName(&#x27;charset&#x27;, null); // placeholder
    topDict.setByName(&#x27;CharStrings&#x27;, null); // placeholder
    topDict.setByName(&#x27;Private&#x27;, null); // placeholder
    cff.topDict = topDict;

    var strings = new CFFStrings();
    strings.add(&#x27;Version 0.11&#x27;); // Version
    strings.add(&#x27;See original notice&#x27;); // Notice
    strings.add(name); // FullName
    strings.add(name); // FamilyName
    strings.add(&#x27;Medium&#x27;); // Weight
    cff.strings = strings;

    cff.globalSubrIndex = new CFFIndex();

    var count = glyphs.length;
    var charsetArray = [0];
    for (var i = 0; i &lt; count; i++) {
      var index = CFFStandardStrings.indexOf(charstrings[i].glyph);
      // Some characters like asterikmath &amp;&amp; circlecopyrt are
      // missing from the original strings, for the moment let&#x27;s
      // map them to .notdef and see later if it cause any
      // problems
      if (index == -1)
        index = 0;

      charsetArray.push((index &gt;&gt; 8) &amp; 0xff, index &amp; 0xff);
    }
    cff.charset = new CFFCharset(false, 0, [], charsetArray);

    var charStringsIndex = new CFFIndex();
    charStringsIndex.add([0x8B, 0x0E]); // .notdef
    for (var i = 0; i &lt; count; i++) {
      charStringsIndex.add(glyphs[i]);
    }
    cff.charStrings = charStringsIndex;

    var privateDict = new CFFPrivateDict();
    privateDict.setByName(&#x27;Subrs&#x27;, null); // placeholder
    var fields = [
      &#x27;BlueValues&#x27;,
      &#x27;OtherBlues&#x27;,
      &#x27;FamilyBlues&#x27;,
      &#x27;FamilyOtherBlues&#x27;,
      &#x27;StemSnapH&#x27;,
      &#x27;StemSnapV&#x27;,
      &#x27;BlueShift&#x27;,
      &#x27;BlueFuzz&#x27;,
      &#x27;BlueScale&#x27;,
      &#x27;LanguageGroup&#x27;,
      &#x27;ExpansionFactor&#x27;,
      &#x27;ForceBold&#x27;,
      &#x27;StdHW&#x27;,
      &#x27;StdVW&#x27;
    ];
    for (var i = 0, ii = fields.length; i &lt; ii; i++) {
      var field = fields[i];
      if (!properties.privateData.hasOwnProperty(field))
        continue;
      var value = properties.privateData[field];
      if (isArray(value)) {
        // All of the private dictionary array data in CFF must be stored as
        // &quot;delta-encoded&quot; numbers.
        for (var j = value.length - 1; j &gt; 0; j--) {
          value[j] -= value[j - 1]; // ... difference from previous value
        }
      }
      privateDict.setByName(field, value);
    }
    cff.topDict.privateDict = privateDict;

    var subrIndex = new CFFIndex();
    for (var i = 0, ii = subrs.length; i &lt; ii; i++) {
      subrIndex.add(subrs[i]);
    }
    privateDict.subrsIndex = subrIndex;

    var compiler = new CFFCompiler(cff);
    return compiler.compile();
  }
};

var CFFFont = (function CFFFontClosure() {
  function CFFFont(file, properties) {
    this.properties = properties;

    var parser = new CFFParser(file, properties);
    this.cff = parser.parse();
    var compiler = new CFFCompiler(this.cff);
    this.readExtra();
    try {
      this.data = compiler.compile();
    } catch (e) {
      warn(&#x27;Failed to compile font &#x27; + properties.loadedName);
      // There may have just been an issue with the compiler, set the data
      // anyway and hope the font loaded.
      this.data = file;
    }
  }

  CFFFont.prototype = {
    readExtra: function CFFFont_readExtra() {
      // charstrings contains info about glyphs (one element per glyph
      // containing mappings for {unicode, width})
      var charstrings = this.getCharStrings();

      // create the mapping between charstring and glyph id
      var glyphIds = [];
      for (var i = 0, ii = charstrings.length; i &lt; ii; i++)
        glyphIds.push(charstrings[i].gid);

      this.charstrings = charstrings;
      this.glyphIds = glyphIds;
      this.seacs = this.cff.seacs;
    },
    getCharStrings: function CFFFont_getCharStrings() {
      var cff = this.cff;
      var charsets = cff.charset.charset;
      var encoding = cff.encoding ? cff.encoding.encoding : null;
      var charstrings = [];
      var unicodeUsed = [];
      var unassignedUnicodeItems = [];
      var inverseEncoding = [];
      var gidStart = 0;
      // Even though the CFF font may not actually be a CID font is could have
      // CID information in the font descriptor.
      if (this.properties.cidSystemInfo) {
        // According to section 9.7.4.2 if the font is actually a CID font then
        // we should use the charset to map CIDs to GIDs. If it is not actually
        // a CID font then CIDs can be mapped directly to GIDs.
        if (this.cff.isCIDFont) {
          inverseEncoding = charsets;
        } else {
          for (var i = 0, ii = charsets.length; i &lt; charsets.length; i++) {
            inverseEncoding.push(i);
          }
        }
      } else {
        for (var charcode in encoding)
          inverseEncoding[encoding[charcode]] = charcode | 0;
        if (charsets[0] === &#x27;.notdef&#x27;) {
          gidStart = 1;
        }
      }

      for (var i = gidStart, ii = charsets.length; i &lt; ii; i++) {
        var glyph = charsets[i];

        var code = inverseEncoding[i];
        if (!code || isSpecialUnicode(code)) {
          unassignedUnicodeItems.push(i);
          continue;
        }
        charstrings.push({
          unicode: code,
          code: code,
          gid: i,
          glyph: glyph
        });
        unicodeUsed[code] = true;
      }

      var nextUnusedUnicode = CMAP_GLYPH_OFFSET;
      for (var j = 0, jj = unassignedUnicodeItems.length; j &lt; jj; ++j) {
        var i = unassignedUnicodeItems[j];
        // giving unicode value anyway
        while (nextUnusedUnicode in unicodeUsed)
          nextUnusedUnicode++;
        var unicode = nextUnusedUnicode++;
        charstrings.push({
          unicode: unicode,
          code: inverseEncoding[i] || 0,
          gid: i,
          glyph: charsets[i]
        });
      }

      // sort the array by the unicode value (again)
      charstrings.sort(function getCharStringsSort(a, b) {
        return a.unicode - b.unicode;
      });
      return charstrings;
    }
  };

  return CFFFont;
})();

var CFFParser = (function CFFParserClosure() {
  var CharstringValidationData = [
    null,
    { id: &#x27;hstem&#x27;, min: 2, resetStack: true, stem: true },
    null,
    { id: &#x27;vstem&#x27;, min: 2, resetStack: true, stem: true },
    { id: &#x27;vmoveto&#x27;, min: 1, resetStack: true },
    { id: &#x27;rlineto&#x27;, min: 2, resetStack: true },
    { id: &#x27;hlineto&#x27;, min: 1, resetStack: true },
    { id: &#x27;vlineto&#x27;, min: 1, resetStack: true },
    { id: &#x27;rrcurveto&#x27;, min: 6, resetStack: true },
    null,
    { id: &#x27;callsubr&#x27;, min: 1, undefStack: true },
    { id: &#x27;return&#x27;, min: 0, undefStack: true },
    null, // 12
    null,
    null, // endchar
    null,
    null,
    null,
    { id: &#x27;hstemhm&#x27;, min: 2, resetStack: true, stem: true },
    null, // hintmask
    null, // cntrmask
    { id: &#x27;rmoveto&#x27;, min: 2, resetStack: true },
    { id: &#x27;hmoveto&#x27;, min: 1, resetStack: true },
    { id: &#x27;vstemhm&#x27;, min: 2, resetStack: true, stem: true },
    { id: &#x27;rcurveline&#x27;, min: 8, resetStack: true },
    { id: &#x27;rlinecurve&#x27;, min: 8, resetStack: true },
    { id: &#x27;vvcurveto&#x27;, min: 4, resetStack: true },
    { id: &#x27;hhcurveto&#x27;, min: 4, resetStack: true },
    null, // shortint
    { id: &#x27;callgsubr&#x27;, min: 1, undefStack: true },
    { id: &#x27;vhcurveto&#x27;, min: 4, resetStack: true },
    { id: &#x27;hvcurveto&#x27;, min: 4, resetStack: true }
  ];
  var CharstringValidationData12 = [
    null,
    null,
    null,
    { id: &#x27;and&#x27;, min: 2, stackDelta: -1 },
    { id: &#x27;or&#x27;, min: 2, stackDelta: -1 },
    { id: &#x27;not&#x27;, min: 1, stackDelta: 0 },
    null,
    null,
    null,
    { id: &#x27;abs&#x27;, min: 1, stackDelta: 0 },
    { id: &#x27;add&#x27;, min: 2, stackDelta: -1,
      stackFn: function stack_div(stack, index) {
        stack[index - 2] = stack[index - 2] + stack[index - 1];
      }
    },
    { id: &#x27;sub&#x27;, min: 2, stackDelta: -1,
      stackFn: function stack_div(stack, index) {
        stack[index - 2] = stack[index - 2] - stack[index - 1];
      }
    },
    { id: &#x27;div&#x27;, min: 2, stackDelta: -1,
      stackFn: function stack_div(stack, index) {
        stack[index - 2] = stack[index - 2] / stack[index - 1];
      }
    },
    null,
    { id: &#x27;neg&#x27;, min: 1, stackDelta: 0,
      stackFn: function stack_div(stack, index) {
        stack[index - 1] = -stack[index - 1];
      }
    },
    { id: &#x27;eq&#x27;, min: 2, stackDelta: -1 },
    null,
    null,
    { id: &#x27;drop&#x27;, min: 1, stackDelta: -1 },
    null,
    { id: &#x27;put&#x27;, min: 2, stackDelta: -2 },
    { id: &#x27;get&#x27;, min: 1, stackDelta: 0 },
    { id: &#x27;ifelse&#x27;, min: 4, stackDelta: -3 },
    { id: &#x27;random&#x27;, min: 0, stackDelta: 1 },
    { id: &#x27;mul&#x27;, min: 2, stackDelta: -1,
      stackFn: function stack_div(stack, index) {
        stack[index - 2] = stack[index - 2] * stack[index - 1];
      }
    },
    null,
    { id: &#x27;sqrt&#x27;, min: 1, stackDelta: 0 },
    { id: &#x27;dup&#x27;, min: 1, stackDelta: 1 },
    { id: &#x27;exch&#x27;, min: 2, stackDelta: 0 },
    { id: &#x27;index&#x27;, min: 2, stackDelta: 0 },
    { id: &#x27;roll&#x27;, min: 3, stackDelta: -2 },
    null,
    null,
    null,
    { id: &#x27;hflex&#x27;, min: 7, resetStack: true },
    { id: &#x27;flex&#x27;, min: 13, resetStack: true },
    { id: &#x27;hflex1&#x27;, min: 9, resetStack: true },
    { id: &#x27;flex1&#x27;, min: 11, resetStack: true }
  ];

  function CFFParser(file, properties) {
    this.bytes = file.getBytes();
    this.properties = properties;
  }
  CFFParser.prototype = {
    parse: function CFFParser_parse() {
      var properties = this.properties;
      var cff = new CFF();
      this.cff = cff;

      // The first five sections must be in order, all the others are reached
      // via offsets contained in one of the below.
      var header = this.parseHeader();
      var nameIndex = this.parseIndex(header.endPos);
      var topDictIndex = this.parseIndex(nameIndex.endPos);
      var stringIndex = this.parseIndex(topDictIndex.endPos);
      var globalSubrIndex = this.parseIndex(stringIndex.endPos);

      var topDictParsed = this.parseDict(topDictIndex.obj.get(0));
      var topDict = this.createDict(CFFTopDict, topDictParsed, cff.strings);

      cff.header = header.obj;
      cff.names = this.parseNameIndex(nameIndex.obj);
      cff.strings = this.parseStringIndex(stringIndex.obj);
      cff.topDict = topDict;
      cff.globalSubrIndex = globalSubrIndex.obj;

      this.parsePrivateDict(cff.topDict);

      cff.isCIDFont = topDict.hasName(&#x27;ROS&#x27;);

      var charStringOffset = topDict.getByName(&#x27;CharStrings&#x27;);
      var charStringsAndSeacs = this.parseCharStrings(charStringOffset);
      cff.charStrings = charStringsAndSeacs.charStrings;
      cff.seacs = charStringsAndSeacs.seacs;

      var fontMatrix = topDict.getByName(&#x27;FontMatrix&#x27;);
      if (fontMatrix) {
        properties.fontMatrix = fontMatrix;
      }

      var fontBBox = topDict.getByName(&#x27;FontBBox&#x27;);
      if (fontBBox) {
        // adjusting ascent/descent
        properties.ascent = fontBBox[3];
        properties.descent = fontBBox[1];
        properties.ascentScaled = true;
      }

      var charset, encoding;
      if (cff.isCIDFont) {
        var fdArrayIndex = this.parseIndex(topDict.getByName(&#x27;FDArray&#x27;)).obj;
        for (var i = 0, ii = fdArrayIndex.count; i &lt; ii; ++i) {
          var dictRaw = fdArrayIndex.get(i);
          var fontDict = this.createDict(CFFTopDict, this.parseDict(dictRaw),
                                         cff.strings);
          this.parsePrivateDict(fontDict);
          cff.fdArray.push(fontDict);
        }
        // cid fonts don&#x27;t have an encoding
        encoding = null;
        charset = this.parseCharsets(topDict.getByName(&#x27;charset&#x27;),
                                     cff.charStrings.count, cff.strings, true);
        cff.fdSelect = this.parseFDSelect(topDict.getByName(&#x27;FDSelect&#x27;),
                                             cff.charStrings.count);
      } else {
        charset = this.parseCharsets(topDict.getByName(&#x27;charset&#x27;),
                                     cff.charStrings.count, cff.strings, false);
        encoding = this.parseEncoding(topDict.getByName(&#x27;Encoding&#x27;),
                                      properties,
                                      cff.strings, charset.charset);
      }
      cff.charset = charset;
      cff.encoding = encoding;

      return cff;
    },
    parseHeader: function CFFParser_parseHeader() {
      var bytes = this.bytes;
      var offset = 0;

      while (bytes[offset] != 1)
        ++offset;

      if (offset !== 0) {
        info(&#x27;cff data is shifted&#x27;);
        bytes = bytes.subarray(offset);
        this.bytes = bytes;
      }
      var major = bytes[0];
      var minor = bytes[1];
      var hdrSize = bytes[2];
      var offSize = bytes[3];
      var header = new CFFHeader(major, minor, hdrSize, offSize);
      return {obj: header, endPos: hdrSize};
    },
    parseDict: function CFFParser_parseDict(dict) {
      var pos = 0;

      function parseOperand() {
        var value = dict[pos++];
        if (value === 30) {
          return parseFloatOperand(pos);
        } else if (value === 28) {
          value = dict[pos++];
          value = ((value &lt;&lt; 24) | (dict[pos++] &lt;&lt; 16)) &gt;&gt; 16;
          return value;
        } else if (value === 29) {
          value = dict[pos++];
          value = (value &lt;&lt; 8) | dict[pos++];
          value = (value &lt;&lt; 8) | dict[pos++];
          value = (value &lt;&lt; 8) | dict[pos++];
          return value;
        } else if (value &gt;= 32 &amp;&amp; value &lt;= 246) {
          return value - 139;
        } else if (value &gt;= 247 &amp;&amp; value &lt;= 250) {
          return ((value - 247) * 256) + dict[pos++] + 108;
        } else if (value &gt;= 251 &amp;&amp; value &lt;= 254) {
          return -((value - 251) * 256) - dict[pos++] - 108;
        } else {
          error(&#x27;255 is not a valid DICT command&#x27;);
        }
        return -1;
      }

      function parseFloatOperand() {
        var str = &#x27;&#x27;;
        var eof = 15;
        var lookup = [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;,
            &#x27;9&#x27;, &#x27;.&#x27;, &#x27;E&#x27;, &#x27;E-&#x27;, null, &#x27;-&#x27;];
        var length = dict.length;
        while (pos &lt; length) {
          var b = dict[pos++];
          var b1 = b &gt;&gt; 4;
          var b2 = b &amp; 15;

          if (b1 == eof)
            break;
          str += lookup[b1];

          if (b2 == eof)
            break;
          str += lookup[b2];
        }
        return parseFloat(str);
      }

      var operands = [];
      var entries = [];

      var pos = 0;
      var end = dict.length;
      while (pos &lt; end) {
        var b = dict[pos];
        if (b &lt;= 21) {
          if (b === 12)
            b = (b &lt;&lt; 8) | dict[++pos];
          entries.push([b, operands]);
          operands = [];
          ++pos;
        } else {
          operands.push(parseOperand());
        }
      }
      return entries;
    },
    parseIndex: function CFFParser_parseIndex(pos) {
      var cffIndex = new CFFIndex();
      var bytes = this.bytes;
      var count = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
      var offsets = [];
      var start = pos;
      var end = pos;

      if (count !== 0) {
        var offsetSize = bytes[pos++];
        // add 1 for offset to determine size of last object
        var startPos = pos + ((count + 1) * offsetSize) - 1;

        for (var i = 0, ii = count + 1; i &lt; ii; ++i) {
          var offset = 0;
          for (var j = 0; j &lt; offsetSize; ++j) {
            offset &lt;&lt;= 8;
            offset += bytes[pos++];
          }
          offsets.push(startPos + offset);
        }
        end = offsets[count];
      }
      for (var i = 0, ii = offsets.length - 1; i &lt; ii; ++i) {
        var offsetStart = offsets[i];
        var offsetEnd = offsets[i + 1];
        cffIndex.add(bytes.subarray(offsetStart, offsetEnd));
      }
      return {obj: cffIndex, endPos: end};
    },
    parseNameIndex: function CFFParser_parseNameIndex(index) {
      var names = [];
      for (var i = 0, ii = index.count; i &lt; ii; ++i) {
        var name = index.get(i);
        // OTS doesn&#x27;t allow names to be over 127 characters.
        var length = Math.min(name.length, 127);
        var data = [];
        // OTS also only permits certain characters in the name.
        for (var j = 0; j &lt; length; ++j) {
          var c = name[j];
          if (j === 0 &amp;&amp; c === 0) {
            data[j] = c;
            continue;
          }
          if ((c &lt; 33 || c &gt; 126) || c === 91 /* [ */ || c === 93 /* ] */ ||
              c === 40 /* ( */ || c === 41 /* ) */ || c === 123 /* { */ ||
              c === 125 /* } */ || c === 60 /* &lt; */ || c === 62 /* &gt; */ ||
              c === 47 /* / */ || c === 37 /* % */) {
            data[j] = 95;
            continue;
          }
          data[j] = c;
        }
        names.push(String.fromCharCode.apply(null, data));
      }
      return names;
    },
    parseStringIndex: function CFFParser_parseStringIndex(index) {
      var strings = new CFFStrings();
      for (var i = 0, ii = index.count; i &lt; ii; ++i) {
        var data = index.get(i);
        strings.add(String.fromCharCode.apply(null, data));
      }
      return strings;
    },
    createDict: function CFFParser_createDict(Type, dict, strings) {
      var cffDict = new Type(strings);
      var types = cffDict.types;

      for (var i = 0, ii = dict.length; i &lt; ii; ++i) {
        var pair = dict[i];
        var key = pair[0];
        var value = pair[1];
        cffDict.setByKey(key, value);
      }
      return cffDict;
    },
    parseCharStrings: function CFFParser_parseCharStrings(charStringOffset) {
      var charStrings = this.parseIndex(charStringOffset).obj;
      var seacs = [];
      var count = charStrings.count;
      for (var i = 0; i &lt; count; i++) {
        var charstring = charStrings.get(i);

        var stackSize = 0;
        var stack = [];
        var undefStack = true;
        var hints = 0;
        var valid = true;
        var data = charstring;
        var length = data.length;
        for (var j = 0; j &lt; length;) {
          var value = data[j++];
          var validationCommand = null;
          if (value == 12) {
            var q = data[j++];
            if (q === 0) {
              // The CFF specification state that the &#x27;dotsection&#x27; command
              // (12, 0) is deprecated and treated as a no-op, but all Type2
              // charstrings processors should support them. Unfortunately
              // the font sanitizer don&#x27;t. As a workaround the sequence (12, 0)
              // is replaced by a useless (0, hmoveto).
              data[j - 2] = 139;
              data[j - 1] = 22;
              stackSize = 0;
            } else {
              validationCommand = CharstringValidationData12[q];
            }
          } else if (value === 28) { // number (16 bit)
            stack[stackSize] = ((data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16)) &gt;&gt; 16;
            j += 2;
            stackSize++;
          } else if (value == 14) {
            if (stackSize &gt;= 4) {
              stackSize -= 4;
              if (SEAC_ANALYSIS_ENABLED) {
                seacs[i] = stack.slice(stackSize, stackSize + 4);
                valid = false;
              }
            }
          } else if (value &gt;= 32 &amp;&amp; value &lt;= 246) {  // number
            stack[stackSize] = value - 139;
            stackSize++;
          } else if (value &gt;= 247 &amp;&amp; value &lt;= 254) {  // number (+1 bytes)
            stack[stackSize] = value &lt; 251 ?
              ((value - 247) &lt;&lt; 8) + data[j] + 108 :
              -((value - 251) &lt;&lt; 8) - data[j] - 108;
            j++;
            stackSize++;
          } else if (value == 255) {  // number (32 bit)
            stack[stackSize] = ((data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) |
              (data[j + 2] &lt;&lt; 8) | data[j + 3]) / 65536;
            j += 4;
            stackSize++;
          } else if (value == 19 || value == 20) {
            hints += stackSize &gt;&gt; 1;
            j += (hints + 7) &gt;&gt; 3; // skipping right amount of hints flag data
            stackSize = 0;
          } else {
            validationCommand = CharstringValidationData[value];
          }
          if (validationCommand) {
            if (validationCommand.stem) {
              hints += stackSize &gt;&gt; 1;
            }
            if (&#x27;min&#x27; in validationCommand) {
              if (!undefStack &amp;&amp; stackSize &lt; validationCommand.min) {
                warn(&#x27;Not enough parameters for &#x27; + validationCommand.id +
                     &#x27;; actual: &#x27; + stackSize +
                     &#x27;, expected: &#x27; + validationCommand.min);
                valid = false;
                break;
              }
            }
            if (&#x27;stackDelta&#x27; in validationCommand) {
              if (&#x27;stackFn&#x27; in validationCommand) {
                validationCommand.stackFn(stack, stackSize);
              }
              stackSize += validationCommand.stackDelta;
            } else if (validationCommand.resetStack) {
              stackSize = 0;
              undefStack = false;
            } else if (validationCommand.undefStack) {
              stackSize = 0;
              undefStack = true;
            }
          }
        }
        if (!valid) {
          // resetting invalid charstring to single &#x27;endchar&#x27;
          charStrings.set(i, new Uint8Array([14]));
        }
      }
      return { charStrings: charStrings, seacs: seacs };
    },
    emptyPrivateDictionary:
      function CFFParser_emptyPrivateDictionary(parentDict) {
      var privateDict = this.createDict(CFFPrivateDict, [],
                                        parentDict.strings);
      parentDict.setByKey(18, [0, 0]);
      parentDict.privateDict = privateDict;
    },
    parsePrivateDict: function CFFParser_parsePrivateDict(parentDict) {
      // no private dict, do nothing
      if (!parentDict.hasName(&#x27;Private&#x27;)) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      var privateOffset = parentDict.getByName(&#x27;Private&#x27;);
      // make sure the params are formatted correctly
      if (!isArray(privateOffset) || privateOffset.length !== 2) {
        parentDict.removeByName(&#x27;Private&#x27;);
        return;
      }
      var size = privateOffset[0];
      var offset = privateOffset[1];
      // remove empty dicts or ones that refer to invalid location
      if (size === 0 || offset &gt;= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }

      var privateDictEnd = offset + size;
      var dictData = this.bytes.subarray(offset, privateDictEnd);
      var dict = this.parseDict(dictData);
      var privateDict = this.createDict(CFFPrivateDict, dict,
                                        parentDict.strings);
      parentDict.privateDict = privateDict;

      // Parse the Subrs index also since it&#x27;s relative to the private dict.
      if (!privateDict.getByName(&#x27;Subrs&#x27;))
        return;
      var subrsOffset = privateDict.getByName(&#x27;Subrs&#x27;);
      var relativeOffset = offset + subrsOffset;
      // Validate the offset.
      if (subrsOffset === 0 || relativeOffset &gt;= this.bytes.length) {
        this.emptyPrivateDictionary(parentDict);
        return;
      }
      var subrsIndex = this.parseIndex(relativeOffset);
      privateDict.subrsIndex = subrsIndex.obj;
    },
    parseCharsets: function CFFParser_parseCharsets(pos, length, strings, cid) {
      if (pos === 0) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.ISO_ADOBE,
                              ISOAdobeCharset);
      } else if (pos == 1) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT,
                              ExpertCharset);
      } else if (pos == 2) {
        return new CFFCharset(true, CFFCharsetPredefinedTypes.EXPERT_SUBSET,
                              ExpertSubsetCharset);
      }

      var bytes = this.bytes;
      var start = pos;
      var format = bytes[pos++];
      var charset = [&#x27;.notdef&#x27;];

      // subtract 1 for the .notdef glyph
      length -= 1;

      switch (format) {
        case 0:
          for (var i = 0; i &lt; length; i++) {
            var id = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
            charset.push(cid ? id : strings.get(id));
          }
          break;
        case 1:
          while (charset.length &lt;= length) {
            var id = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
            var count = bytes[pos++];
            for (var i = 0; i &lt;= count; i++)
              charset.push(cid ? id++ : strings.get(id++));
          }
          break;
        case 2:
          while (charset.length &lt;= length) {
            var id = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
            var count = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
            for (var i = 0; i &lt;= count; i++)
              charset.push(cid ? id++ : strings.get(id++));
          }
          break;
        default:
          error(&#x27;Unknown charset format&#x27;);
      }
      // Raw won&#x27;t be needed if we actually compile the charset.
      var end = pos;
      var raw = bytes.subarray(start, end);

      return new CFFCharset(false, format, charset, raw);
    },
    parseEncoding: function CFFParser_parseEncoding(pos,
                                                    properties,
                                                    strings,
                                                    charset) {
      var encoding = {};
      var bytes = this.bytes;
      var predefined = false;
      var hasSupplement = false;
      var format;
      var raw = null;

      function readSupplement() {
        var supplementsCount = bytes[pos++];
        for (var i = 0; i &lt; supplementsCount; i++) {
          var code = bytes[pos++];
          var sid = (bytes[pos++] &lt;&lt; 8) + (bytes[pos++] &amp; 0xff);
          encoding[code] = properties.differences.indexOf(strings.get(sid));
        }
      }

      if (pos === 0 || pos == 1) {
        predefined = true;
        format = pos;
        var baseEncoding = pos ? Encodings.ExpertEncoding :
                                 Encodings.StandardEncoding;
        for (var i = 0, ii = charset.length; i &lt; ii; i++) {
          var index = baseEncoding.indexOf(charset[i]);
          if (index != -1) {
            encoding[index] = i;
          }
        }
      } else {
        var dataStart = pos;
        var format = bytes[pos++];
        switch (format &amp; 0x7f) {
          case 0:
            var glyphsCount = bytes[pos++];
            for (var i = 1; i &lt;= glyphsCount; i++)
              encoding[bytes[pos++]] = i;
            break;

          case 1:
            var rangesCount = bytes[pos++];
            var gid = 1;
            for (var i = 0; i &lt; rangesCount; i++) {
              var start = bytes[pos++];
              var left = bytes[pos++];
              for (var j = start; j &lt;= start + left; j++)
                encoding[j] = gid++;
            }
            break;

          default:
            error(&#x27;Unknow encoding format: &#x27; + format + &#x27; in CFF&#x27;);
            break;
        }
        var dataEnd = pos;
        if (format &amp; 0x80) {
          // The font sanitizer does not support CFF encoding with a
          // supplement, since the encoding is not really used to map
          // between gid to glyph, let&#x27;s overwrite what is declared in
          // the top dictionary to let the sanitizer think the font use
          // StandardEncoding, that&#x27;s a lie but that&#x27;s ok.
          bytes[dataStart] &amp;= 0x7f;
          readSupplement();
          hasSupplement = true;
        }
        raw = bytes.subarray(dataStart, dataEnd);
      }
      format = format &amp; 0x7f;
      return new CFFEncoding(predefined, format, encoding, raw);
    },
    parseFDSelect: function CFFParser_parseFDSelect(pos, length) {
      var start = pos;
      var bytes = this.bytes;
      var format = bytes[pos++];
      var fdSelect = [];
      switch (format) {
        case 0:
          for (var i = 0; i &lt; length; ++i) {
            var id = bytes[pos++];
            fdSelect.push(id);
          }
          break;
        case 3:
          var rangesCount = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
          for (var i = 0; i &lt; rangesCount; ++i) {
            var first = (bytes[pos++] &lt;&lt; 8) | bytes[pos++];
            var fdIndex = bytes[pos++];
            var next = (bytes[pos] &lt;&lt; 8) | bytes[pos + 1];
            for (var j = first; j &lt; next; ++j)
              fdSelect.push(fdIndex);
          }
          // Advance past the sentinel(next).
          pos += 2;
          break;
        default:
          error(&#x27;Unknown fdselect format &#x27; + format);
          break;
      }
      var end = pos;
      return new CFFFDSelect(fdSelect, bytes.subarray(start, end));
    }
  };
  return CFFParser;
})();

// Compact Font Format
var CFF = (function CFFClosure() {
  function CFF() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;

    // The following could really be per font, but since we only have one font
    // store them here.
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;

    this.isCIDFont = false;
  }
  return CFF;
})();

var CFFHeader = (function CFFHeaderClosure() {
  function CFFHeader(major, minor, hdrSize, offSize) {
    this.major = major;
    this.minor = minor;
    this.hdrSize = hdrSize;
    this.offSize = offSize;
  }
  return CFFHeader;
})();

var CFFStrings = (function CFFStringsClosure() {
  function CFFStrings() {
    this.strings = [];
  }
  CFFStrings.prototype = {
    get: function CFFStrings_get(index) {
      if (index &gt;= 0 &amp;&amp; index &lt;= 390)
        return CFFStandardStrings[index];
      if (index - 391 &lt;= this.strings.length)
        return this.strings[index - 391];
      return CFFStandardStrings[0];
    },
    add: function CFFStrings_add(value) {
      this.strings.push(value);
    },
    get count() {
      return this.strings.length;
    }
  };
  return CFFStrings;
})();

var CFFIndex = (function CFFIndexClosure() {
  function CFFIndex() {
    this.objects = [];
    this.length = 0;
  }
  CFFIndex.prototype = {
    add: function CFFIndex_add(data) {
      this.length += data.length;
      this.objects.push(data);
    },
    set: function CFFIndex_set(index, data) {
      this.length += data.length - this.objects[index].length;
      this.objects[index] = data;
    },
    get: function CFFIndex_get(index) {
      return this.objects[index];
    },
    get count() {
      return this.objects.length;
    }
  };
  return CFFIndex;
})();

var CFFDict = (function CFFDictClosure() {
  function CFFDict(tables, strings) {
    this.keyToNameMap = tables.keyToNameMap;
    this.nameToKeyMap = tables.nameToKeyMap;
    this.defaults = tables.defaults;
    this.types = tables.types;
    this.opcodes = tables.opcodes;
    this.order = tables.order;
    this.strings = strings;
    this.values = {};
  }
  CFFDict.prototype = {
    // value should always be an array
    setByKey: function CFFDict_setByKey(key, value) {
      if (!(key in this.keyToNameMap))
        return false;
      // ignore empty values
      if (value.length === 0)
        return true;
      var type = this.types[key];
      // remove the array wrapping these types of values
      if (type === &#x27;num&#x27; || type === &#x27;sid&#x27; || type === &#x27;offset&#x27;)
        value = value[0];
      this.values[key] = value;
      return true;
    },
    setByName: function CFFDict_setByName(name, value) {
      if (!(name in this.nameToKeyMap)) {
        error(&#x27;Invalid dictionary name &quot;&#x27; + name + &#x27;&quot;&#x27;);
      }
      this.values[this.nameToKeyMap[name]] = value;
    },
    hasName: function CFFDict_hasName(name) {
      return this.nameToKeyMap[name] in this.values;
    },
    getByName: function CFFDict_getByName(name) {
      if (!(name in this.nameToKeyMap))
        error(&#x27;Invalid dictionary name &quot;&#x27; + name + &#x27;&quot;&#x27;);
      var key = this.nameToKeyMap[name];
      if (!(key in this.values))
        return this.defaults[key];
      return this.values[key];
    },
    removeByName: function CFFDict_removeByName(name) {
      delete this.values[this.nameToKeyMap[name]];
    }
  };
  CFFDict.createTables = function CFFDict_createTables(layout) {
    var tables = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (var i = 0, ii = layout.length; i &lt; ii; ++i) {
      var entry = layout[i];
      var key = isArray(entry[0]) ? (entry[0][0] &lt;&lt; 8) + entry[0][1] : entry[0];
      tables.keyToNameMap[key] = entry[1];
      tables.nameToKeyMap[entry[1]] = key;
      tables.types[key] = entry[2];
      tables.defaults[key] = entry[3];
      tables.opcodes[key] = isArray(entry[0]) ? entry[0] : [entry[0]];
      tables.order.push(key);
    }
    return tables;
  };
  return CFFDict;
})();

var CFFTopDict = (function CFFTopDictClosure() {
  var layout = [
    [[12, 30], &#x27;ROS&#x27;, [&#x27;sid&#x27;, &#x27;sid&#x27;, &#x27;num&#x27;], null],
    [[12, 20], &#x27;SyntheticBase&#x27;, &#x27;num&#x27;, null],
    [0, &#x27;version&#x27;, &#x27;sid&#x27;, null],
    [1, &#x27;Notice&#x27;, &#x27;sid&#x27;, null],
    [[12, 0], &#x27;Copyright&#x27;, &#x27;sid&#x27;, null],
    [2, &#x27;FullName&#x27;, &#x27;sid&#x27;, null],
    [3, &#x27;FamilyName&#x27;, &#x27;sid&#x27;, null],
    [4, &#x27;Weight&#x27;, &#x27;sid&#x27;, null],
    [[12, 1], &#x27;isFixedPitch&#x27;, &#x27;num&#x27;, 0],
    [[12, 2], &#x27;ItalicAngle&#x27;, &#x27;num&#x27;, 0],
    [[12, 3], &#x27;UnderlinePosition&#x27;, &#x27;num&#x27;, -100],
    [[12, 4], &#x27;UnderlineThickness&#x27;, &#x27;num&#x27;, 50],
    [[12, 5], &#x27;PaintType&#x27;, &#x27;num&#x27;, 0],
    [[12, 6], &#x27;CharstringType&#x27;, &#x27;num&#x27;, 2],
    [[12, 7], &#x27;FontMatrix&#x27;, [&#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;],
                            [0.001, 0, 0, 0.001, 0, 0]],
    [13, &#x27;UniqueID&#x27;, &#x27;num&#x27;, null],
    [5, &#x27;FontBBox&#x27;, [&#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;, &#x27;num&#x27;], [0, 0, 0, 0]],
    [[12, 8], &#x27;StrokeWidth&#x27;, &#x27;num&#x27;, 0],
    [14, &#x27;XUID&#x27;, &#x27;array&#x27;, null],
    [15, &#x27;charset&#x27;, &#x27;offset&#x27;, 0],
    [16, &#x27;Encoding&#x27;, &#x27;offset&#x27;, 0],
    [17, &#x27;CharStrings&#x27;, &#x27;offset&#x27;, 0],
    [18, &#x27;Private&#x27;, [&#x27;offset&#x27;, &#x27;offset&#x27;], null],
    [[12, 21], &#x27;PostScript&#x27;, &#x27;sid&#x27;, null],
    [[12, 22], &#x27;BaseFontName&#x27;, &#x27;sid&#x27;, null],
    [[12, 23], &#x27;BaseFontBlend&#x27;, &#x27;delta&#x27;, null],
    [[12, 31], &#x27;CIDFontVersion&#x27;, &#x27;num&#x27;, 0],
    [[12, 32], &#x27;CIDFontRevision&#x27;, &#x27;num&#x27;, 0],
    [[12, 33], &#x27;CIDFontType&#x27;, &#x27;num&#x27;, 0],
    [[12, 34], &#x27;CIDCount&#x27;, &#x27;num&#x27;, 8720],
    [[12, 35], &#x27;UIDBase&#x27;, &#x27;num&#x27;, null],
    // XXX: CID Fonts on DirectWrite 6.1 only seem to work if FDSelect comes
    // before FDArray.
    [[12, 37], &#x27;FDSelect&#x27;, &#x27;offset&#x27;, null],
    [[12, 36], &#x27;FDArray&#x27;, &#x27;offset&#x27;, null],
    [[12, 38], &#x27;FontName&#x27;, &#x27;sid&#x27;, null]
  ];
  var tables = null;
  function CFFTopDict(strings) {
    if (tables === null)
      tables = CFFDict.createTables(layout);
    CFFDict.call(this, tables, strings);
    this.privateDict = null;
  }
  CFFTopDict.prototype = Object.create(CFFDict.prototype);
  return CFFTopDict;
})();

var CFFPrivateDict = (function CFFPrivateDictClosure() {
  var layout = [
    [6, &#x27;BlueValues&#x27;, &#x27;delta&#x27;, null],
    [7, &#x27;OtherBlues&#x27;, &#x27;delta&#x27;, null],
    [8, &#x27;FamilyBlues&#x27;, &#x27;delta&#x27;, null],
    [9, &#x27;FamilyOtherBlues&#x27;, &#x27;delta&#x27;, null],
    [[12, 9], &#x27;BlueScale&#x27;, &#x27;num&#x27;, 0.039625],
    [[12, 10], &#x27;BlueShift&#x27;, &#x27;num&#x27;, 7],
    [[12, 11], &#x27;BlueFuzz&#x27;, &#x27;num&#x27;, 1],
    [10, &#x27;StdHW&#x27;, &#x27;num&#x27;, null],
    [11, &#x27;StdVW&#x27;, &#x27;num&#x27;, null],
    [[12, 12], &#x27;StemSnapH&#x27;, &#x27;delta&#x27;, null],
    [[12, 13], &#x27;StemSnapV&#x27;, &#x27;delta&#x27;, null],
    [[12, 14], &#x27;ForceBold&#x27;, &#x27;num&#x27;, 0],
    [[12, 17], &#x27;LanguageGroup&#x27;, &#x27;num&#x27;, 0],
    [[12, 18], &#x27;ExpansionFactor&#x27;, &#x27;num&#x27;, 0.06],
    [[12, 19], &#x27;initialRandomSeed&#x27;, &#x27;num&#x27;, 0],
    [20, &#x27;defaultWidthX&#x27;, &#x27;num&#x27;, 0],
    [21, &#x27;nominalWidthX&#x27;, &#x27;num&#x27;, 0],
    [19, &#x27;Subrs&#x27;, &#x27;offset&#x27;, null]
  ];
  var tables = null;
  function CFFPrivateDict(strings) {
    if (tables === null)
      tables = CFFDict.createTables(layout);
    CFFDict.call(this, tables, strings);
    this.subrsIndex = null;
  }
  CFFPrivateDict.prototype = Object.create(CFFDict.prototype);
  return CFFPrivateDict;
})();

var CFFCharsetPredefinedTypes = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
var CFFCharsetEmbeddedTypes = {
  FORMAT0: 0,
  FORMAT1: 1,
  FORMAT2: 2
};
var CFFCharset = (function CFFCharsetClosure() {
  function CFFCharset(predefined, format, charset, raw) {
    this.predefined = predefined;
    this.format = format;
    this.charset = charset;
    this.raw = raw;
  }
  return CFFCharset;
})();

var CFFEncodingPredefinedTypes = {
  STANDARD: 0,
  EXPERT: 1
};
var CFFCharsetEmbeddedTypes = {
  FORMAT0: 0,
  FORMAT1: 1
};
var CFFEncoding = (function CFFEncodingClosure() {
  function CFFEncoding(predefined, format, encoding, raw) {
    this.predefined = predefined;
    this.format = format;
    this.encoding = encoding;
    this.raw = raw;
  }
  return CFFEncoding;
})();

var CFFFDSelect = (function CFFFDSelectClosure() {
  function CFFFDSelect(fdSelect, raw) {
    this.fdSelect = fdSelect;
    this.raw = raw;
  }
  return CFFFDSelect;
})();

// Helper class to keep track of where an offset is within the data and helps
// filling in that offset once it&#x27;s known.
var CFFOffsetTracker = (function CFFOffsetTrackerClosure() {
  function CFFOffsetTracker() {
    this.offsets = {};
  }
  CFFOffsetTracker.prototype = {
    isTracking: function CFFOffsetTracker_isTracking(key) {
      return key in this.offsets;
    },
    track: function CFFOffsetTracker_track(key, location) {
      if (key in this.offsets)
        error(&#x27;Already tracking location of &#x27; + key);
      this.offsets[key] = location;
    },
    offset: function CFFOffsetTracker_offset(value) {
      for (var key in this.offsets) {
        this.offsets[key] += value;
      }
    },
    setEntryLocation: function CFFOffsetTracker_setEntryLocation(key,
                                                                 values,
                                                                 output) {
      if (!(key in this.offsets))
        error(&#x27;Not tracking location of &#x27; + key);
      var data = output.data;
      var dataOffset = this.offsets[key];
      var size = 5;
      for (var i = 0, ii = values.length; i &lt; ii; ++i) {
        var offset0 = i * size + dataOffset;
        var offset1 = offset0 + 1;
        var offset2 = offset0 + 2;
        var offset3 = offset0 + 3;
        var offset4 = offset0 + 4;
        // It&#x27;s easy to screw up offsets so perform this sanity check.
        if (data[offset0] !== 0x1d || data[offset1] !== 0 ||
            data[offset2] !== 0 || data[offset3] !== 0 || data[offset4] !== 0)
          error(&#x27;writing to an offset that is not empty&#x27;);
        var value = values[i];
        data[offset0] = 0x1d;
        data[offset1] = (value &gt;&gt; 24) &amp; 0xFF;
        data[offset2] = (value &gt;&gt; 16) &amp; 0xFF;
        data[offset3] = (value &gt;&gt; 8) &amp; 0xFF;
        data[offset4] = value &amp; 0xFF;
      }
    }
  };
  return CFFOffsetTracker;
})();

// Takes a CFF and converts it to the binary representation.
var CFFCompiler = (function CFFCompilerClosure() {
  function stringToArray(str) {
    var array = [];
    for (var i = 0, ii = str.length; i &lt; ii; ++i)
      array[i] = str.charCodeAt(i);

    return array;
  }
  function CFFCompiler(cff) {
    this.cff = cff;
  }
  CFFCompiler.prototype = {
    compile: function CFFCompiler_compile() {
      var cff = this.cff;
      var output = {
        data: [],
        length: 0,
        add: function CFFCompiler_add(data) {
          this.data = this.data.concat(data);
          this.length = this.data.length;
        }
      };

      // Compile the five entries that must be in order.
      var header = this.compileHeader(cff.header);
      output.add(header);

      var nameIndex = this.compileNameIndex(cff.names);
      output.add(nameIndex);

      if (cff.isCIDFont) {
        // The spec is unclear on how font matrices should relate to each other
        // when there is one in the main top dict and the sub top dicts.
        // Windows handles this differently than linux and osx so we have to
        // normalize to work on all.
        // Rules based off of some mailing list discussions:
        // - If main font has a matrix and subfont doesn&#x27;t, use the main matrix.
        // - If no main font matrix and there is a subfont matrix, use the
        //   subfont matrix.
        // - If both have matrices, concat together.
        // - If neither have matrices, use default.
        // To make this work on all platforms we move the top matrix into each
        // sub top dict and concat if necessary.
        if (cff.topDict.hasName(&#x27;FontMatrix&#x27;)) {
          var base = cff.topDict.getByName(&#x27;FontMatrix&#x27;);
          cff.topDict.removeByName(&#x27;FontMatrix&#x27;);
          for (var i = 0, ii = cff.fdArray.length; i &lt; ii; i++) {
            var subDict = cff.fdArray[i];
            var matrix = base.slice(0);
            if (subDict.hasName(&#x27;FontMatrix&#x27;)) {
              matrix = Util.transform(matrix, subDict.getByName(&#x27;FontMatrix&#x27;));
            }
            subDict.setByName(&#x27;FontMatrix&#x27;, matrix);
          }
        }
      }

      var compiled = this.compileTopDicts([cff.topDict],
                                          output.length,
                                          cff.isCIDFont);
      output.add(compiled.output);
      var topDictTracker = compiled.trackers[0];

      var stringIndex = this.compileStringIndex(cff.strings.strings);
      output.add(stringIndex);

      var globalSubrIndex = this.compileIndex(cff.globalSubrIndex);
      output.add(globalSubrIndex);

      // Now start on the other entries that have no specfic order.
      if (cff.encoding &amp;&amp; cff.topDict.hasName(&#x27;Encoding&#x27;)) {
        if (cff.encoding.predefined) {
          topDictTracker.setEntryLocation(&#x27;Encoding&#x27;, [cff.encoding.format],
                                          output);
        } else {
          var encoding = this.compileEncoding(cff.encoding);
          topDictTracker.setEntryLocation(&#x27;Encoding&#x27;, [output.length], output);
          output.add(encoding);
        }
      }

      if (cff.charset &amp;&amp; cff.topDict.hasName(&#x27;charset&#x27;)) {
        if (cff.charset.predefined) {
          topDictTracker.setEntryLocation(&#x27;charset&#x27;, [cff.charset.format],
                                          output);
        } else {
          var charset = this.compileCharset(cff.charset);
          topDictTracker.setEntryLocation(&#x27;charset&#x27;, [output.length], output);
          output.add(charset);
        }
      }

      var charStrings = this.compileCharStrings(cff.charStrings);
      topDictTracker.setEntryLocation(&#x27;CharStrings&#x27;, [output.length], output);
      output.add(charStrings);

      if (cff.isCIDFont) {
        // For some reason FDSelect must be in front of FDArray on windows. OSX
        // and linux don&#x27;t seem to care.
        topDictTracker.setEntryLocation(&#x27;FDSelect&#x27;, [output.length], output);
        var fdSelect = this.compileFDSelect(cff.fdSelect.raw);
        output.add(fdSelect);
        // It is unclear if the sub font dictionary can have CID related
        // dictionary keys, but the sanitizer doesn&#x27;t like them so remove them.
        var compiled = this.compileTopDicts(cff.fdArray, output.length, true);
        topDictTracker.setEntryLocation(&#x27;FDArray&#x27;, [output.length], output);
        output.add(compiled.output);
        var fontDictTrackers = compiled.trackers;

        this.compilePrivateDicts(cff.fdArray, fontDictTrackers, output);
      }

      this.compilePrivateDicts([cff.topDict], [topDictTracker], output);

      // If the font data ends with INDEX whose object data is zero-length,
      // the sanitizer will bail out. Add a dummy byte to avoid that.
      output.add([0]);

      return output.data;
    },
    encodeNumber: function CFFCompiler_encodeNumber(value) {
      if (parseFloat(value) == parseInt(value, 10) &amp;&amp; !isNaN(value)) // isInt
        return this.encodeInteger(value);
      else
        return this.encodeFloat(value);
    },
    encodeFloat: function CFFCompiler_encodeFloat(num) {
      var value = num.toString();

      // rounding inaccurate doubles
      var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
      if (m) {
        var epsilon = parseFloat(&#x27;1e&#x27; + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(num * epsilon) / epsilon).toString();
      }

      var nibbles = &#x27;&#x27;;
      for (var i = 0, ii = value.length; i &lt; ii; ++i) {
        var a = value[i];
        if (a === &#x27;e&#x27;) {
          nibbles += value[++i] === &#x27;-&#x27; ? &#x27;c&#x27; : &#x27;b&#x27;;
        } else if (a === &#x27;.&#x27;) {
          nibbles += &#x27;a&#x27;;
        } else if (a === &#x27;-&#x27;) {
          nibbles += &#x27;e&#x27;;
        } else {
          nibbles += a;
        }
      }
      nibbles += (nibbles.length &amp; 1) ? &#x27;f&#x27; : &#x27;ff&#x27;;
      var out = [30];
      for (var i = 0, ii = nibbles.length; i &lt; ii; i += 2) {
        out.push(parseInt(nibbles.substr(i, 2), 16));
      }
      return out;
    },
    encodeInteger: function CFFCompiler_encodeInteger(value) {
      var code;
      if (value &gt;= -107 &amp;&amp; value &lt;= 107) {
        code = [value + 139];
      } else if (value &gt;= 108 &amp;&amp; value &lt;= 1131) {
        value = [value - 108];
        code = [(value &gt;&gt; 8) + 247, value &amp; 0xFF];
      } else if (value &gt;= -1131 &amp;&amp; value &lt;= -108) {
        value = -value - 108;
        code = [(value &gt;&gt; 8) + 251, value &amp; 0xFF];
      } else if (value &gt;= -32768 &amp;&amp; value &lt;= 32767) {
        code = [0x1c, (value &gt;&gt; 8) &amp; 0xFF, value &amp; 0xFF];
      } else {
        code = [0x1d,
                (value &gt;&gt; 24) &amp; 0xFF,
                (value &gt;&gt; 16) &amp; 0xFF,
                (value &gt;&gt; 8) &amp; 0xFF,
                 value &amp; 0xFF];
      }
      return code;
    },
    compileHeader: function CFFCompiler_compileHeader(header) {
      return [
        header.major,
        header.minor,
        header.hdrSize,
        header.offSize
      ];
    },
    compileNameIndex: function CFFCompiler_compileNameIndex(names) {
      var nameIndex = new CFFIndex();
      for (var i = 0, ii = names.length; i &lt; ii; ++i)
        nameIndex.add(stringToArray(names[i]));
      return this.compileIndex(nameIndex);
    },
    compileTopDicts: function CFFCompiler_compileTopDicts(dicts,
                                                          length,
                                                          removeCidKeys) {
      var fontDictTrackers = [];
      var fdArrayIndex = new CFFIndex();
      for (var i = 0, ii = dicts.length; i &lt; ii; ++i) {
        var fontDict = dicts[i];
        if (removeCidKeys) {
          fontDict.removeByName(&#x27;CIDFontVersion&#x27;);
          fontDict.removeByName(&#x27;CIDFontRevision&#x27;);
          fontDict.removeByName(&#x27;CIDFontType&#x27;);
          fontDict.removeByName(&#x27;CIDCount&#x27;);
          fontDict.removeByName(&#x27;UIDBase&#x27;);
        }
        var fontDictTracker = new CFFOffsetTracker();
        var fontDictData = this.compileDict(fontDict, fontDictTracker);
        fontDictTrackers.push(fontDictTracker);
        fdArrayIndex.add(fontDictData);
        fontDictTracker.offset(length);
      }
      fdArrayIndex = this.compileIndex(fdArrayIndex, fontDictTrackers);
      return {
        trackers: fontDictTrackers,
        output: fdArrayIndex
      };
    },
    compilePrivateDicts: function CFFCompiler_compilePrivateDicts(dicts,
                                                                  trackers,
                                                                  output) {
      for (var i = 0, ii = dicts.length; i &lt; ii; ++i) {
        var fontDict = dicts[i];
        assert(fontDict.privateDict &amp;&amp; fontDict.hasName(&#x27;Private&#x27;),
               &#x27;There must be an private dictionary.&#x27;);
        var privateDict = fontDict.privateDict;
        var privateDictTracker = new CFFOffsetTracker();
        var privateDictData = this.compileDict(privateDict, privateDictTracker);

        var outputLength = output.length;
        privateDictTracker.offset(outputLength);
        if (!privateDictData.length) {
          // The private dictionary was empty, set the output length to zero to
          // ensure the offset length isn&#x27;t out of bounds in the eyes of the
          // sanitizer.
          outputLength = 0;
        }

        trackers[i].setEntryLocation(&#x27;Private&#x27;,
                                     [privateDictData.length, outputLength],
                                     output);
        output.add(privateDictData);

        if (privateDict.subrsIndex &amp;&amp; privateDict.hasName(&#x27;Subrs&#x27;)) {
          var subrs = this.compileIndex(privateDict.subrsIndex);
          privateDictTracker.setEntryLocation(&#x27;Subrs&#x27;, [privateDictData.length],
                                              output);
          output.add(subrs);
        }
      }
    },
    compileDict: function CFFCompiler_compileDict(dict, offsetTracker) {
      var out = [];
      // The dictionary keys must be in a certain order.
      var order = dict.order;
      for (var i = 0; i &lt; order.length; ++i) {
        var key = order[i];
        if (!(key in dict.values))
          continue;
        var values = dict.values[key];
        var types = dict.types[key];
        if (!isArray(types)) types = [types];
        if (!isArray(values)) values = [values];

        // Remove any empty dict values.
        if (values.length === 0)
          continue;

        for (var j = 0, jj = types.length; j &lt; jj; ++j) {
          var type = types[j];
          var value = values[j];
          switch (type) {
            case &#x27;num&#x27;:
            case &#x27;sid&#x27;:
              out = out.concat(this.encodeNumber(value));
              break;
            case &#x27;offset&#x27;:
              // For offsets we just insert a 32bit integer so we don&#x27;t have to
              // deal with figuring out the length of the offset when it gets
              // replaced later on by the compiler.
              var name = dict.keyToNameMap[key];
              // Some offsets have the offset and the length, so just record the
              // position of the first one.
              if (!offsetTracker.isTracking(name))
                offsetTracker.track(name, out.length);
              out = out.concat([0x1d, 0, 0, 0, 0]);
              break;
            case &#x27;array&#x27;:
            case &#x27;delta&#x27;:
              out = out.concat(this.encodeNumber(value));
              for (var k = 1, kk = values.length; k &lt; kk; ++k)
                out = out.concat(this.encodeNumber(values[k]));
              break;
            default:
              error(&#x27;Unknown data type of &#x27; + type);
              break;
          }
        }
        out = out.concat(dict.opcodes[key]);
      }
      return out;
    },
    compileStringIndex: function CFFCompiler_compileStringIndex(strings) {
      var stringIndex = new CFFIndex();
      for (var i = 0, ii = strings.length; i &lt; ii; ++i)
        stringIndex.add(stringToArray(strings[i]));
      return this.compileIndex(stringIndex);
    },
    compileGlobalSubrIndex: function CFFCompiler_compileGlobalSubrIndex() {
      var globalSubrIndex = this.cff.globalSubrIndex;
      this.out.writeByteArray(this.compileIndex(globalSubrIndex));
    },
    compileCharStrings: function CFFCompiler_compileCharStrings(charStrings) {
      return this.compileIndex(charStrings);
    },
    compileCharset: function CFFCompiler_compileCharset(charset) {
      return this.compileTypedArray(charset.raw);
    },
    compileEncoding: function CFFCompiler_compileEncoding(encoding) {
      return this.compileTypedArray(encoding.raw);
    },
    compileFDSelect: function CFFCompiler_compileFDSelect(fdSelect) {
      return this.compileTypedArray(fdSelect);
    },
    compileTypedArray: function CFFCompiler_compileTypedArray(data) {
      var out = [];
      for (var i = 0, ii = data.length; i &lt; ii; ++i)
        out[i] = data[i];
      return out;
    },
    compileIndex: function CFFCompiler_compileIndex(index, trackers) {
      trackers = trackers || [];
      var objects = index.objects;
      // First 2 bytes contains the number of objects contained into this index
      var count = objects.length;

      // If there is no object, just create an index. This technically
      // should just be [0, 0] but OTS has an issue with that.
      if (count === 0)
        return [0, 0, 0];

      var data = [(count &gt;&gt; 8) &amp; 0xFF, count &amp; 0xff];

      var lastOffset = 1;
      for (var i = 0; i &lt; count; ++i)
        lastOffset += objects[i].length;

      var offsetSize;
      if (lastOffset &lt; 0x100)
        offsetSize = 1;
      else if (lastOffset &lt; 0x10000)
        offsetSize = 2;
      else if (lastOffset &lt; 0x1000000)
        offsetSize = 3;
      else
        offsetSize = 4;

      // Next byte contains the offset size use to reference object in the file
      data.push(offsetSize);

      // Add another offset after this one because we need a new offset
      var relativeOffset = 1;
      for (var i = 0; i &lt; count + 1; i++) {
        if (offsetSize === 1) {
          data.push(relativeOffset &amp; 0xFF);
        } else if (offsetSize === 2) {
          data.push((relativeOffset &gt;&gt; 8) &amp; 0xFF,
                     relativeOffset &amp; 0xFF);
        } else if (offsetSize === 3) {
          data.push((relativeOffset &gt;&gt; 16) &amp; 0xFF,
                    (relativeOffset &gt;&gt; 8) &amp; 0xFF,
                     relativeOffset &amp; 0xFF);
        } else {
          data.push((relativeOffset &gt;&gt;&gt; 24) &amp; 0xFF,
                    (relativeOffset &gt;&gt; 16) &amp; 0xFF,
                    (relativeOffset &gt;&gt; 8) &amp; 0xFF,
                     relativeOffset &amp; 0xFF);
        }

        if (objects[i])
          relativeOffset += objects[i].length;
      }
      var offset = data.length;

      for (var i = 0; i &lt; count; i++) {
        // Notify the tracker where the object will be offset in the data.
        if (trackers[i])
          trackers[i].offset(data.length);
        for (var j = 0, jj = objects[i].length; j &lt; jj; j++)
          data.push(objects[i][j]);
      }
      return data;
    }
  };
  return CFFCompiler;
})();

// Workaround for seac on Windows.
(function checkSeacSupport() {
  if (/Windows/.test(navigator.userAgent)) {
    SEAC_ANALYSIS_ENABLED = true;
  }
})();

// Workaround for Private Use Area characters in Chrome on Windows
// http://code.google.com/p/chromium/issues/detail?id=122465
// https://github.com/mozilla/pdf.js/issues/1689
(function checkChromeWindows() {
  if (/Windows.*Chrome/.test(navigator.userAgent)) {
    SYMBOLIC_FONT_GLYPH_OFFSET = 0xF100;
  }
})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
